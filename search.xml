<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[字符编码Unicode原理数据流压缩Zlib与Miniz的实现]]></title>
    <url>%2F2020%2F10%2F08%2F%E5%AD%97%E7%AC%A6%E7%BC%96%E7%A0%81Unicode%E5%8E%9F%E7%90%86%E6%95%B0%E6%8D%AE%E6%B5%81%E5%8E%8B%E7%BC%A9Zlib%E4%B8%8EMiniz%E7%9A%84%E5%AE%9E%E7%8E%B0%2F</url>
    <content type="text"><![CDATA[字符Unicode其实是根据码表转化映射出图形。根据码表找到位图文件显示出文字。 UTF-8 1-6字节UTF-16 2或4字节UTF-32 4字节 通过前缀码，编译器可以知道是这个文件是按什么格式编码的。 Mysql的“uft8”不是真正的UTF-8，“utf8”只支持每个字符最多3个字节。 Mysql真正的UTF-8是”utf8mb4”。]]></content>
      <categories>
        <category>基础</category>
      </categories>
      <tags>
        <tag>基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Golang 系统监控]]></title>
    <url>%2F2020%2F10%2F07%2FGolang-%E7%B3%BB%E7%BB%9F%E7%9B%91%E6%8E%A7%2F</url>
    <content type="text"><![CDATA[系统监控程序会定期的检查上次垃圾回收器什么时候执行的，如果发现已经有很长时间没有执行垃圾回收操作了，它就强制执行一次回收。 它来定期扫描自由内存块，如果长时间不用，它就会建议操作系统把物理内存收回去。 在函数头部插入一段汇编指令：第一件事用来判断栈帧空间够不够用，不够用进行扩张第二件事检查当前的G执行多长，如果系统调度发出抢占通知，立即中止G执行。]]></content>
      <categories>
        <category>基础</category>
      </categories>
      <tags>
        <tag>Golang</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Golang 并发]]></title>
    <url>%2F2020%2F10%2F07%2FGolang-%E5%B9%B6%E5%8F%91%2F</url>
    <content type="text"><![CDATA[PMG模型 第一本地队列超过 256 个任务转移一半任务到全局队列，第二本地队列执行 60 个任务则到全局队列执行一个确保公平性。 runnextG对象有runnext属性，记录最后一个G对象。执行 runnext 优先，然后 runq 队列。 栈内存M 的所有的状态都保存在 G 任务栈，优点是在任意时 M 都能上下文切换。 M 使用的栈保存在 G 栈上，切换时只需要把 M 使用的 SP 等寄存器保存到 G 的寄存器上，保存后 M 就可以上下文切换。 G 自带栈可以从 2KB 扩容到 1GB，那么怎么扩容呢？实际上重新分配两倍的内存，然后把数据拷贝进来，栈指针指向新的地址，原来的释放掉，称之为拷贝栈。收缩也一样，创建小一点的块，把数据拷贝进来，用它来替换原来的释放。]]></content>
      <categories>
        <category>基础</category>
      </categories>
      <tags>
        <tag>Golang</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[垃圾回收]]></title>
    <url>%2F2020%2F10%2F07%2F%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%2F</url>
    <content type="text"><![CDATA[引用计数引用计数实现方式非常简单，每个对象头部有一个计数器，引用对象时计数器加一，取消引用时计数器减一，等于零时释放内存。 缺点：1.易内存泄漏2.不支持循环引用 代龄代龄机制是这样的，对象通常分成三级代龄 0、1、2。新创建的对象的代龄是 0，每级代龄都有阈值，当 0 级对象数量超过阈值就会启动垃圾回收，垃圾回收扫描所有 0 级代龄对象，扫描完对象是活着或者死着两种状态。理论来说在第一次回收活着对象在第二次回收活着几率很高，垃圾回收器把第一次扫描活着对象标记为 1 级代龄对象，下次扫描 0 级代龄对象不用扫描第一次扫描过的对象，减少扫描对象的数量。当 1 级代龄对象数量超过阈值便扫描 1 级代龄对象，如果 1 级代龄还活着说明这个对象生命周期更长，就标记为 2 级代龄对象。 优点1：减少扫描对象数量优点2：支持内存压缩 标记清理回收器启动把所有对象标记成白色。A引用B，B变成灰色。白色可以释放。下次扫描灰色。B变成黑色，如果B引用C。C依然是灰色。不断递归，只剩黑色和白色。那么黑色的都是活着的白色的都是死的。 并发清理回收白色对象的时候可以和用户逻辑并发。 写屏障一旦进入垃圾回收状态时进行短暂 STW 暂停，打开标记位标记为正在执行垃圾回收。扫描当时状态。在垃圾回收阶段重新引用另外新对象，这个屏障把这种行为重新过滤。 信用授权回收的速度跟不上分配的速度垃圾回收器会把用户逻辑暂停，用户逻辑暂停后不会有新的对象出现。黑白对象标记完的对象数量累计到公共账户信用值，如果小于等于零则调度切换为垃圾回收，切换后不停的增加信用值和检查公共账户信用值，尽早提前结束切换执行用户代码，保证用户代码和垃圾回收的并行。]]></content>
      <categories>
        <category>基础</category>
      </categories>
      <tags>
        <tag>垃圾回收</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[内存分配器]]></title>
    <url>%2F2020%2F10%2F07%2F%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E5%99%A8%2F</url>
    <content type="text"><![CDATA[为了避免程序频繁的向操作系统申请，占用更多的空间延长内存的使用时间。可以一次性申请多一部分的内存重复使用。例如：对象池、连接池。并且一次性申请大块内存可以做到连续分配，通过相邻的地址空间的合并减少碎片化。 虚拟地址空间如何使用每个进程有一个虚拟地址空间，内存分配在某段虚拟地址空间内就能保证是连续的。 1.让操作系统随机开始，保留一段地址空间，如果失败，加上或者减去偏移量重新选择。2.如果连续的方式不行使用分段的方式。空间扩展尝试同一方向扩展，失败则换个相反方向扩展，这样空间还是连续的。操作系统随机从两个方向扩展的方式称之为稀疏堆。3.使用一个数组。数组存储内存指针指向自由块，自由块有各种状态，比如当前使用多少内存、是否是空闲状态等，形成类似反查表的作用。自由块的内存起始地址减去初始位置得到偏移量，偏移量按页大小对齐作为数组索引。这样的优点是只需检查数组就知道内存分配的信息、检查相邻的两项的是否空闲可以合并成大块内存。通过反查表实现碎片化问题。 Go管理内存框架 内存分配的完整流程首先检查 Cache 里有没有自由块，有的话直接返回；没有的话计算向哪个 Central 申请，如果 Central 有则取回一批，如果没有，则向Heap申请大块自由块切割，如果Heap没有多余的自由块，Heap向操作系统申请。Go语言在初始化时建立一个静态表，通过静态表知道一次取多少个，这个数字是基于大量的统计得到的，有些语言根据程序运行期动态调整这个数字。 任何时候内存管理都会涉及两个核心问题。 第一个快速分配，比如实现无锁操作或者减少锁。因为 Central 被很多Cache共享，操作数据必须加锁处理，Heap 被很多 Central 共享，操作数据要加锁。 第二个尽可能在内存复用方面做到平衡。快速操作意味着用批处理代替单次处理实现性能提升，但是批处理会浪费大量的资源。所以一来用批处理来实现快速分配操作的性能，一来实现内存节约避免快速消耗，需要在中间找到平衡点。]]></content>
      <categories>
        <category>基础</category>
      </categories>
      <tags>
        <tag>内存</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[线程池]]></title>
    <url>%2F2020%2F10%2F07%2F%E7%BA%BF%E7%A8%8B%E6%B1%A0%2F</url>
    <content type="text"><![CDATA[123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#include &lt;assert.h&gt;#include &lt;stdarg.h&gt;#include &lt;pthread.h&gt;#define LL_ADD(item, list) do &#123; \ item-&gt;prev = NULL; \ item-&gt;next = list; \ list = item; \&#125; while(0)#define LL_REMOVE(item, list) do &#123; \ if (item-&gt;prev != NULL) item-&gt;prev-&gt;next = item-&gt;next; \ if (item-&gt;next != NULL) item-&gt;next-&gt;prev = item-&gt;prev; \ if (list == item) list = item-&gt;next; \ item-&gt;prev = item-&gt;next = NULL; \&#125; while(0)//执行（线程ID，终止标识，池管理组件对象）typedef struct NWORKER &#123; pthread_t thread; int terminate; struct NWORKQUEUE *workqueue; struct NWORKER *prev; struct NWORKER *next;&#125; nWorker;//任务（任务回调函数，任务执行的参数）typedef struct NJOB &#123; void (*job_function)(struct NJOB *job); void *user_data; struct NJOB *prev; struct NJOB *next;&#125; nJob;//池管理组件（互斥锁，条件变量，执行队列，任务队列）typedef struct NWORKQUEUE &#123; struct NWORKER *workers; struct NJOB *waiting_jobs; pthread_mutex_t jobs_mtx; pthread_cond_t jobs_cond;&#125; nWorkQueue;typedef nWorkQueue nThreadPool;static void *ntyWorkerThread(void *ptr) &#123; nWorker *worker = (nWorker*)ptr; while (1) &#123; pthread_mutex_lock(&amp;worker-&gt;workqueue-&gt;jobs_mtx); while (worker-&gt;workqueue-&gt;waiting_jobs == NULL) &#123; if (worker-&gt;terminate) break; pthread_cond_wait(&amp;worker-&gt;workqueue-&gt;jobs_cond, &amp;worker-&gt;workqueue-&gt;jobs_mtx); &#125; if (worker-&gt;terminate) &#123; pthread_mutex_unlock(&amp;worker-&gt;workqueue-&gt;jobs_mtx); break; &#125; nJob *job = worker-&gt;workqueue-&gt;waiting_jobs; if (job != NULL) &#123; LL_REMOVE(job, worker-&gt;workqueue-&gt;waiting_jobs); &#125; pthread_mutex_unlock(&amp;worker-&gt;workqueue-&gt;jobs_mtx); if (job == NULL) continue; job-&gt;job_function(job); &#125; free(worker); pthread_exit(NULL);&#125;int ntyThreadPoolCreate(nThreadPool *workqueue, int numWorkers) &#123; if (numWorkers &lt; 1) numWorkers = 1; memset(workqueue, 0, sizeof(nThreadPool)); pthread_cond_t blank_cond = PTHREAD_COND_INITIALIZER; memcpy(&amp;workqueue-&gt;jobs_cond, &amp;blank_cond, sizeof(workqueue-&gt;jobs_cond)); pthread_mutex_t blank_mutex = PTHREAD_MUTEX_INITIALIZER; memcpy(&amp;workqueue-&gt;jobs_mtx, &amp;blank_mutex, sizeof(workqueue-&gt;jobs_mtx)); int i = 0; for (i = 0;i &lt; numWorkers;i ++) &#123; nWorker *worker = (nWorker*)malloc(sizeof(nWorker)); if (worker == NULL) &#123; perror(&quot;malloc&quot;); return 1; &#125; memset(worker, 0, sizeof(nWorker)); worker-&gt;workqueue = workqueue; //printf(&quot;pthread_create --&gt; %d\n&quot;, i); int ret = pthread_create(&amp;worker-&gt;thread, NULL, ntyWorkerThread, (void *)worker); if (ret) &#123; perror(&quot;pthread_create&quot;); free(worker); return 1; &#125; LL_ADD(worker, worker-&gt;workqueue-&gt;workers); &#125; return 0;&#125;void ntyThreadPoolShutdown(nThreadPool *workqueue) &#123; nWorker *worker = NULL; for (worker = workqueue-&gt;workers;worker != NULL;worker = worker-&gt;next) &#123; worker-&gt;terminate = 1; &#125; pthread_mutex_lock(&amp;workqueue-&gt;jobs_mtx); workqueue-&gt;workers = NULL; workqueue-&gt;waiting_jobs = NULL; pthread_cond_broadcast(&amp;workqueue-&gt;jobs_cond); pthread_mutex_unlock(&amp;workqueue-&gt;jobs_mtx); &#125;void ntyThreadPoolQueue(nThreadPool *workqueue, nJob *job) &#123; pthread_mutex_lock(&amp;workqueue-&gt;jobs_mtx); LL_ADD(job, workqueue-&gt;waiting_jobs); pthread_cond_signal(&amp;workqueue-&gt;jobs_cond); pthread_mutex_unlock(&amp;workqueue-&gt;jobs_mtx); &#125;#define KING_MAX_THREAD 80#define KING_COUNTER_SIZE 1000void king_counter(nJob *job) &#123; int index = *(int*)job-&gt;user_data; printf(&quot;index : %d, selfid : %lu\n&quot;, index, pthread_self()); free(job-&gt;user_data); free(job);&#125;int main(int argc, char *argv[]) &#123; nThreadPool pool; ntyThreadPoolCreate(&amp;pool, KING_MAX_THREAD); int i = 0; for (i = 0;i &lt; KING_COUNTER_SIZE;i ++) &#123; nJob *job = (nJob*)malloc(sizeof(nJob)); if (job == NULL) &#123; perror(&quot;malloc&quot;); exit(1); &#125; job-&gt;job_function = king_counter; job-&gt;user_data = malloc(sizeof(int)); *(int*)job-&gt;user_data = i; ntyThreadPoolQueue(&amp;pool, job); &#125; getchar(); printf(&quot;\n&quot;); &#125;]]></content>
      <categories>
        <category>基础</category>
      </categories>
      <tags>
        <tag>线程池</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[无锁CAS无锁队列]]></title>
    <url>%2F2020%2F10%2F07%2F%E6%97%A0%E9%94%81CAS%E6%97%A0%E9%94%81%E9%98%9F%E5%88%97%2F</url>
    <content type="text"><![CDATA[#include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;pthread.h&gt; #include &lt;mutex&gt; #include &lt;time.h&gt; #include &lt;atomic&gt; #include &lt;list&gt; #include &lt;memory&gt; #define MAX_THREAD_NUM 1 #define FOR_LOOP_COUNT 10000000 static int counter = 0; static pthread_spinlock_t spinlock; static std::mutex s_mutex; static int s_count_push = 0; static int s_count_pop = 0; // using namespace lock_free; // 有锁队列，直接使用list static std::list&lt;int&gt; s_list; typedef void *(*thread_func_t)(void *argv); static int lxx_atomic_add(int *ptr, int increment) { int old_value = *ptr; __asm__ volatile(&quot;lock; xadd %0, %1 \n\t&quot; : &quot;=r&quot;(old_value), &quot;=m&quot;(*ptr) : &quot;0&quot;(increment), &quot;m&quot;(*ptr) : &quot;cc&quot;, &quot;memory&quot;); return *ptr; } template &lt;typename ElemType&gt; struct qnode // 链表节点 { struct qnode *_next; ElemType _data; }; template &lt;typename ElemType&gt; class Queue { private: struct qnode&lt;ElemType&gt; *volatile _head = NULL; // 随着pop后指向的位置是不一样的, head不是固定的 struct qnode&lt;ElemType&gt; *volatile _tail = NULL; public: Queue() { _head = _tail = new qnode&lt;ElemType&gt;; _head-&gt;_next = NULL; _tail-&gt;_next = NULL; printf(&quot;Queue _head:%p\n&quot;, _head); } void push(const ElemType &amp;e) { struct qnode&lt;ElemType&gt; *p = new qnode&lt;ElemType&gt;; p-&gt;_data = e; p-&gt;_next = NULL; struct qnode&lt;ElemType&gt; *t = _tail; // 获取尾部 t-&gt;_next = p; // 插到尾部 _tail = p; // 更新尾部节点 } void push2(const ElemType &amp;e) { struct qnode&lt;ElemType&gt; *p = new qnode&lt;ElemType&gt;; // printf(&quot;push head:%p, p:%p\n&quot;, _head, p); p-&gt;_next = NULL; p-&gt;_data = e; struct qnode&lt;ElemType&gt; *t = _tail; struct qnode&lt;ElemType&gt; *old_t = _tail; int count = 0; do { while (t-&gt;_next != NULL) // 非空的时候要去更新 t-&gt;_next t = t-&gt;_next; // 找到最后的节点 if (count++ &gt;= 1) { printf(&quot;push count:%d, t-&gt;_next:%p\n&quot;, count, t-&gt;_next); } // 将null换为p即是插入的节点 } while (!__sync_bool_compare_and_swap(&amp;t-&gt;_next, NULL, p)); // 将最后的节点_tail更换为p节点 __sync_bool_compare_and_swap(&amp;_tail, old_t, p); } bool pop(ElemType &amp;e) { struct qnode&lt;ElemType&gt; *p = _head; // 头结点 struct qnode&lt;ElemType&gt; *np = _head-&gt;_next; // 首元素节点 if (!np) { return false; } e = np-&gt;_data; _head-&gt;_next = np-&gt;_next; delete np; return true; } bool pop2(ElemType &amp;e) { struct qnode&lt;ElemType&gt; *p = NULL; struct qnode&lt;ElemType&gt; *np = NULL; int count = 0; do { p = _head; // 头节点，不真正存储数据 np = p-&gt;_next; if (p-&gt;_next == NULL) // 首元节点为空，则返回 { return false; } if (count++ &gt;= 1) { printf(&quot;pop count:%d, p-&gt;_next:%p\n&quot;, count, p-&gt;_next); } // 更新头结点位置 } while (!__sync_bool_compare_and_swap(&amp;_head, p, p-&gt;_next)); e = p-&gt;_next-&gt;_data; // printf(&quot;pop p:%p\n&quot;, p); delete p; // 因为我们已经将头部节点换成了p-&gt;_next, 所以可以释放掉 return true; } ~Queue() { struct qnode&lt;ElemType&gt; *volatile tmp; while (_head) { tmp = _head-&gt;_next; printf(&quot;_head:%p\n&quot;, _head); delete _head; _head = tmp; } } }; void *mutex_thread_push(void *argv) { for (int i = 0; i &lt; FOR_LOOP_COUNT; i++) { s_mutex.lock(); s_count_push++; s_list.push_back(i); s_mutex.unlock(); } return NULL; } void *mutex_thread_pop(void *argv) { while (true) { int value = 0; s_mutex.lock(); if (s_list.size() &gt; 0) { value = s_list.front(); s_list.pop_front(); s_count_pop++; } s_mutex.unlock(); if (s_count_pop &gt;= FOR_LOOP_COUNT * MAX_THREAD_NUM) { printf(&quot;%s dequeue:%d\n&quot;, __FUNCTION__, value); break; } } printf(&quot;%s exit\n&quot;, __FUNCTION__); return NULL; } static Queue&lt;int&gt; s_queue; void *queue_free_thread_push(void *argv) { for (int i = 0; i &lt; FOR_LOOP_COUNT; i++) { s_queue.push2(i); lxx_atomic_add(&amp;s_count_push, 1); // printf(&quot;s_count_push:%d\n&quot;,s_count_push); } return NULL; } void *queue_free_thread_pop(void *argv) { // for (int i = 0; i &lt; FOR_LOOP_COUNT*5; i++) int last_value = 0; static int s_pid_count = 0; s_pid_count++; int pid = s_pid_count; while (true) { int value = 0; if (s_queue.pop2(value)) { last_value = value; if (s_count_pop != value) { printf(&quot;pid:%d, -&gt; value:%d, expected:%d\n&quot;, pid, value, s_count_pop); } s_count_pop++; // printf(&quot;pid:%d, -&gt; value:%d\n&quot;, pid, value); } else { // printf(&quot;pid:%d, null\n&quot;, pid); } if (s_count_pop &gt;= FOR_LOOP_COUNT * MAX_THREAD_NUM) { printf(&quot;%s dequeue:%d\n&quot;, __FUNCTION__, last_value); break; } } printf(&quot;%s exit\n&quot;, __FUNCTION__); return NULL; } int test_queue(thread_func_t func_push, thread_func_t func_pop, char **argv) { clock_t start = clock(); pthread_t tid_push[MAX_THREAD_NUM] = {0}; for (int i = 0; i &lt; MAX_THREAD_NUM; i++) { int ret = pthread_create(&amp;tid_push[i], NULL, func_push, argv); if (0 != ret) { printf(&quot;create thread failed\n&quot;); } } pthread_t tid_pop[MAX_THREAD_NUM] = {0}; for (int i = 0; i &lt; MAX_THREAD_NUM; i++) { int ret = pthread_create(&amp;tid_pop[i], NULL, func_pop, argv); if (0 != ret) { printf(&quot;create thread failed\n&quot;); } } for (int i = 0; i &lt; MAX_THREAD_NUM; i++) { pthread_join(tid_push[i], NULL); } for (int i = 0; i &lt; MAX_THREAD_NUM; i++) { pthread_join(tid_pop[i], NULL); } clock_t end = clock(); printf(&quot;spend clock : %ld, push:%d, pop:%d\n&quot;, (end - start) / CLOCKS_PER_SEC, s_count_push, s_count_pop); return 0; } // 多尝试几次 g++ -o 4_test_queue 4_test_queue.cpp -lpthread -latomic -std=c++11 int main(int argc, char **argv) { printf(&quot;THREAD_NUM:%d\n\n&quot;, MAX_THREAD_NUM); for (int i = 0; i &lt; 100; i++) { s_count_push = 0; s_count_pop = 0; printf(&quot;\n\n---------&gt;i:%d\n\n&quot;, i); printf(&quot;use mutex queue -----------&gt;\n&quot;); test_queue(mutex_thread_push, mutex_thread_pop, NULL); s_count_push = 0; s_count_pop = 0; printf(&quot;\nuse queue_free queue -----------&gt;\n&quot;); test_queue(queue_free_thread_push, queue_free_thread_pop, NULL); } printf(&quot;finish\n&quot;); return 0; }]]></content>
      <categories>
        <category>基础</category>
      </categories>
      <tags>
        <tag>CAS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[进程协程线程]]></title>
    <url>%2F2020%2F09%2F27%2F%E8%BF%9B%E7%A8%8B%E5%8D%8F%E7%A8%8B%E7%BA%BF%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[进程是一种资源单位，操作系统按照进程来分配资源管理资源。线程是进程内的，专门用来执行。 线程线程我们严格意义上来说指的是任务加上任务执行所需的资源，称之为线程，如果线程只是执行单位没有任何资源，称之为任务，它是可复用的，线程本身有状态的，因为线程执行时有线程栈，所以任务加上任务执行所需的线程栈等资源称之为线程。 系统线程与用户线程 系统线程指的是操作系统提供的的任务单元。用户线程指的是在用户空间实现的一些并发任务，跟操作系统没关系。 线程池模型使用池模型不再需要频繁的创建系统线程，用户态可以创建很多用来存储状态的执行单位。执行时把它绑定到一个系统线程上去执行，执行完把系统线程释放，系统线程把绑定状态删除放到池中，不需要杀掉系统线程，接下来另外一个执行单位重新的绑定到这个系统线程上去执行。 如下图所示： 首先创建一定数量的系统线程专门用来执行的。其次在用户态空间创建一些对象专门用来保存执行时所需要的状态，包括线程栈。它不负责执行，它只是很普通的数据抽象容器。它执行时把它绑定到某个系统线程上，这个系统线程就具备了普通线程状态然后去执行，执行完把这个线程的状态全部剥离，这个线程就恢复成原始状态，接下来可以执行其他的任务。 实现用户态的执行和系统态的执行分离，避免反复系统调用所消耗的资源。 协程为了充分利用时间片，利用异步机制，在用户态实现调度机制把阻塞的时间片执行其他的任务，当任务执行完成时，下次再执行时去检查返回的事件，把事件返回的结果返还给原先任务。 很明显，协程是串行不是并行，它的执行序是执行 A 任务，当 A 任务阻塞时唤醒 B 任务，B 任务执行结束检查 A 的结果是否有返回，不断的切换实现多任务并发。 上下文切换对性能的影响无论进程级别、线程级别、主动系统调用引发的上下文切换都会造成一定的性能损失。尽可能的减少系统调用实际上是减少上下文切换造成的性能损失。因为离 CPU 近的资源比如 L 级的 Cache，寄存器数据都要写回到主存，系统代码执行完要把主存数据读回来，相对 CPU 执行速度从主存操作数据非常慢。]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式]]></title>
    <url>%2F2020%2F09%2F26%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[填坑，待补…..]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[http]]></title>
    <url>%2F2020%2F09%2F26%2Fhttp%2F</url>
    <content type="text"><![CDATA[简介HTTP 协议，即超文本传输协议(Hypertext transfer protocol)。是一种详细规定了浏览器和万维网(WWW = World Wide Web)服务器之间互相通信的规则，通过因特网传送万维网文档的数据传送协议，可以传输文本，图片，视频等。 简单快速：协议简单，通信速度快；灵活：HTTP 允许传输任意类型的数据对象。正在传输的类型由 Content-Type 加以标记；无状态：：HTTP 协议是无状态协议。无状态是指协议对于事务处理没有记忆能力。缺少状态意味着如果后续处理需要前面的信息，则它必须重传，这样可能导致每次连接传送的数据量增大。另一方面，在服务器不需要先前信息时它的应答就较快。 http工作原理以下是 HTTP 请求/响应的步骤：1、客户端连接到 Web 服务器一个 HTTP 客户端，通常是浏览器，与 Web 服务器的 HTTP 端口（默认为 80）建立一个 TCP套接字连接。例如，http://www.0voice.com。2、发送 HTTP 请求通过 TCP 套接字，客户端向 Web 服务器发送一个文本的请求报文，一个请求报文由请求行、请求头部、空行和请求数据 4 部分组成。3、服务器接受请求并返回 HTTP 响应Web 服务器解析请求，定位请求资源。服务器将资源复本写到 TCP 套接字，由客户端读取。一个响应由状态行、响应头部、空行和响应数据 4 部分组成。4、释放连接 TCP 连接若 connection 模式为 close，则服务器主动关闭 TCP 连接，客户端被动关闭连接，释放 TCP连接;若 connection 模式为 keepalive，则该连接会保持一段时间，在该时间内可以继续接收请求;5、客户端浏览器解析 HTML 内容客户端浏览器首先解析状态行，查看表明请求是否成功的状态代码。然后解析每一个响应头，响应头告知以下为若干字节的 HTML 文档和文档的字符集。客户端浏览器读取响应数据HTML，根据 HTML 的语法对其进行格式化，并在浏览器窗口中显示。 http请求方法根据 HTTP 标准，HTTP 请求可以使用多种请求方法。HTTP1.0 定义了三种请求方法: GET、POST 和 HEAD 方法。HTTP1.1 新增了六种请求方法: OPTIONS、PUT、PATCH、DELETE、TRACE 和 CONNECT 方法。 1 GET 请求指定的页面信息，并返回实体主体。2 HEAD 类似于 GET 请求，只不过返回的响应中没有具体的内容，用于获取报头3 POST 向指定资源提交数据进行处理请求（例如提交表单或者上传文件）。数据被包含在请求体中。POST 请求可能会导致新的资源的建立和/或已有资源的修改。4 PUT 从客户端向服务器传送的数据取代指定的文档的内容。5 DELETE 请求服务器删除指定的页面。6 CONNECT HTTP/1.1 协议中预留给能够将连接改为管道方式的代理服务器。7 OPTIONS 允许客户端查看服务器的性能。8 TRACE 回显服务器收到的请求，主要用于测试或诊断。9 PATCH 是对 PUT 方法的补充，用来对已知资源进行局部更新 。 GET和POST区别1、GET 提交的数据会放在 URL 之后，以?分割 URL 和传输数据，参数之间以&amp;相连，如http://localhost:8600/user?name=test1&amp;id=123456. POST 方法是把提交的数据放在 HTTP包的 Body 中。2、GET 提交的数据大小有限制（因为浏览器对 URL 的长度有限制），而 POST 方法提交的数据没有限制。3、GET 方式需要使用 Request.QueryString 来取得变量的值，而 POST 方式通过 Request.Form来获取变量的值。4、GET 方式提交数据，会带来安全问题，比如一个登录页面，通过 GET 方式提交数据时，用户名和密码将出现在 URL 上，如果页面可以被缓存或者其他人可以访问这台机器，就可以从历史记录获得该用户的账号和密码。 http响应头信息 http状态码状态代码有三位数字组成，第一个数字定义了响应的类别，共分五种类别:1xx：指示信息–表示请求已接收，继续处理2xx：成功–表示请求已被成功接收、理解、接受3xx：重定向–要完成请求必须进行更进一步的操作4xx：客户端错误–请求有语法错误或请求无法实现5xx：服务器端错误–服务器未能实现合法的请求]]></content>
      <categories>
        <category>http</category>
      </categories>
      <tags>
        <tag>http</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[nginx]]></title>
    <url>%2F2020%2F09%2F24%2Fnginx%2F</url>
    <content type="text"><![CDATA[负载均衡可以在多个层上去做，nginx只是在应用层上面的负载均衡。 初识从配置入手 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647worker_processes 4; ##进程数events &#123; worker_connections 1024; #连接数&#125;http &#123; upstream backend &#123; #负载均衡 server 192.168.142.128 weight=2; server 192.168.142.129 weight=1; &#125; server &#123; listen 8888; server_name localhost; client_max_body_size 100m; #客户端最大包体 location / &#123;# root /usr/local/nginx/html/;# proxy_pass http://192.168.142.128; proxy_pass http://backend; &#125; location /images/ &#123; root /usr/local/nginx/; #静态资源映射 &#125; location ~ \.(mp3|mp4) &#123; root /usr/local/nginx/media/; &#125; &#125; server &#123; listen 9000; location ~ \.cgi &#123; fastcgi_pass 127.0.0.1:9001; fastcgi_index index.cgi; fastcgi_param SCRIPT_FILENAME cgi$fastcgi_script_name; include ../conf/fastcgi_params; &#125; &#125; &#125; cgi应用于在线编程工具，通过nginx映射到cgi端口，实际上并没有进入Server服务器，只是在cgi进程做的处理。fastcgi用进程池去处理。]]></content>
      <categories>
        <category>nginx</category>
      </categories>
      <tags>
        <tag>nginx</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mysql]]></title>
    <url>%2F2020%2F09%2F22%2Fmysql%2F</url>
    <content type="text"><![CDATA[数值类型 事务特征事务四大特征：原子性（Atomicity，或称不可分割性）、一致性（Consistency）、隔离性（Isolation，又称独立性）、持久性（Durability）。一致性：数据库在操作前和操作后，完整性不被破坏。隔离性：多个事务可以同时执行，防止多个事务并发执行引起交叉执行数据不一致。持久性：事务结束后，对数据的修改是永久的。 隔离级别（1）读未提交：read uncommitted（2）读已提交：read committed（3）可重复读：repeatable read（4）串行化：serializable undolog每一个事务都有undolog，事务开启时一个临时表存事务的操作，这个临时表就是undolog，一旦有错误就X掉这次事务。 优化四条从效果上第一条影响最大，后面越来越小。① SQL语句及索引的优化 ② 数据库表结构的优化③ 系统配置的优化④ 硬件的优化 锁表级锁行级锁页级锁 引擎Myisam(表级锁) Innodb(行级锁)1.为什么Myisam快？因为Myisam B+树存的是引用，加载到内存快。 等Innodb加载完，Myisam都查完了2.为什么Innodb不支持全文索引？数据直接在叶子结点上，如果要全文索引，相当于复制了一份数据库，浪费空间 binlog binlog实际是除了select以外所有操作数据库动作的记录，方便恢复数据库。master主动推送到slave结点的relay log，从结点io线程去读relay log然后在sql线程去更新数据库。]]></content>
      <categories>
        <category>mysql</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[redis补充]]></title>
    <url>%2F2020%2F09%2F20%2Fredis%E8%A1%A5%E5%85%85%2F</url>
    <content type="text"><![CDATA[扩容与缩容扩容当used &gt; size 的时候扩容，当进行持久化aof,rdb,script(lua事务) block的时候，如果used &gt; 5size 翻倍扩容缩容当used &lt; size * 0.1的时候缩容扩容和缩容导致rehashscan遇到扩充时 io多线程 zset当数据量少的时候用压缩列表当数据量大于128用跳表实现 redis与mongo的区别 协议 C语言使用Redis编译hiredis进入 redis-6.0.3/deps/hiredis$ make$ sudo make installmkdir -p /usr/local/include/hiredis /usr/local/include/hiredis/adapters /usr/local/libcp -pPR hiredis.h async.h read.h sds.h /usr/local/include/hirediscp -pPR adapters/*.h /usr/local/include/hiredis/adapterscp -pPR libhiredis.so /usr/local/lib/libhiredis.so.0.14cd /usr/local/lib &amp;&amp; ln -sf libhiredis.so.0.14 libhiredis.socp -pPR libhiredis.a /usr/local/libmkdir -p /usr/local/lib/pkgconfigcp -pPR hiredis.pc /usr/local/lib/pkgconfig可以看到头文件、和库文件的安装目录 连接Redis服务 授权 Auth redisCommand 详解原型void redisCommand(redisContext c, const char *format, …); 参数说明这个函数是一个带有不定参数的。可以按着 format 格式给出对应的参数，这就和 printf 函数类似。c 是一个 reidsConnect 函数返回的一个对象。 返回值返回值是一个 void 类型的指针，实际为指向一个 redisReply 类型的指针。12345678910111213141516redisReply 的定义/* This is the reply object returned by redisCommand() */typedef struct redisReply &#123; /*命令执行结果的返回类型*/ int type; /* REDIS_REPLY_* */ /*存储执行结果返回为整数*/ long long integer; /* The integer when type is REDIS_REPLY_INTEGER */ /*字符串值的长度*/ size_t len; /* Length of string */ /*存储命令执行结果返回是字符串*/ char *str; /* Used for both REDIS_REPLY_ERROR and REDIS_REPLY_STRING */ /*返回结果是数组的大小*/ size_t elements; /* number of elements, for REDIS_REPLY_ARRAY */ /*存储执行结果返回是数组*/ struct redisReply **element; /* elements vector for REDIS_REPLY_ARRAY */&#125; redisReply; 返回结果的类型 reply-&gt;type,reply 为 redisReply* 类型。• REDIS_REPLY_STRING == 1:返回值是字符串,字符串储存在 redis-&gt;str 当中,字符串长度为 redis-&gt;len。• REDIS_REPLY_ARRAY == 2：返回值是数组，数组大小存在 redis-&gt;elements 里面，数组值存储在 redis-&gt;element[i]里面。数组里面存储的是指向 redisReply 的指针，数组里面的返回值可以通过 redis-&gt;element[i]-&gt;str 来访问，数组的结果里全是type==REDIS_REPLY_STRING 的 redisReply 对象指针。• REDIS_REPLY_INTEGER == 3：返回值为整数 long long。• REDIS_REPLY_NIL==4：返回值为空表示执行结果为空。• REDIS_REPLY_STATUS ==5：返回命令执行的状态，比如 set foo bar 返回的状态为 OK，存储在 str 当中 reply-&gt;str == “OK”。• REDIS_REPLY_ERROR ==6 ：命令执行错误,错误信息存放在 reply-&gt;str 当中。]]></content>
      <categories>
        <category>redis</category>
      </categories>
      <tags>
        <tag>redis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[redis]]></title>
    <url>%2F2020%2F09%2F20%2Fredis%2F</url>
    <content type="text"><![CDATA[Redis基础数据类型string基本操作: set key value; get key; del key; mset; mget; strlen; append;数值增减 incr decr数据时效性 setex psetex(user:id:3506728370:fans 12210947 json) hash基本操作: hset key field value; hget key field; hgetall key; hdel key field1 [field2]; hmset; hmget; hlen(获取key数量); hexists扩展操作: hkeys; hvals; hincrby; hincrbyfloat; hsetnx(京东购物车) list底层是双向链表基本操作: lpush; rpush; lrange key start stop(朋友圈点赞、最新消息展示) set基本操作: sadd; smembers; srem; scard; sismember; srandmember; spop扩展操作: 交并补 sinter sunion sdiff; 到指定集合 sinterstore destination key1 key2 sunionstore; sdiffstore smove(热点歌单推荐、实现黑白名单) sorted_set基本操作: zadd key score1 member1 [score2 member2]; zrange key start stop [withscores]; zrevrange ;zrem ;zrangebyscore key min max [withscores] [limit]; zrevrangebyscore; zremrangebyrank; zremrangebyscore; zcard; zcount; zinterstore; zunionstore;扩展操作: zrank key member; zrevrank key member; zscore key member; zincrby key increment member; 通用命令key基本操作: del key; exists key; type key;扩展操作: expire key seconds; pexpire key milliseconds; expireat(timestamp); pexpireat; ttl key(有效时间); pttl; persist key(切换key从时效性转换到永久性);其他操作: rename key newkey; renamenx key newkey(如果对应的新newkey不存在再执行); sort; db基本操作: select index; quit; ping; echo massage;其他操作: move key db; dbsize; flushdb flushall; Redis高级持久化1.将当先数据状态进行保存2.将数据的操作过程进行保存 RDB1.save。save指令的执行会阻塞当前Redis服务器，知道当前RDB过程完成为止2.bgsave。 AOFAOF重写随着命令不断写入AOF，文件会越来越大，为了解决这个问题，Redis引入了AOF重写机制压缩文件体积。AOF文件重写是将Redis进程内的数据转化为写命令同步到新AOF文件的过程。简单说就是将对同一个数据的若干条命令执行结果转化成最终结果数据对应的指令进行记录。 事务开启: multi执行: exec取消: discard锁: watch key (watch 监控的指令一旦有人修改了，那么事务不会在执行) 取消锁: unwatch分布式锁: setnx lock-key value 有值返回失败，无值返回设置成功 expire lock-key second(解决死锁) del lock-key 删除策略定时删除惰性删除定期删除逐出策略 高级数据类型bitmaps:setbit time bit value; bitcountHyperLogLog:pfadd; pfcount; pfmergeGEO:geoadd key longitude latitude member; geopos key member; geodist key member member; georadius; georadiusbymember; geohash; 集群主从复制 主从复制常见问题:频繁的全量复制网络:数据不一致: 哨兵 集群 Redis应用企业级解决方案缓存预热问题:1.请求数量较高2.主从之间数据吞吐量较大，数据同步操作频度较高总结:缓存预热就是系统启动前，提前将相关的缓存数据直接加载到缓存系统。避免在用户请求的时候，先查询数据库，然后再将数据缓存的问题。 缓存雪崩问题:在一个较短的时间内，缓存中较多的key集中过期。我们去大量的访问了对应数据。总结:缓存雪崩就算瞬间过期数据量太大，导致对数据库服务器造成压力。如能够有效避免过期时间集中，可以有效解决雪崩现象的出现，配合其他策略一起使用，并监控服务器的运行数据，根据运行记录做快速调整。 缓存击穿问题:1.Redis中某个key过期，该key访问量巨大2.多个数据请求从服务器直接压到Redis后，均未命中3.Redis在短时间内发起了大量对数据库中同一数据的访问总结:缓存击穿就是单个高热数据过期的瞬间，数据访问量较大，未命中redis后，发起了大量对同一数据的数据库访问，导致对数据库服务器造成压力。应对策略应该在业务数据分析与预防方面进行，配合运行监控测试与即使调整策略。 缓存穿透问题:1.Redis中大面积出现未命中2.获取的数据在数据库中也不存在，数据库查询未得到对应数据总结:缓存击穿访问了不存在的数据，跳过了合法数据的Redis数据缓存阶段，每次访问数据库，导致对数据库服务器造成压力。]]></content>
      <categories>
        <category>redis</category>
      </categories>
      <tags>
        <tag>redis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[select/poll/epoll]]></title>
    <url>%2F2020%2F09%2F13%2Fselect-poll-epoll%2F</url>
    <content type="text"><![CDATA[传送门]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[计网概括]]></title>
    <url>%2F2020%2F09%2F13%2F%E8%AE%A1%E7%BD%91%E6%A6%82%E6%8B%AC%2F</url>
    <content type="text"><![CDATA[传送门]]></content>
      <categories>
        <category>计网</category>
      </categories>
      <tags>
        <tag>计网</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[平衡二叉树与红黑树]]></title>
    <url>%2F2020%2F09%2F13%2F%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%8E%E7%BA%A2%E9%BB%91%E6%A0%91%2F</url>
    <content type="text"><![CDATA[简介本文转自这里 常见用途STL（标准模板库）中在set map是基于红黑树实现的。Java中在TreeMap使用的也是红黑树。epoll在内核中的实现，用红黑树管理事件块。linux进程调度Completely Fair Scheduler,用红黑树管理进程控制块。 红黑树 VS AVL树常见的平衡树有红黑树和AVL平衡树，为什么STL和linux都使用红黑树作为平衡树的实现？大概有以下几个原因： 从实现细节上来讲，如果插入一个结点引起了树的不平衡，AVL树和红黑树都最多需要2次旋转操作，即两者都是O(1)；但是在删除node引起树的不平衡时，最坏情况下，AVL需要维护从被删node到root这条路径上所有node的平衡性，因此需要旋转的量级O(logN)，而RB-Tree最多只需3次旋转，只需要O(1)的复杂度 从两种平衡树对平衡的要求来讲，AVL的结构相较RB-Tree来说更为平衡，在插入和删除node更容易引起Tree的unbalance，因此在大量数据需要插入或者删除时，AVL需要rebalance的频率会更高。因此，RB-Tree在需要大量插入和删除node的场景下，效率更高。自然，由于AVL高度平衡，因此AVL的search效率更高。 总体来说，RB-tree的统计性能是高于AVL的。 红黑树红黑树性质1.列表项结点是红色或黑色。2.根是黑色。3.所有叶子都是黑色（叶子是NIL结点）。4.每个红色结点必须有两个黑色的子结点。（从每个叶子到根的所有路径上不能有两个连续的红色结点。）5.从任一结点到其每个叶子的所有简单路径都包含相同数目的黑色结点。为了便于处理红黑树中的边界情况，使用一个哨兵来代表所有的NIL结点，也就是说所有指向NIL的指针都指向哨兵T.nil。 旋转 解释：x的右节点换成y的左节点x的右节点的父亲换成xy名正言顺成为x的父亲的儿子y的父亲发现自己儿子换了，看看是哪边的儿子换了现在跟x相关的结点都换好了，那么y名正言顺成为x的爹 12345678910111213141516171819202122232425262728293031323334353637383940414243444546/**@brief rbt_left_rotate*@param[in] T 树根*@param[in] x 要进行旋转的节点*/void rbt_left_rotate( rbt_root_t* T, rbt_t* x)&#123; rbt_t* y = x-&gt;right; x-&gt;right = y-&gt;left; if(x-&gt;right != T-&gt;nil)//更新某结点的父亲时，要确定此结点不是T.nil x-&gt;right-&gt;p = x; y-&gt;p = x-&gt;p; if(x-&gt;p == T-&gt;nil)&#123;//如果x以前是树根，那么现在树根易主了 T-&gt;root = y; &#125;else if(y-&gt;key &lt; y-&gt;p-&gt;key) y-&gt;p-&gt;left = y; else y-&gt;p-&gt;right = y; y-&gt;left = x; x-&gt;p = y;&#125;/**@brief rbt_right_rotate*@param[in] 树根*@param[in] 要进行旋转的节点*/void rbt_right_rotate( rbt_root_t* T, rbt_t* x)&#123; rbt_t * y = x-&gt;left; x-&gt;left = y-&gt;right; if(T-&gt;nil != x-&gt;left) x-&gt;left-&gt;p = x; y-&gt;p = x-&gt;p; if(y-&gt;p == T-&gt;nil) T-&gt;root = y; else if(y-&gt;key &lt; y-&gt;p-&gt;key) y-&gt;p-&gt;left= y; else y-&gt;p-&gt;right = y; y-&gt;right = x; x-&gt;p = y;&#125; 插入1.新插入的节点一定是红色的。（如果是黑色的，会破坏条件5）2.如果新插入的节点的父亲是黑色的，则没有破坏任何性质，那么插入完成。3.如果插入节点的父节点是红色, 破坏了性质4. 故插入算法就是通过重新着色或旋转, 来维持性质 此时要记住一件事事情，插入时总是要考虑它的叔叔，删除时总要考虑它的兄弟。而且插入时维护的主要是颜色（性质4），而删除时维护的主要是黑色结点数量（性质5） 情况1： N为红，P为红（GP一定为黑），U为红。 下面会说明我们可以通过一种特殊的处理把这种情况避免掉。 那为什么要避免这种情况呢？因为这种情况一般是通过颜色翻转来处理的，也就是把P U换成黑色，把GP抱成红色，但是GP的父亲如果是红色的话又会违反红黑树的性质。 情况2： N，P都为红（GP一定为黑)，U为黑 根据境像，情况2可细分为4种情况，如下： 但是这四种具体情况的处理手法是一样的，都是通过颜色翻转与旋转来处理的。下面我们通过情况2.1和2.2来说明一下处理方法：情况2.2通过调用left_rotate(T,p)变成情况2.1;情况2.1通过交换GP与P的颜色，然后调用right_rotate(T,GP)，此时不再违反任何性质。 情况2.3和2.4分别是2.1和2.2的境像。 如何避免情况1 令X = T.root,在向下遍历的过程中，我们如果遇到X.right.color == x.left.color == RED时我们将x与它孩子的颜色翻转，即把x涂成红色，把x.right和x.left涂成黑色。 如果x的父亲为黑色，没有违反性质；如果x的父亲为红色，那么可以把x当成新插入的红色结点N，那么只需要处理情况2即可。 至此，插入完成，具体实现可以看完整代码部分，代码也有必要的注释。 删除首先找到要删除的结点，我们定义它为 z 如果要删除 z 结点，那么就让 z 的后继来代替 z 的位置即可。 如果z是红色的，那么操作便完成了，删除一个红色结点没有违反任何性质。但如果z是黑色的，那么我们删除一个黑色结点，便违反了性质5，造成黑色结点数量的左右不平衡。只要分析出删除一个黑色结点会遇到哪些情况即可。 如果 z 的两个孩子都不是T.nil，那么我们在 z 的右子树中找出最小的结点 m，把 m 结点的值赋给 z （而不是把m移植到z的位置，也就不用考虑颜色问题，那么我们要删除的结点就成为 m 了。m 肯定没有左孩子。令 z 重新指向 m 找到要删除的结点 z 之后，我们用 z 的孩子(记作 x )来取代 z的位置（即使z.right == T.nil） 。rbt_transplant(T,z,z.right); 此时用到下面一段代码，实现用v代替u123456789void rbt_transplant(rbt_root_t* T, rbt_t* u, rbt_t* v)&#123; if(u-&gt;p == T-&gt;nil) T-&gt;root = v; else if(u == u-&gt;p-&gt;left) u-&gt;p-&gt;left =v; else u-&gt;p-&gt;right = v; v-&gt;p = u-&gt;p;//即使v是T.nil也可以执行这一行&#125; 到目前为止，如果要被删除的 z 结点是红色的，那么程序就结束了。但是如果 z 是黑色的，所以删除z之后z这边少了一个黑色结点，会违反性质5，此时分为4种情况（x 是左孩子 和 x 是右孩子分别有4种情况，现在只讨论x是左孩子的情况）： 情况1： x的兄弟w是红色的，那么它们的父亲、w的孩子都是黑色的。 这种情况下只能做一种无损的操作，通过交换颜色再旋转，对树的性质不会产生影响，所以从根到x结点的路径上少的一个黑色结点也不会补上。 交换p与w的颜色，再对p进行左旋操之后，x的新兄弟就为黑色，情况变成了2 3 4中的一种. 图中x为白色，表示我们不关心x的颜色。 情况2： x的兄弟w是黑色，而且w的两个孩子都是黑色。 此时可以细分为2种情况，但无论哪种情况，我们要进行的操作都是一样的，都是将w涂成红色，将p涂成黑色。 如果是情况2.1(有可能由情况1发展过来的)，由于上述操作为x那边补上了一个黑色（从根到x在路径上多了一个黑色结点），此时红黑树性质5得到满足，程序结束。 如果是情况2.2, 经过上述操作后，P的右子树也少了一个黑色结点，令P作为新的X继续循环。 情况3: W是黑色有，w在左孩子是红色的，W的右孩子是黑色的。 通过交换L与W的颜色，再对W进行右旋操作。这种操作也不会对红黑树性质产生影响，此时进入情况4，我们会看到通过情况4中的操作最终使红黑树性质得到满足，结束程序。 图中最后边的R结点没有画出来，因为我们不关心它了 情况4: w是黑色的，w的右孩子是红色的。 把w涂成p的颜色，把P涂成黑色，R涂成黑色，左旋P。此时从根到x在路径上多了一个黑色结点，程序结束。 完整代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434#include&lt;stdafx.h&gt;#include&lt;malloc.h&gt;#include &lt;assert.h&gt;//版权声明：原创不易，转载请注明转自[weewqrer 红黑树](http://blog.csdn.net/weewqrer/article/details/51866488)//红黑树typedef enum ColorType &#123;RED, BLACK&#125; ColorType;typedef struct rbt_t&#123; int key; rbt_t * left; rbt_t * right; rbt_t * p; ColorType color;&#125;rbt_t;typedef struct rbt_root_t&#123; rbt_t* root; rbt_t* nil;&#125;rbt_root_t;//函数声明rbt_root_t* rbt_init(void);static void rbt_handleReorient(rbt_root_t* T, rbt_t* x, int k);rbt_root_t* rbt_insert(rbt_root_t* &amp;T, int k);rbt_root_t* rbt_delete(rbt_root_t* &amp;T, int k);void rbt_transplant(rbt_root_t* T, rbt_t* u, rbt_t* v);static void rbt_left_rotate( rbt_root_t* T, rbt_t* x);static void rbt_right_rotate( rbt_root_t* T, rbt_t* x);void rbt_inPrint(const rbt_root_t* T, rbt_t* t);void rbt_prePrint(const rbt_t * T, rbt_t* t);void rbt_print(const rbt_root_t* T);static rbt_t* rbt_findMin(rbt_root_t * T, rbt_t* t);static rbt_t* rbt_findMax(rbt_root_t * T, rbt_t* t);static rbt_t* rbt_findMin(rbt_root_t * T, rbt_t* t)&#123; if(t == T-&gt;nil) return T-&gt;nil; while(t-&gt;left != T-&gt;nil) t = t-&gt;left; return t;&#125;static rbt_t* rbt_findMax(rbt_root_t * T, rbt_t* t)&#123; if(t == T-&gt;nil) return T-&gt;nil; while(t-&gt;right != T-&gt;nil) t = t-&gt;right; return t;&#125;/**@brief rbt_init 初始化*/rbt_root_t* rbt_init(void)&#123; rbt_root_t* T; T = (rbt_root_t*)malloc(sizeof(rbt_root_t)); assert( NULL != T); T-&gt;nil = (rbt_t*)malloc(sizeof(rbt_t)); assert(NULL != T-&gt;nil); T-&gt;nil-&gt;color = BLACK; T-&gt;nil-&gt;left = T-&gt;nil-&gt;right = NULL; T-&gt;nil-&gt;p = NULL; T-&gt;root = T-&gt;nil; return T;&#125;/**@brief rbt_handleReorient 内部函数 由rbt_insert调用* 在两种情况下调用这个函数：* 1 x有连个红色儿子* 2 x为新插入的结点**/ void rbt_handleReorient(rbt_root_t* T, rbt_t* x, int k)&#123; //在第一种情况下，进行颜色翻转； 在第二种情况下，相当于对新插入的x点初始化 x-&gt;color = RED; x-&gt;left-&gt;color = x-&gt;right-&gt;color = BLACK; //如果x.p为红色，那么x.p一定不是根，x.p.p一定不是T.nil，而且为黑色 if( RED == x-&gt;p-&gt;color)&#123; x-&gt;p-&gt;p-&gt;color = RED;//此时x, p, x.p.p都为红 if(x-&gt;p-&gt;key &lt; x-&gt;p-&gt;p-&gt;key)&#123; if(k &gt; x-&gt;p-&gt;key)&#123; x-&gt;color = BLACK;//小心地处理颜色 rbt_left_rotate(T,x-&gt;p); rbt_right_rotate(T,x-&gt;p); &#125;else&#123; x-&gt;p-&gt;color = BLACK;//小心地处理颜色 rbt_right_rotate(T,x-&gt;p-&gt;p); &#125; &#125;else&#123; if(k &lt; x-&gt;p-&gt;key)&#123; x-&gt;color = BLACK; rbt_right_rotate(T,x-&gt;p); rbt_left_rotate(T,x-&gt;p); &#125;else&#123; x-&gt;p-&gt;color = BLACK; rbt_left_rotate(T,x-&gt;p-&gt;p); &#125; &#125; &#125; T-&gt;root-&gt;color = BLACK;//无条件令根为黑色&#125;/**@brief brt_insert 插入*1 新插入的结点一定是红色的，如果是黑色的，会破坏条件4（每个结点到null叶结点的每条路径有同样数目的黑色结点）*2 如果新插入的结点的父亲是黑色的，那么插入完成。 如果父亲是红色的，那么做一个旋转即可。（前提是叔叔是黑色的）*3 我们这个插入要保证其叔叔是黑色的。也就是在x下沉过程中，不允许存在两个红色结点肩并肩。*/rbt_root_t* rbt_insert(rbt_root_t* &amp;T, int k)&#123; rbt_t * x, *p; x = T-&gt;root; p = x; //令x下沉到叶子上，而且保证一路上不会有同时为红色的兄弟 while( x != T-&gt;nil)&#123; // //保证没有一对兄弟同时为红色， 为什么要这么做？ if(x != T-&gt;nil) if(x-&gt;left-&gt;color == RED &amp;&amp; x-&gt;right-&gt;color == RED) rbt_handleReorient(T,x,k); p = x; if(k&lt;x-&gt;key) x = x-&gt;left; else if(k&gt;x-&gt;key) x = x-&gt;right; else&#123; printf(&quot;\n%d已存在\n&quot;,k); return T; &#125; &#125; //为x分配空间，并对其进行初始化 x = (rbt_t *)malloc(sizeof(rbt_t)); assert(NULL != x); x-&gt;key = k; x-&gt;color = RED; x-&gt;left = x-&gt;right = T-&gt;nil; x-&gt;p = p; //让x的父亲指向x if(T-&gt;root == T-&gt;nil) T-&gt;root = x; else if(k &lt; p-&gt;key) p-&gt;left = x; else p-&gt;right = x; //因为一路下来，如果x的父亲是红色，那么x的叔叔肯定不是红色了，这个时候只需要做一下翻转即可。 rbt_handleReorient(T,x,k); return T;&#125;void rbt_transplant(rbt_root_t* T, rbt_t* u, rbt_t* v)&#123; if(u-&gt;p == T-&gt;nil) T-&gt;root = v; else if(u == u-&gt;p-&gt;left) u-&gt;p-&gt;left =v; else u-&gt;p-&gt;right = v; v-&gt;p = u-&gt;p;&#125;/**@brief rbt_delete 从树中删除 k***/rbt_root_t* rbt_delete(rbt_root_t* &amp;T, int k)&#123; assert(T != NULL); if(NULL == T-&gt;root) return T; //找到要被删除的叶子结点 rbt_t * toDelete = T-&gt;root; rbt_t * x; //找到值为k的结点 while(toDelete != T-&gt;nil &amp;&amp; toDelete-&gt;key != k)&#123; if(k&lt;toDelete-&gt;key) toDelete = toDelete-&gt;left; else if(k&gt;toDelete-&gt;key) toDelete = toDelete-&gt;right; &#125; if(toDelete == T-&gt;nil)&#123; printf(&quot;\n%d 不存在\n&quot;,k); return T; &#125; //如果两个孩子，就找到右子树中最小的代替, alternative最多有一个右孩子 if(toDelete-&gt;left != T-&gt;nil &amp;&amp; toDelete-&gt;right != T-&gt;nil)&#123; rbt_t* alternative = rbt_findMin(T, toDelete-&gt;right); k = toDelete-&gt;key = alternative-&gt;key; toDelete = alternative; &#125; if(toDelete-&gt;left == T-&gt;nil)&#123; x = toDelete-&gt;right; rbt_transplant(T,toDelete,toDelete-&gt;right); &#125;else if(toDelete-&gt;right == T-&gt;nil)&#123; x = toDelete-&gt;left; rbt_transplant(T,toDelete,toDelete-&gt;left); &#125; if(toDelete-&gt;color == BLACK)&#123; //x不是todelete，而是用于代替x的那个 //如果x颜色为红色的，把x涂成黑色即可， 否则 从根到x处少了一个黑色结点，导致不平衡 while(x != T-&gt;root &amp;&amp; x-&gt;color == BLACK)&#123; if(x == x-&gt;p-&gt;left)&#123; rbt_t* w = x-&gt;p-&gt;right; //情况1 x的兄弟是红色的，通过 if(RED == w-&gt;color)&#123; w-&gt;color = BLACK; w-&gt;p-&gt;color = RED; rbt_left_rotate(T,x-&gt;p); w = x-&gt;p-&gt;right; &#125;//处理完情况1之后，w.color== BLACK ， 情况就变成2 3 4 了 //情况2 x的兄弟是黑色的，并且其儿子都是黑色的。 if(w-&gt;left-&gt;color == BLACK &amp;&amp; w-&gt;right-&gt;color == BLACK)&#123; if(x-&gt;p-&gt;color == RED)&#123; x-&gt;p-&gt;color = BLACK; w-&gt;color = RED; break; &#125;else&#123; w-&gt;color = RED; x = x-&gt;p;//x.p左右是平衡的，但是x.p处少了一个黑结点，所以把x.p作为新的x继续循环 continue; &#125; &#125; //情况3 w为黑色的，左孩子为红色。（走到这一步，说明w左右不同时为黑色。） if(w-&gt;right-&gt;color == BLACK)&#123; w-&gt;left-&gt;color = BLACK; w-&gt;color = RED; rbt_right_rotate(T,w); w = x-&gt;p-&gt;right; &#125;//处理完之后，变成情况4 //情况4 走到这一步说明w为黑色， w的左孩子为黑色， 右孩子为红色。 w-&gt;color=x-&gt;p-&gt;color; x-&gt;p-&gt;color=BLACK; w-&gt;right-&gt;color=BLACK; rbt_left_rotate(T,x-&gt;p); x = T-&gt;root; &#125;else&#123; rbt_t* w = x-&gt;p-&gt;left; //1 if(w-&gt;color == RED)&#123; w-&gt;color = BLACK; x-&gt;p-&gt;color = RED; rbt_right_rotate(T,x-&gt;p); w = x-&gt;p-&gt;left; &#125; //2 if(w-&gt;left-&gt;color==BLACK &amp;&amp; w-&gt;right-&gt;color == BLACK)&#123; if(x-&gt;p-&gt;color == RED)&#123; x-&gt;p-&gt;color = BLACK; w-&gt;color = RED; break; &#125;else&#123; x-&gt;p-&gt;color = BLACK; w-&gt;color = RED; x = x-&gt;p; continue; &#125; &#125; //3 if(w-&gt;left-&gt;color == BLACK)&#123; w-&gt;color = RED; w-&gt;right-&gt;color = BLACK; w = x-&gt;p-&gt;left; &#125; //4 w-&gt;color=w-&gt;p-&gt;color; x-&gt;p-&gt;color = BLACK; w-&gt;left-&gt;color = BLACK; rbt_right_rotate(T,x-&gt;p); x = T-&gt;root; &#125; &#125; x-&gt;color = BLACK; &#125; //放心删除todelete 吧 free(toDelete); return T;&#125;/**@brief rbt_left_rotate*@param[in] T 树根*@param[in] x 要进行旋转的结点*/void rbt_left_rotate( rbt_root_t* T, rbt_t* x)&#123; rbt_t* y = x-&gt;right; x-&gt;right = y-&gt;left; if(x-&gt;right != T-&gt;nil) x-&gt;right-&gt;p = x; y-&gt;p = x-&gt;p; if(y-&gt;p == T-&gt;nil)&#123; T-&gt;root = y; &#125;else if(y-&gt;key &lt; y-&gt;p-&gt;key) y-&gt;p-&gt;left = y; else y-&gt;p-&gt;right = y; y-&gt;left = x; x-&gt;p = y;&#125;/**@brief rbt_right_rotate*@param[in] 树根*@param[in] 要进行旋转的结点*/void rbt_right_rotate( rbt_root_t* T, rbt_t* x)&#123; rbt_t * y = x-&gt;left; x-&gt;left = y-&gt;right; if(T-&gt;nil != x-&gt;left) x-&gt;left-&gt;p = x; y-&gt;p = x-&gt;p; if(y-&gt;p == T-&gt;nil) T-&gt;root = y; else if(y-&gt;key &lt; y-&gt;p-&gt;key) y-&gt;p-&gt;left= y; else y-&gt;p-&gt;right = y; y-&gt;right = x; x-&gt;p = y;&#125;void rbt_prePrint(const rbt_root_t* T, rbt_t* t)&#123; if(T-&gt;nil == t)return ; if(t-&gt;color == RED) printf(&quot;%3dR&quot;,t-&gt;key); else printf(&quot;%3dB&quot;,t-&gt;key); rbt_prePrint(T,t-&gt;left); rbt_prePrint(T,t-&gt;right);&#125;void rbt_inPrint(const rbt_root_t* T, rbt_t* t)&#123; if(T-&gt;nil == t)return ; rbt_inPrint(T,t-&gt;left); if(t-&gt;color == RED) printf(&quot;%3dR&quot;,t-&gt;key); else printf(&quot;%3dB&quot;,t-&gt;key); rbt_inPrint(T,t-&gt;right);&#125;//打印程序包括前序遍历和中序遍历两个，因为它俩可以唯一确定一棵二叉树void rbt_print(const rbt_root_t* T)&#123; assert(T!=NULL); printf(&quot;\n前序遍历 ：&quot;); rbt_prePrint(T,T-&gt;root); printf(&quot;\n中序遍历 ：&quot;); rbt_inPrint(T,T-&gt;root); printf(&quot;\n&quot;);&#125;void rbt_test()&#123; rbt_root_t* T = rbt_init(); /************************************************************************/ /* 1 测试插入 /* /* /*输出 前序遍历 ： 7B 2R 1B 5B 4R 11R 8B 14B 15R /* 中序遍历 ： 1B 2R 4R 5B 7B 8B 11R 14B 15R /************************************************************************/ T = rbt_insert(T,11); T = rbt_insert(T,7); T = rbt_insert(T,1); T = rbt_insert(T,2); T = rbt_insert(T,8); T = rbt_insert(T,14); T = rbt_insert(T,15); T = rbt_insert(T,5); T = rbt_insert(T,4); T = rbt_insert(T,4); //重复插入测试 rbt_print(T); /************************************************************************/ /* 2 测试删除 /* /*操作 连续删除4个元素 rbt_delete(T,8);rbt_delete(T,14);rbt_delete(T,7);rbt_delete(T,11); /*输出 前序遍历 ： 2B 1B 5R 4B 15B /* 中序遍历 ： 1B 2B 4B 5R 15B /************************************************************************/ rbt_delete(T,8); rbt_delete(T,14);rbt_delete(T,7);rbt_delete(T,11); rbt_delete(T,8);//删除不存在的元素 rbt_print(T);&#125;]]></content>
      <categories>
        <category>基础</category>
      </categories>
      <tags>
        <tag>红黑树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[布隆过滤器]]></title>
    <url>%2F2020%2F09%2F13%2F%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8%2F</url>
    <content type="text"><![CDATA[布隆过滤器一个空的布隆过滤器是一串被置为0的bit数组（假设由m位）。同时，应该声明k个不同的散列函数生成一个统一随机分布，每一个散列函数都将元素映射到m个bit中的一个（k是一个小于m的常数，与加入过滤器中的元素个数成比例）。k与相应的m的选择由误判率决定。 向过滤器中添加元素时，通过k个散列函数得到该元素对应的k个位置，并将这些位置置为1. 查询某个元素/测试是否与已有元素重复时，依旧通过k个散列函数得到对应的k个位置，判断这些位置是否为1（若全为1则在集合内/重复） 可以看如下图所示的一个例子，其中，{x,y,z}为集合，w为进行比对的元素，m=18，k=3，不同颜色的箭头表示散列映射关系。可以看出，w并不在{x,y,z}这个集合中。 Bitmap是用一个数组中的每个数据的每个二进制位表示一个数是否存在。1表示存在，0表示不存在。 相当于把数组分成很多块的空间，每一块是32个比特位。 原来32个比特位放一个数据，相当于现在一个位就可以放一个数据。]]></content>
      <categories>
        <category>基础</category>
      </categories>
      <tags>
        <tag>布隆过滤器</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[B树与B+树]]></title>
    <url>%2F2020%2F09%2F13%2FB%E6%A0%91%E4%B8%8EB-%E6%A0%91%2F</url>
    <content type="text"><![CDATA[B树性质一颗M阶B树T，满足以下条件 每个结点至多拥有M课子树 根结点至少拥有两颗子树 除了根结点以外，其余每个分支结点至少拥有M/2课子树 所有的叶结点都在同一层上 有k课子树的分支结点则存在k-1个关键字，关键字按照递增顺序进行排序 关键字数量满足ceil(M/2)-1 &lt;= n &lt;= M-1 插入通过对B树进行遍历，找出要插入的结点以及结点位置，如果找到的key值在B树当中已经存在，则说明插入失败，否则，就可以进行插入操作。这里可以先不管是否超出M阶树的上限要求，因为我们在定义的时候会故意留下一个位置，可以存放多余的一个元素，插入之后，通过判断是否达到M阶树上限要求，再进行递归的分裂操作。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849/**** @name Status insertBTree(BTree &amp;T, Record e)* @description 插入实现元素的插入* @return 成功返回OK,如果存在则返回FALSE，否则返回ERROR* @notice***/Status insertBTree(BTree &amp;T, Record e)&#123; BTree p; int index, temp; Status find_flag; if (NULL == T)//考虑B树为空树的情况 &#123; T = (BTree)malloc(BTLEN); if (NULL == T) return OVERFLOW; T-&gt;keynum = 1; T-&gt;parent = NULL; for (index = 0;index &lt;= m; ++index) &#123; T-&gt;ptr[index] = NULL; T-&gt;key[index] = 0; &#125; T-&gt;key[1] = e.key; return OK; &#125; find_flag = findBTree(T, p, temp, e.key);//寻找插入节点 if (find_flag == TRUE) &#123; return FALSE; &#125; if (find_flag == FALSE) &#123; //不管怎样先直接插入 p-&gt;keynum++; for (index = p-&gt;keynum;index &gt; temp;--index) &#123; p-&gt;key[index] = p-&gt;key[index - 1]; p-&gt;ptr[index] = p-&gt;ptr[index - 1]; &#125; p-&gt;ptr[temp] = NULL; p-&gt;key[temp] = e.key; if (p-&gt;keynum == m) //这种情况得分裂 &#123; splitBTree(p); &#125; renewParent(T); return OK; &#125; return ERROR;&#125; 分裂分裂操作是插入操作过程中一个最重要的操作，因为这是处理“冲突”（即结点中的数据元素大于B树规则中要求的最大个数）的一个通用的处理方式，这种方式必须要对所有的情况都适用，而分裂是解决这一问题一个方法。当然这种方法只是考虑到效率，没有对兄弟可否借数据进行判断，但是另外一种方式比较麻烦，这里先不做讨论。 分裂的思路是让父亲结点先腾出一个位置（包括key和ptr）出来，然后在需要分裂的结点里面取中间的元素并且移动中间的元素key到父亲结点已经腾出来的key位置那里，然后把分裂出来的右部分接到腾出来的ptr那里。注意整个过程对左部分和右部分的都要改变元素的个数以及清空一些没用的空间。在往上分裂之后可能会造成一种情况，就是父亲结点也可能达到分裂的最大个数，所以，检查父亲结点是否需要分裂，需要的话，递归之。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950/**** @name status splitBTree(BTree T)* @description 递归实现分裂节点操作* @return 成功返回OK,否则返回ERROR* @notice***/Status splitBTree(BTree T) //此时分裂的节点一定会是超出最大值的。&#123; BTree t1, t2; int index, index_1; if (T-&gt;parent == NULL) &#123; t1 = (BTree)malloc(BTLEN); if (NULL == t1) return OVERFLOW; t2 = (BTree)malloc(BTLEN); if (NULL == t2) return OVERFLOW; t1-&gt;keynum = m / 2; t2-&gt;keynum = m - (m / 2) - 1; t1-&gt;parent = T; t2-&gt;parent = T; for (index = 0;index &lt;= m; ++index) //先全部初始化 &#123; t1-&gt;ptr[index] = NULL; t1-&gt;key[index] = 0; t2-&gt;ptr[index] = NULL; t2-&gt;key[index] = 0; &#125; for (index = 0;index &lt;= m / 2; ++index) //初始化t1 &#123; t1-&gt;ptr[index] = T-&gt;ptr[index]; t1-&gt;key[index] = T-&gt;key[index]; &#125; t2-&gt;ptr[0] = T-&gt;ptr[(m / 2) + 1]; for (index = (m / 2) + 2;index &lt;= m; ++index) //初始化t2 &#123; t2-&gt;ptr[index - ((m / 2) + 1)] = T-&gt;ptr[index]; t2-&gt;key[index - ((m / 2) + 1)] = T-&gt;key[index]; &#125; T-&gt;keynum = 1; T-&gt;ptr[0] = t1; T-&gt;ptr[1] = t2; T-&gt;key[1] = T-&gt;key[m / 2 + 1]; for (index = 2;index &lt;= m; ++index) //初始化T &#123; T-&gt;ptr[index] = NULL; T-&gt;key[index] = 0; &#125; return OK; &#125; 删除B树元素的删除操作与插入操作类似，但是却要麻烦，因为得分两种情况处理。（1）寻找到存在这个元素，而且这个元素所在是叶子节点（即它的孩子为空），直接对其进行删除，之后再判断是否小于B树规则中要求的最小的子树个数。如果小于，那就调用合并函数。（2）如果寻找到的这个元素是非叶子节点的元素，通过寻找比该元素小的最大元素（该元素肯定为叶子节点），把该元素直接赋值给要删除的元素，再在叶子节点处进行（1）中的操作。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556/**** @name Status deleteBTreeRecord(BTree &amp;T, Record e)* @description 实现B树元素的删除* @return 成功返回OK,否则返回ERROR* @notice***/Status deleteBTreeRecord(BTree &amp;T, Record e)&#123; BTree p, q; int num, temp, index; Status find_flag; if (T == NULL) return ERROR; find_flag = findBTree(T, p, temp, e.key); if (find_flag == FALSE) &#123; return FALSE; &#125; if (find_flag == TRUE) &#123; //deleteBTreeBNode(p,temp); if (p-&gt;ptr[temp] == NULL) //如果是叶子节点的话 &#123; for (index = temp;index &lt;= p-&gt;keynum;++index) &#123; p-&gt;key[index] = p-&gt;key[index + 1]; p-&gt;ptr[index] = p-&gt;ptr[index + 1]; &#125; p-&gt;keynum--; if (p-&gt;keynum == (m + 1) / 2 - 2) &#123; //调用借兄弟的函数 if (borrowBNode(p) == EMPTY) T = NULL; else renewParent(T); &#125; return OK; &#125; else //不是叶子结点的话 &#123; //遍历 findMax(p-&gt;ptr[temp - 1], q, num);//返回的q一定会是叶子节点 p-&gt;key[temp] = q-&gt;key[num]; q-&gt;key[num] = 0; q-&gt;keynum--; if (q-&gt;keynum == (m + 1) / 2 - 2) &#123; //调用借兄弟的函数 if (borrowBNode(q) == EMPTY) T = NULL; else renewParent(T); &#125; return OK; &#125; return OK; &#125; return ERROR;&#125; 合并首先先向兄弟结点借元素，如果兄弟能够借给你元素的话（即借了你之后并不会小于最少的分支），那么直接从兄弟那里取元素，否则，和兄弟合并。合并其实是分裂反过来的情况，从父亲结点那里取出一个key值介于要合并的两个结点之间的元素，插入左部分最末尾处，同时右部分插到左部分后面，然后父亲结点元素依次往前挪。从而实现合并操作。之后，也必须对父亲结点进行判断是否小于最小的分支数，如果也小于，对父亲节点进行递归操作。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123/**** @name Status borrowBNode(BTree &amp;T)* @description 递归实现，向兄弟借元素，否则和兄弟合并* @return 成功返回OK,否则返回ERROR* @notice 这种情况应该是T为单元素结点***/Status borrowBNode(BTree T)&#123; int mynum, bronum, index; BTree b = NULL, f = NULL; if (T == NULL) return ERROR; f = T-&gt;parent; if (f == NULL)//考虑父亲结点不存在的情况 &#123; if (T-&gt;keynum == 0) &#123; f = T-&gt;ptr[0]; if (f == NULL) &#123; free(T); return EMPTY; &#125; for (index = 0;index &lt;= f-&gt;keynum;index++) &#123; T-&gt;key[index] = f-&gt;key[index]; T-&gt;ptr[index] = f-&gt;ptr[index]; &#125; T-&gt;keynum = f-&gt;keynum; free(f); renewParent(T); &#125; return OK; &#125; mynum = whichSon(T); if (mynum == 0) bronum = 1; else bronum = mynum - 1; b = f-&gt;ptr[bronum]; if (b-&gt;keynum == (m + 1) / 2 - 1) //如果兄弟帮不了你了 &#123; //那么就和这个兄弟合体 if (bronum &lt; mynum) //如果我不是第一个 &#123; b-&gt;keynum++; b-&gt;key[b-&gt;keynum] = f-&gt;key[mynum]; b-&gt;ptr[b-&gt;keynum] = T-&gt;ptr[0]; for (index = 1;index &lt;= T-&gt;keynum;index++) &#123; b-&gt;key[index + b-&gt;keynum] = T-&gt;key[index]; b-&gt;ptr[index + b-&gt;keynum] = T-&gt;ptr[index]; b-&gt;keynum++; &#125; free(T); for (index = mynum;index &lt;= f-&gt;keynum;index++) &#123; f-&gt;key[index] = f-&gt;key[index + 1]; f-&gt;ptr[index] = f-&gt;ptr[index + 1]; &#125; f-&gt;keynum--; &#125; else &#123; T-&gt;keynum++; T-&gt;key[T-&gt;keynum] = f-&gt;key[bronum]; T-&gt;ptr[T-&gt;keynum] = b-&gt;ptr[0]; for (index = 1;index &lt;= b-&gt;keynum;index++) &#123; T-&gt;key[index + T-&gt;keynum] = b-&gt;key[index]; T-&gt;ptr[index + T-&gt;keynum] = b-&gt;ptr[index]; T-&gt;keynum++; &#125; free(b); for (index = bronum;index &lt;= f-&gt;keynum;index++) &#123; f-&gt;key[index] = f-&gt;key[index + 1]; f-&gt;ptr[index] = f-&gt;ptr[index + 1]; &#125; f-&gt;keynum--; &#125; renewParent(f); if (f-&gt;keynum == (m + 1) / 2 - 2) &#123; //调用借兄弟的函数 return borrowBNode(f); &#125; &#125; else//如果兄弟能够帮你 &#123; if (bronum &lt; mynum) //如果我不是第一个 &#123; for (index = 1;index &lt;= T-&gt;keynum;index++) &#123; T-&gt;key[index + 1] = T-&gt;key[index]; T-&gt;ptr[index + 1] = T-&gt;ptr[index]; &#125; T-&gt;ptr[1] = T-&gt;ptr[0]; T-&gt;key[1] = f-&gt;key[mynum]; T-&gt;ptr[0] = b-&gt;ptr[b-&gt;keynum]; T-&gt;keynum++; f-&gt;key[mynum] = b-&gt;key[b-&gt;keynum]; b-&gt;key[b-&gt;keynum] = 0; b-&gt;ptr[b-&gt;keynum] = NULL; b-&gt;keynum--; &#125; else //如果我是第一个 &#123; T-&gt;keynum++; T-&gt;key[T-&gt;keynum] = f-&gt;key[1]; T-&gt;ptr[T-&gt;keynum] = b-&gt;ptr[0]; f-&gt;key[1] = b-&gt;key[1]; b-&gt;ptr[0] = b-&gt;ptr[1]; for (index = 1;index &lt;= b-&gt;keynum;index++) &#123; b-&gt;key[index] = b-&gt;key[index + 1]; b-&gt;ptr[index] = b-&gt;ptr[index + 1]; &#125; b-&gt;keynum--; &#125; &#125; return OK;&#125; 完整代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798991001011021031041051061071081091101111121131141151161171181191201211221231241251261271281291301311321331341351361371381391401411421431441451461471481491501511521531541551561571581591601611621631641651661671681691701711721731741751761771781791801811821831841851861871881891901911921931941951961971981992002012022032042052062072082092102112122132142152162172182192202212222232242252262272282292302312322332342352362372382392402412422432442452462472482492502512522532542552562572582592602612622632642652662672682692702712722732742752762772782792802812822832842852862872882892902912922932942952962972982993003013023033043053063073083093103113123133143153163173183193203213223233243253263273283293303313323333343353363373383393403413423433443453463473483493503513523533543553563573583593603613623633643653663673683693703713723733743753763773783793803813823833843853863873883893903913923933943953963973983994004014024034044054064074084094104114124134144154164174184194204214224234244254264274284294304314324334344354364374384394404414424434444454464474484494504514524534544554564574584594604614624634644654664674684694704714724734744754764774784794804814824834844854864874884894904914924934944954964974984995005015025035045055065075085095105115125135145155165175185195205215225235245255265275285295305315325335345355365375385395405415425435445455465475485495505515525535545555565575585595605615625635645655665675685695705715725735745755765775785795805815825835845855865875885895905915925935945955965975985996006016026036046056066076086096106116126136146156166176186196206216226236246256266276286296306316326336346356366376386396406416426436446456466476486496506516526536546556566576586596606616626636646656666676686696706716726736746756766776786796806816826836846856866876886896906916926936946956961 #define _CRT_SECURE_NO_WARNINGS2 #include&lt;stdio.h&gt; 3 #include&lt;stdlib.h&gt;4 #include&lt;time.h&gt; 5 #define BTREELENGTH 506 #define BTLEN (sizeof(BTNode))7 #define MAXINT 100 8 typedef enum status9 &#123; 10 TRUE, 11 FALSE, 12 OK, 13 ERROR, 14 OVERFLOW, 15 EMPTY 16 &#125;Status; 17 typedef int KeyType; 18 19 //**********************************B树**************************************** 20 #define m 3 // B树的阶，此设为4 21 typedef struct 22 &#123; 23 KeyType key; 24 char data; 25 &#125; Record; 26 typedef struct BTNode 27 &#123; 28 int keynum; // 结点中关键字个数，即结点的大小 29 struct BTNode *parent; // 指向双亲结点 30 KeyType key[m + 1]; // 关键字向量，0号单元未用 31 struct BTNode *ptr[m + 1]; // 子树指针向量 32 // Record *recptr[m + 1]; // 记录指针向量，0号单元未用 33 //在此添加其他自定义数据 34 &#125; BTNode, *BTree; // B树结点和B树的类型 35 typedef struct 36 &#123; 37 BTNode *pt; // 指向找到的结点 38 int i; // 1..m，在结点中的关键字序号 39 int tag; // 1:查找成功，0:查找失败 40 &#125; Result; // 在B树的查找结果类型 41 //**********************************B树**************************************** 42 43 //**********************************队列*************************************** 44 typedef struct LNode &#123; 45 BTree data; // 数据域 46 struct LNode *next; // 指针域 47 &#125; LNode, *LinkList; 48 //**********************************队列*************************************** 49 50 /*** 51 * @name Status InitQueue_L(LinkList &amp;L) 52 * @description 初始化队列 53 * @return 成功返回OK，开辟空间失败返回OVERFLOW 54 * @notice 55 ***/ 56 Status InitQueue_L(LinkList &amp;L) 57 &#123; // 初始化一个只含头结点的空单链表L 58 if (NULL == (L = (LNode*)malloc(sizeof(LNode)))) // 生成新结点 59 return OVERFLOW; 60 L-&gt;next = NULL; 61 return OK; 62 &#125; 63 /*** 64 * @name LNode* MakeNode_L(BTree e) 65 * @description 构造队列结点 66 * @return 返回结点地址 67 * @notice 68 ***/ 69 LNode* MakeNode_L(BTree e) 70 &#123; // 构造数据域为e的单链表结点 71 LNode *p; 72 p = (LNode*)malloc(sizeof(LNode)); // 分配结点空间 73 if (p != NULL) 74 &#123; 75 p-&gt;data = e; 76 p-&gt;next = NULL; 77 &#125; 78 return p; 79 &#125; 80 /*** 81 * @name Status Enqueue_L(LNode *p, BTree e) 82 * @description 队列的入队 83 * @return 成功返回OK，否则返回ERROR 84 * @notice 85 ***/ 86 Status Enqueue_L(LNode *p, BTree e) 87 &#123; //在p结点之后插入q结点 88 if (NULL == p) return ERROR; // 参数不合理 89 while (p-&gt;next != NULL) 90 p = p-&gt;next; 91 p-&gt;next = MakeNode_L(e); // 对应图4.11（b）的②，修改p结点的指针域 92 return OK; 93 &#125; 94 95 /*** 96 * @name Status Dequeue_L(LNode *p, BTree &amp;e) 97 * @description 队列的出队 98 * @return 成功返回OK，否则返回ERROR 99 * @notice100 ***/101 Status Dequeue_L(LNode *p, BTree &amp;e)102 &#123;103 // 删除p结点的直接后继结点并用参数e返回被删结点的值104 LNode *q;105 if (NULL == p || NULL == p-&gt;next) return ERROR; // 删除位置不合理 106 q = p-&gt;next;107 p-&gt;next = q-&gt;next; // 修改被删结点q的指针域108 e = q-&gt;data;109 free(q); // 释放结点q110 return OK;111 &#125;112 113 /***114 * @name void DestroyQueue(LinkList L)115 * @description 队列的销毁116 * @return 无返回117 * @notice118 ***/119 void DestroyQueue(LinkList L)120 &#123;121 // 销毁整个链表122 LinkList p;123 if (L != NULL)124 &#123;125 p = L;126 L = L-&gt;next;127 free(p);128 DestroyQueue(L);129 &#125;130 &#125;131 /***132 * @name Status IfEmpty(LinkList L)133 * @description 判断队列是否为空134 * @return 空返回TRUE，不空返回FALSE，否则返回ERROR135 * @notice 136 ***/137 Status IfEmpty(LinkList L)138 &#123;139 if (L == NULL) return ERROR;140 if (L-&gt;next == NULL) return TRUE;141 return FALSE;142 &#125;143 /***144 * @name Status ergodic(BTree T, LinkList L, int newline, int sum)145 * @description print需要用到的递归遍历程序146 * @return 成功返回OK147 * @notice 此处用到队列148 ***/149 Status ergodic(BTree T, LinkList L, int newline, int sum)150 &#123;151 int index;152 BTree p;153 if (T != NULL)154 &#123;155 printf(&quot;[ &quot;);156 Enqueue_L(L, T-&gt;ptr[0]);157 for (index = 1;index &lt;= T-&gt;keynum; index++)158 &#123;159 printf(&quot;%d &quot;, T-&gt;key[index]);160 Enqueue_L(L, T-&gt;ptr[index]);161 &#125;162 sum += T-&gt;keynum + 1;163 printf(&quot;]&quot;);164 if (newline == 0)165 &#123;166 printf(&quot;\n&quot;);167 newline = sum - 1;168 sum = 0;169 &#125;170 else171 &#123;172 --newline;173 &#125;174 &#125;175 if (IfEmpty(L) == FALSE)176 &#123;177 Dequeue_L(L, p);178 ergodic(p, L, newline, sum);179 &#125;180 return OK;181 &#125;182 /***183 * @name Status print(BTree T)184 * @description 层次遍历并分层输出B树185 * @return 成功返回OK186 * @notice187 ***/188 Status print(BTree T)189 &#123;190 LinkList L;191 if (T == NULL)192 &#123;193 printf(&quot;[ ]\n&quot;);194 return OK;195 &#125;196 InitQueue_L(L);197 ergodic(T, L, 0, 0);198 DestroyQueue(L);199 return OK;200 &#125;201 202 /***203 * @name Status findMax(BTree T, BTree &amp;p,int ans)204 * @description 寻找最大关键字的结点,T为要寻找的树，p为返回的节点,ans为第几个205 * @return 成功返回OK,否则返回ERROR206 * @notice207 ***/208 Status findMax(BTree T, BTree &amp;p, int &amp;ans)209 &#123;210 if (T == NULL)211 return ERROR;212 p = T;213 while (p-&gt;ptr[p-&gt;keynum] != NULL)214 &#123;215 p = p-&gt;ptr[p-&gt;keynum];216 &#125;217 ans = p-&gt;keynum;218 return OK;219 &#125;220 /***221 * @name Status findMin(BTree T, BTree &amp;p,int ans)222 * @description 寻找最小关键字的结点,T为要寻找的树，p为返回的节点,ans为第几个223 * @return 成功返回OK,否则返回ERROR224 * @notice225 ***/226 /***227 * @name Status findBTree(BTree T, BTree &amp;p, int &amp;ans, KeyType k)228 * @description 寻找 ,T为要寻找的树，p为返回的节点，ans为第几个元素，k为要找的值229 * @return 成功返回OK,否则返回ERROR230 * @notice231 ***/232 Status findBTree(BTree T, BTree &amp;p, int &amp;ans, KeyType k)233 &#123;234 BTree q;235 int index = 1;236 KeyType keynow;237 if (T == NULL)238 return ERROR;239 q = T;240 keynow = T-&gt;key[1];241 while (q != NULL) //深度的遍历242 &#123;243 index = 1;244 keynow = q-&gt;key[index];245 while (index &lt;= q-&gt;keynum) //节点内对各真值进行遍历246 &#123;247 if (k == keynow) //找到元素248 &#123;249 p = q;250 ans = index;251 return TRUE;252 &#125;253 if (k &gt; keynow)254 &#123;255 if (index == q-&gt;keynum)256 &#123;257 if (q-&gt;ptr[index] == NULL)258 &#123;259 p = q;260 ans = q-&gt;keynum + 1;261 return FALSE;262 &#125;263 q = q-&gt;ptr[index];264 break;265 &#125;266 ++index;267 keynow = q-&gt;key[index];268 continue;269 &#125;270 if (k &lt; keynow)271 &#123;272 if (q-&gt;ptr[index - 1] == NULL)273 &#123;274 p = q;275 ans = index;276 return FALSE;277 &#125;278 q = q-&gt;ptr[index - 1];279 break;280 &#125;281 &#125;282 &#125;283 284 return ERROR;285 &#125;286 /***287 * @name Status renewParent(BTree p)288 * @description 告诉孩子们亲身爸爸是谁289 * @return 成功返回OK,否则返回ERROR290 * @notice291 ***/292 Status renewParent(BTree p)293 &#123;294 int index;295 if (p == NULL) return ERROR;296 for (index = 0;index &lt;= p-&gt;keynum;++index)297 &#123;298 if (p-&gt;ptr[index] != NULL)299 &#123;300 p-&gt;ptr[index]-&gt;parent = p;301 renewParent(p-&gt;ptr[index]);302 &#125;303 &#125;304 return OK;305 &#125;306 /***307 * @name int whichSon(BTree T)308 * @description 找出是父亲的第几个孩子309 * @return 成功返回第几个孩子,否则返回-1310 * @notice311 ***/312 int whichSon(BTree T)313 &#123;314 int index = -1;315 if (T == NULL) return -1;316 for (index = 0;index &lt;= T-&gt;parent-&gt;keynum;++index) //找出是父亲的第几个孩子317 &#123;318 if (T-&gt;parent-&gt;ptr[index] == T) return index;319 &#125;320 return -1;321 &#125;322 /***323 * @name status splitBTree(BTree T)324 * @description 递归实现分裂节点操作325 * @return 成功返回OK,否则返回ERROR326 * @notice327 ***/328 Status splitBTree(BTree T) //此时分裂的节点一定会是超出最大值的。329 &#123;330 BTree t1, t2;331 int index, index_1;332 if (T-&gt;parent == NULL)333 &#123;334 t1 = (BTree)malloc(BTLEN);335 if (NULL == t1) return OVERFLOW;336 t2 = (BTree)malloc(BTLEN);337 if (NULL == t2) return OVERFLOW;338 339 t1-&gt;keynum = m / 2;340 t2-&gt;keynum = m - (m / 2) - 1;341 t1-&gt;parent = T;342 t2-&gt;parent = T;343 for (index = 0;index &lt;= m; ++index) //先全部初始化344 &#123;345 t1-&gt;ptr[index] = NULL;346 t1-&gt;key[index] = 0;347 t2-&gt;ptr[index] = NULL;348 t2-&gt;key[index] = 0;349 &#125;350 for (index = 0;index &lt;= m / 2; ++index) //初始化t1351 &#123;352 t1-&gt;ptr[index] = T-&gt;ptr[index];353 t1-&gt;key[index] = T-&gt;key[index];354 &#125;355 t2-&gt;ptr[0] = T-&gt;ptr[(m / 2) + 1];356 for (index = (m / 2) + 2;index &lt;= m; ++index) //初始化t2357 &#123;358 t2-&gt;ptr[index - ((m / 2) + 1)] = T-&gt;ptr[index];359 t2-&gt;key[index - ((m / 2) + 1)] = T-&gt;key[index];360 &#125;361 T-&gt;keynum = 1;362 T-&gt;ptr[0] = t1;363 T-&gt;ptr[1] = t2;364 T-&gt;key[1] = T-&gt;key[m / 2 + 1];365 for (index = 2;index &lt;= m; ++index) //初始化T366 &#123;367 T-&gt;ptr[index] = NULL;368 T-&gt;key[index] = 0;369 &#125;370 return OK;371 &#125;372 373 index = whichSon(T);374 for (index_1 = T-&gt;parent-&gt;keynum;index_1 &gt; index;--index_1) //腾出父亲的位置375 &#123;376 T-&gt;parent-&gt;ptr[index_1 + 1] = T-&gt;parent-&gt;ptr[index_1];377 T-&gt;parent-&gt;key[index_1 + 1] = T-&gt;parent-&gt;key[index_1];378 &#125;379 T-&gt;parent-&gt;keynum++;380 T-&gt;parent-&gt;key[index + 1] = T-&gt;key[m / 2 + 1];381 t2 = T-&gt;parent-&gt;ptr[index + 1] = (BTree)malloc(BTLEN);382 if (NULL == t2) return OVERFLOW;383 for (index = 0;index &lt;= m; ++index) //先全部初始化384 &#123;385 t2-&gt;ptr[index] = NULL;386 t2-&gt;key[index] = 0;387 &#125;388 t2-&gt;keynum = m - (m / 2) - 1;389 t2-&gt;parent = T-&gt;parent;390 t2-&gt;ptr[0] = T-&gt;ptr[(m / 2) + 1];391 for (index = (m / 2) + 2;index &lt;= m; ++index) //初始化t2392 &#123;393 t2-&gt;ptr[index - ((m / 2) + 1)] = T-&gt;ptr[index];394 t2-&gt;key[index - ((m / 2) + 1)] = T-&gt;key[index];395 &#125;396 T-&gt;keynum = m / 2;397 for (index = (m / 2) + 1;index &lt;= m; ++index) //初始化t2398 &#123;399 T-&gt;ptr[index] = NULL;400 T-&gt;key[index] = 0;401 &#125;402 if (T-&gt;parent-&gt;keynum == m)403 &#123;404 splitBTree(T-&gt;parent);405 &#125;406 return OK;407 &#125;408 /***409 * @name Status insertBTree(BTree &amp;T, Record e)410 * @description 插入实现元素的插入411 * @return 成功返回OK,如果存在则返回FALSE，否则返回ERROR412 * @notice413 ***/414 Status insertBTree(BTree &amp;T, Record e)415 &#123;416 BTree p;417 int index, temp;418 Status find_flag;419 if (NULL == T)420 &#123;421 T = (BTree)malloc(BTLEN);422 if (NULL == T) return OVERFLOW;423 T-&gt;keynum = 1;424 T-&gt;parent = NULL;425 for (index = 0;index &lt;= m; ++index)426 &#123;427 T-&gt;ptr[index] = NULL;428 T-&gt;key[index] = 0;429 &#125;430 T-&gt;key[1] = e.key;431 return OK;432 &#125;433 find_flag = findBTree(T, p, temp, e.key);434 if (find_flag == TRUE)435 &#123;436 return FALSE;437 &#125;438 if (find_flag == FALSE)439 &#123; //不管怎样先直接插入440 p-&gt;keynum++;441 for (index = p-&gt;keynum;index &gt; temp;--index) //挪位置442 &#123;443 p-&gt;key[index] = p-&gt;key[index - 1];444 p-&gt;ptr[index] = p-&gt;ptr[index - 1];445 &#125;446 p-&gt;ptr[temp] = NULL;447 p-&gt;key[temp] = e.key;448 if (p-&gt;keynum == m) //这种情况得分裂449 &#123;450 splitBTree(p);451 &#125;452 renewParent(T);453 return OK;454 &#125;455 return ERROR;456 &#125;457 /***458 * @name Status borrowBNode(BTree &amp;T)459 * @description 递归实现，向兄弟借元素，否则和兄弟合并460 * @return 成功返回OK,否则返回ERROR461 * @notice 这种情况应该是T为单元素结点462 ***/463 Status borrowBNode(BTree T)464 &#123;465 int mynum, bronum, index;466 BTree b = NULL, f = NULL;467 if (T == NULL) return ERROR;468 f = T-&gt;parent;469 if (f == NULL)//考虑父亲结点不存在的情况470 &#123;471 if (T-&gt;keynum == 0)472 &#123;473 f = T-&gt;ptr[0];474 if (f == NULL)475 &#123;476 free(T);477 return EMPTY;478 &#125;479 for (index = 0;index &lt;= f-&gt;keynum;index++)480 &#123;481 T-&gt;key[index] = f-&gt;key[index];482 T-&gt;ptr[index] = f-&gt;ptr[index];483 &#125;484 T-&gt;keynum = f-&gt;keynum;485 free(f);486 renewParent(T);487 &#125;488 return OK;489 &#125;490 mynum = whichSon(T);491 if (mynum == 0)492 bronum = 1;493 else494 bronum = mynum - 1;495 b = f-&gt;ptr[bronum];496 if (b-&gt;keynum == (m + 1) / 2 - 1) //如果兄弟帮不了你了497 &#123;498 //那么就和这个兄弟合体499 if (bronum &lt; mynum) //如果我不是第一个500 &#123;501 b-&gt;keynum++;502 b-&gt;key[b-&gt;keynum] = f-&gt;key[mynum];503 b-&gt;ptr[b-&gt;keynum] = T-&gt;ptr[0];504 for (index = 1;index &lt;= T-&gt;keynum;index++)505 &#123;506 b-&gt;key[index + b-&gt;keynum] = T-&gt;key[index];507 b-&gt;ptr[index + b-&gt;keynum] = T-&gt;ptr[index];508 b-&gt;keynum++;509 &#125;510 free(T);511 for (index = mynum;index &lt;= f-&gt;keynum;index++)512 &#123;513 f-&gt;key[index] = f-&gt;key[index + 1];514 f-&gt;ptr[index] = f-&gt;ptr[index + 1];515 &#125;516 f-&gt;keynum--;517 &#125;518 else519 &#123;520 T-&gt;keynum++;521 T-&gt;key[T-&gt;keynum] = f-&gt;key[bronum];522 T-&gt;ptr[T-&gt;keynum] = b-&gt;ptr[0];523 for (index = 1;index &lt;= b-&gt;keynum;index++)524 &#123;525 T-&gt;key[index + T-&gt;keynum] = b-&gt;key[index];526 T-&gt;ptr[index + T-&gt;keynum] = b-&gt;ptr[index];527 T-&gt;keynum++;528 &#125;529 free(b);530 for (index = bronum;index &lt;= f-&gt;keynum;index++)531 &#123;532 f-&gt;key[index] = f-&gt;key[index + 1];533 f-&gt;ptr[index] = f-&gt;ptr[index + 1];534 &#125;535 f-&gt;keynum--;536 &#125;537 renewParent(f);538 if (f-&gt;keynum == (m + 1) / 2 - 2)539 &#123;540 //调用借兄弟的函数541 return borrowBNode(f);542 &#125;543 &#125;544 else//如果兄弟能够帮你545 &#123;546 if (bronum &lt; mynum) //如果我不是第一个547 &#123;548 for (index = 1;index &lt;= T-&gt;keynum;index++)549 &#123;550 T-&gt;key[index + 1] = T-&gt;key[index];551 T-&gt;ptr[index + 1] = T-&gt;ptr[index];552 &#125;553 T-&gt;ptr[1] = T-&gt;ptr[0];554 T-&gt;key[1] = f-&gt;key[mynum];555 T-&gt;ptr[0] = b-&gt;ptr[b-&gt;keynum];556 T-&gt;keynum++;557 f-&gt;key[mynum] = b-&gt;key[b-&gt;keynum];558 b-&gt;key[b-&gt;keynum] = 0;559 b-&gt;ptr[b-&gt;keynum] = NULL;560 b-&gt;keynum--;561 562 &#125;563 else //如果我是第一个564 &#123;565 T-&gt;keynum++;566 T-&gt;key[T-&gt;keynum] = f-&gt;key[1];567 T-&gt;ptr[T-&gt;keynum] = b-&gt;ptr[0];568 f-&gt;key[1] = b-&gt;key[1];569 b-&gt;ptr[0] = b-&gt;ptr[1];570 for (index = 1;index &lt;= b-&gt;keynum;index++)571 &#123;572 b-&gt;key[index] = b-&gt;key[index + 1];573 b-&gt;ptr[index] = b-&gt;ptr[index + 1];574 &#125;575 b-&gt;keynum--;576 &#125;577 &#125;578 return OK;579 &#125;580 581 /***582 * @name Status deleteBTreeRecord(BTree &amp;T, Record e)583 * @description 实现B树元素的删除584 * @return 成功返回OK,否则返回ERROR585 * @notice586 ***/587 Status deleteBTreeRecord(BTree &amp;T, Record e)588 &#123;589 BTree p, q;590 int num, temp, index;591 Status find_flag;592 if (T == NULL)593 return ERROR;594 find_flag = findBTree(T, p, temp, e.key);595 if (find_flag == FALSE)596 &#123;597 return FALSE;598 &#125;599 if (find_flag == TRUE)600 &#123;601 //deleteBTreeBNode(p,temp);602 if (p-&gt;ptr[temp] == NULL) //如果是叶子节点的话603 &#123;604 for (index = temp;index &lt;= p-&gt;keynum;++index)605 &#123;606 p-&gt;key[index] = p-&gt;key[index + 1];607 p-&gt;ptr[index] = p-&gt;ptr[index + 1];608 &#125;609 p-&gt;keynum--;610 if (p-&gt;keynum == (m + 1) / 2 - 2)611 &#123;612 //调用借兄弟的函数613 if (borrowBNode(p) == EMPTY) T = NULL;614 else renewParent(T);615 &#125;616 return OK;617 &#125;618 else //不是叶子结点的话619 &#123;620 //遍历621 findMax(p-&gt;ptr[temp - 1], q, num);//返回的q一定会是叶子节点622 p-&gt;key[temp] = q-&gt;key[num];623 q-&gt;key[num] = 0;624 q-&gt;keynum--;625 if (q-&gt;keynum == (m + 1) / 2 - 2)626 &#123;627 //调用借兄弟的函数628 if (borrowBNode(q) == EMPTY) T = NULL;629 else renewParent(T);630 &#125;631 return OK;632 &#125;633 return OK;634 &#125;635 return ERROR;636 &#125;637 /***638 * @name Status initBTree(BTree &amp;t)639 * @description 初始化一个空B树640 * @return 成功返回OK641 * @notice642 ***/643 Status initBTree(BTree &amp;t)644 &#123;645 t = NULL;646 return OK;647 &#125;648 /***649 * @name Status test()650 * @description 针对数据结构实验做的测试函数651 * @return 成功返回OK652 * @notice653 ***/654 Status test()655 &#123;656 // 测试代码657 int n, i;658 int arr[BTREELENGTH];659 BTree a;660 Record d;661 srand((unsigned)time(NULL));662 n = rand() % BTREELENGTH;663 //scanf(&quot;%d&quot;, &amp;n); //可以改为自己输入数据664 printf(&quot;B树的阶为:%d,插入次数为:%d\n&quot;, m, n);665 initBTree(a);666 for (i = 0;i &lt; n;i++)667 &#123;668 d.key = rand() % MAXINT;669 //scanf(&quot;%d&quot;, &amp;d.key); //可以改为自己输入数据670 arr[i] = d.key;671 if (insertBTree(a, d) == OK)672 printf(&quot;第%d次插入%d:\n&quot;, i + 1, d.key);673 else674 printf(&quot;第%d次插入%d不成功:\n&quot;, i + 1, d.key);675 print(a);676 &#125;677 for (i = 0;i &lt; n;i++)678 &#123;679 d.key = arr[i];680 if (deleteBTreeRecord(a, d) == OK)681 printf(&quot;第%d次删除%d:\n&quot;, i + 1, d.key);682 else683 printf(&quot;第%d次删除%d不成功:\n&quot;, i + 1, d.key);684 print(a);685 &#125;686 return OK;687 688 &#125;689 /***690 主函数691 ***/692 int main()693 &#123;694 test();695 return 0;696 &#125; B+树]]></content>
      <categories>
        <category>基础</category>
      </categories>
      <tags>
        <tag>B树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[查找与排序-KMP算法栈队列]]></title>
    <url>%2F2020%2F09%2F12%2F%E6%9F%A5%E6%89%BE%E4%B8%8E%E6%8E%92%E5%BA%8F-KMP%E7%AE%97%E6%B3%95%E6%A0%88%E9%98%9F%E5%88%97%2F</url>
    <content type="text"><![CDATA[冒泡排序选择排序首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置，然后，再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。以此类推，直到所有元素均排序完毕。 稳定性：不稳定 插入排序通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。插入排序因而在从后向前扫描过程中，需要反复把已排序元素逐步向后挪位，为最新元素提供插入空间。 例子：拿扑克牌排序 Input: {4, 3, 8, 5, 2, 6, 1, 7}。 首先拿起第一张牌, 手上有 {4}。 拿起第二张牌 3, 把 3insert 到手上的牌 {4}, 得到 {3 ，4}。 拿起第三张牌 8, 把 8 insert 到手上的牌 {3，4 }, 得到 {3 ，4，8}。 以此类推。 稳定性：稳定 希尔排序分治做法，先分组，把自己组内的先排好序，再合并 1234567891011121314void shell_sort(int *data, int length) &#123; int gap = 0; int i = 0, j = 0; for (gap = length / 2; gap &gt;= 1; gap /= 2) &#123; // 第一层是分组 for (i = gap; i &lt; length; i++) &#123; // 第二层是先保证前面有序，再遍历后面 int temp = data[i]; for (j = i - gap; j &gt;= 0 &amp;&amp; temp &lt; data[j]; j -= gap) &#123; //把大的挪到后面 data[j + gap] = data[j]; &#125; data[j + gap] = temp; &#125; &#125;&#125; 平均O(1.3n) 归并排序分治，把一个集合分成两部分，第一部分再分成两部分，第二部分再分成两部分，直到分到最后一层是两块。 12345678910111213141516171819202122232425262728void sort(int *data, int *temp, int start, int mid, int end) &#123; int i = start, j = mid + 1, k = start; while (i &lt;= mid &amp;&amp; j &lt;= end) &#123; if (data[i] &lt; data[j]) &#123; temp[k++] = data[i++]; &#125; else &#123; temp[k++] = data[j++]; &#125; &#125; while (i &lt;= mid) &#123; temp[k++] = data[i++]; &#125; while (j &lt;= end) &#123; temp[k++] = data[j++]; &#125; for (i = start; i &lt;= end; i++) &#123; data[i] = temp[i]; &#125;&#125;void merge_sort(int *data, int *temp, int start, int end) &#123; if (start &lt; end) &#123; int mid = start + (end - start) / 2; merge_sort(data, temp, start, mid); merge_sort(data, temp, mid + 1, end); sort(data, temp, start, mid, end); &#125;&#125; 最差和最好都是 O(nlogn) 稳定 快速排序第一个值作为哨兵位，从最左端到最右端，如果满足条件，右端–，左端++，直到左端等于右端，那么就确定了哨兵位的位置，赋值即可。 123456789101112131415161718192021222324252627282930313233void sort(int *data, int left, int right) &#123; if (left &gt;= right) return ; int i = left; int j = right; int key = data[left]; while (i &lt; j) &#123; while (i &lt; j &amp;&amp; key &lt;= data[j]) &#123; j --; &#125; data[i] = data[j]; while (i &lt; j &amp;&amp; key &gt;= data[i]) &#123; i ++; &#125; data[j] = data[i]; &#125; data[i] = key; sort(data, left, i - 1); sort(data, i + 1, right);&#125;int quick_sort(int *data, int length) &#123; sort(data, 0, length-1);&#125; KMPtext = “abababababacsdkfasdf”ptn = “abab” 回溯多少。取决于共同前缀与后缀，有多少。abc -&gt; a/ab(前缀) c/bc（后缀）0aba -&gt; a/ab a/ba 1abcabc -&gt; a/ab/abc/abca/abcab c/bc/abc/cabc/bcabc 3 void make_next(const char *pattern, int *next) { int q, k; int m = strlen(pattern); next[0] = 0; for (q = 1,k = 0;q &lt; m; q ++) { while (k &gt; 0 &amp;&amp; pattern[q] != pattern[k]) k = next[k-1]; if (pattern[q] == pattern[k]) { k ++; } next[q] = k; } // next[0] = 0; // q=1, k=0, pattern[q]:pattern[k] = b:a, next[1] = 0; // q=2, k=0, pattern[q]:pattern[k] = c:a, next[2] = 0; // q=3, k=0, pattern[q]:pattern[k] = a:a, k++, next[3] = 1; // q=4, k=1, pattern[q]:pattern[k] = b:b, k++, next[4] = 2; // q=5, k=2, pattern[q]:pattern[k] = c:c, k++, next[5] = 3; // q=6, k=3, pattern[q]:pattern[k] = d:a, k=next[k-1] -&gt; k=0; next[6] = 0; } int kmp(const char *text, const char *pattern, int *next) { int n = strlen(text); int m = strlen(pattern); make_next(pattern, next); int i, q; for (i = 0, q = 0;i &lt; n;i ++) { while (q &gt; 0 &amp;&amp; pattern[q] != text[i]) { q = next[q-1]; } if (pattern[q] == text[i]) { q ++; } if (q == m) { //printf(&quot;Pattern occurs with shift: %d\n&quot;, (i-m+1)); break; } } return i-q+1; }]]></content>
      <categories>
        <category>基础</category>
      </categories>
      <tags>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[idea-maven工程配置]]></title>
    <url>%2F2018%2F08%2F04%2Fidea-maven%E5%B7%A5%E7%A8%8B%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[解决idea创建maven工程后无java,resouces文件问题 Project Structure Modules-Sources New Folder 解决创建properties文件问题 解决idea application context not configured for this file问题spring配置文件中时常会出现这个提示，翻译过来大概意思就是没有配置该文件到项目中 于是进入到file-Project Structure中查看 可以很明显的看到下面有个感叹号，大概意思是下面的文件没有匹配 知道原因就很好解决问题了，只需要加到项目中去就可以了 解决idea无法创建jsp文件问题File-&gt;Project Struction -&gt;modules 按加号 新增web,双击web resource directory 修改路径 web resource directory path 为 当前项目目录/src/webapp -&gt;WEB-INF-&gt;JSP]]></content>
      <categories>
        <category>idea</category>
      </categories>
      <tags>
        <tag>idea</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python 关于excel]]></title>
    <url>%2F2018%2F06%2F12%2FPython-%E5%85%B3%E4%BA%8Eexcel%2F</url>
    <content type="text"><![CDATA[read_excel()加载函数为read_excel(),其具体参数如下。 read_excel(io, sheetname=0, header=0, skiprows=None, skip_footer=0, index_col=None,names=None, parse_cols=None, parse_dates=False,date_parser=None,na_values=None,thousands=None, convert_float=True, has_index_names=None, converters=None,dtype=None, true_values=None, false_values=None, engine=None, squeeze=False, **kwds) 常用参数解析： io : string, path object ; excel 路径。 sheetname : string, int, mixed list of strings/ints, or None, default 0 返回多表使用sheetname=[0,1],若sheetname=None是返回全表 注意：int/string 返回的是dataframe，而none和list返回的是dict of dataframe header : int, list of ints, default 0 指定列名行，默认0，即取第一行，数据为列名行以下的数据 若数据不含列名，则设定 header = None skiprows : list-like,Rows to skip at the beginning，省略指定行数的数据 skip_footer : int,default 0, 省略从尾部数的int行数据 index_col : int, list of ints, default None指定列为索引列，也可以使用u”strings” names : array-like, default None, 指定列的名字。 举例sheet1: ID NUM-1 NUM-2 NUM-3 36901 142 168 661 36902 78 521 602 36903 144 600 521 36904 95 457 468 36905 69 596 695 sheet2： ID NUM-1 NUM-2 NUM-3 36906 190 527 691 36907 101 403 470 1.iobasestation =&quot;F://pythonBook_PyPDAM/data/test.xls&quot; data = pd.read_excel(basestation) print data 此时输出： ID NUM-1 NUM-2 NUM-3 0 36901 142 168 661 1 36902 78 521 602 2 36903 144 600 521 3 36904 95 457 468 4 36905 69 596 695 2.sheetname返回多表使用sheetname=[0,1],若sheetname=None是返回全表 注意：int/string 返回的是dataframe，而none和list返回的是dict of dataframe data_1 = pd.read_excel(basestation,sheetname=[0,1]) print data_1 print type(data_1) 此时输出： OrderedDict([(0, ID NUM-1 NUM-2 NUM-3 0 36901 142 168 661 1 36902 78 521 602 2 36903 144 600 521 3 36904 95 457 468 4 36905 69 596 695), (1, ID NUM-1 NUM-2 NUM-3 0 36906 190 527 691 1 36907 101 403 470)]) 3.header指定列名行，默认0，即取第一行，数据为列名行以下的数据 若数据不含列名，则设定 header = None ，注意这里还有列名的一行。 data = pd.read_excel(basestation,header=None) print data 输出： 0 1 2 3 0 ID NUM-1 NUM-2 NUM-3 1 36901 142 168 661 2 36902 78 521 602 3 36903 144 600 521 4 36904 95 457 468 5 36905 69 596 695 data = pd.read_excel(basestation,header=[3]) print data 输出： 36903 144 600 521 0 36904 95 457 468 1 36905 69 596 695 4.skiprows省略指定行数的数据 data = pd.read_excel(basestation,skiprows = [1]) print data 输出: ID NUM-1 NUM-2 NUM-3 0 36902 78 521 602 1 36903 144 600 521 2 36904 95 457 468 3 36905 69 596 695 5.skip_footer省略从尾部数的int行的数据 data = pd.read_excel(basestation, skip_footer=3) print data 输出： ID NUM-1 NUM-2 NUM-3 0 36901 142 168 661 1 36902 78 521 602 6.index_col指定列为索引列，也可以使用u”strings” data = pd.read_excel(basestation, index_col=&quot;NUM-3&quot;) print data 输出： ID NUM-1 NUM-2 NUM-3 661 36901 142 168 602 36902 78 521 521 36903 144 600 468 36904 95 457 695 36905 69 596 7.names指定列的名字 data = pd.read_excel(basestation,names=[&quot;a&quot;,&quot;b&quot;,&quot;c&quot;,&quot;e&quot;]) print data a b c e 0 36901 142 168 661 1 36902 78 521 602 2 36903 144 600 521 3 36904 95 457 468 4 36905 69 596 695 to_excel()存储函数为pd.DataFrame.to_excel() to_excel(self, excel_writer, sheet_name=’Sheet1’, na_rep=’’, float_format=None,columns=None, header=True, index=True, index_label=None,startrow=0, startcol=0, engine=None, merge_cells=True, encoding=None,inf_rep=’inf’, verbose=True, freeze_panes=None) excel_writer : 目标路径 sheet_name : 填充excel的第几页 na_rep : excel中缺失值的填充 float_format : string, default None Format string for floating point numbers columns : sequence, optional，Columns to write 选择输出的的列。 header : boolean or list of string, default True Write out column names. If a list of string is given it is assumed to be aliases for the column names index : boolean, default True，Write row names (index) index_label : string or sequence, default None， Column label for index column(s) if desired. If None is given, andheader and index are True, then the index names are used. A sequence should be given if the DataFrame uses MultiIndex. startrow :upper left cell row to dump data frame startcol :upper left cell column to dump data frame engine : string, default None ，write engine to use - you can also set this via the options，io.excel.xlsx.writer, io.excel.xls.writer, andio.excel.xlsm.writer. merge_cells : boolean, default True Write MultiIndex and Hierarchical Rows as merged cells. encoding: string, default None encoding of the resulting excel file. Only necessary for xlwt,other writers support unicode natively. inf_rep : string, default ‘inf’ Representation for infinity (there is no native representation for infinity in Excel) freeze_panes : tuple of integer (length 2), default None Specifies the one-based bottommost row and rightmost column that is to be frozen 数据源： ID NUM-1 NUM-2 NUM-3 0 36901 142 168 661 1 36902 78 521 602 2 36903 144 600 521 3 36904 95 457 468 4 36905 69 596 695 5 36906 165 453 加载数据： basestation =&quot;F://python/data/test.xls&quot; basestation_end =&quot;F://python/data/test_end.xls&quot; data = pd.read_excel(basestation) 1.excel_writer输出路径 data.to_excel(basestation_end) 输出： ID NUM-1 NUM-2 NUM-3 0 36901 142 168 661 1 36902 78 521 602 2 36903 144 600 521 3 36904 95 457 468 4 36905 69 596 695 5 36906 165 453 2.sheet_name将数据存储在excel的那个sheet页面 data.to_excel(basestation_end,sheet_name=&quot;sheet2&quot;) 3.na_rep缺失值填充 data.to_excel(basestation_end,na_rep=&quot;NULL&quot;) 输出： ID NUM-1 NUM-2 NUM-3 0 36901 142 168 661 1 36902 78 521 602 2 36903 144 600 521 3 36904 95 457 468 4 36905 69 596 695 5 36906 165 453 NULL 4.colums选择输出的的列 data.to_excel(basestation_end,columns=[&quot;ID&quot;]) 输出 ID 0 36901 1 36902 2 36903 3 36904 4 36905 5 36906 5.header默认为True,可以用list命名列的名字。header = False 则不输出题头 data.to_excel(basestation_end,header=[&quot;a&quot;,&quot;b&quot;,&quot;c&quot;,&quot;d&quot;]) 输出： a b c d 0 36901 142 168 661 1 36902 78 521 602 2 36903 144 600 521 3 36904 95 457 468 4 36905 69 596 695 5 36906 165 453 data.to_excel(basestation_end,header=False,columns=[&quot;ID&quot;]) header = False 则不输出题头 输出： 0 36901 1 36902 2 36903 3 36904 4 36905 5 36906 6.index默认为True，显示index，当index=False 则不显示行索引（名字） index_label : string or sequence, default None设置索引列的列名 data.to_excel(basestation_end,index=False) 输出： ID NUM-1 NUM-2 NUM-3 36901 142 168 661 36902 78 521 602 36903 144 600 521 36904 95 457 468 36905 69 596 695 36906 165 453 data.to_excel(basestation_end,index_label=[&quot;f&quot;]) 输出： f ID NUM-1 NUM-2 NUM-3 0 36901 142 168 661 1 36902 78 521 602 2 36903 144 600 521 3 36904 95 457 468 4 36905 69 596 695 5 36906 165 453 以上为read_excel,to_excel用法，若是想对已经读出的excel文件有所操作，请转移：https://blog.csdn.net/liufang0001/article/details/77856255]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python-tkinter-简单使用介绍]]></title>
    <url>%2F2018%2F05%2F30%2Fpython-tkinter-%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8%E4%BB%8B%E7%BB%8D%2F</url>
    <content type="text"><![CDATA[本文主要介绍几个简单的tkinter组件。 说明每个控件最后要加上pack().否则控件是无法显示的. Label说明 标签 举例 from Tkinter import * root = Tk() root.title(&quot;hello world&quot;) root.geometry(&apos;300x200&apos;) l = Label(root, text=&quot;show&quot;, bg=&quot;green&quot;, font=(&quot;Arial&quot;, 12), width=5, height=2) l.pack(side=LEFT) #这里的side可以赋值为LEFT RTGHT TOP BOTTOM root.mainloop() 效果 Frame说明 在屏幕上创建一块矩形区域,多作为容器来布局窗体 举例 from Tkinter import * root = Tk() root.title(&quot;hello world&quot;) root.geometry(&apos;300x200&apos;) Label(root, text=&apos;校训&apos;, font=(&apos;Arial&apos;, 20)).pack() frm = Frame(root) # left frm_L = Frame(frm) Label(frm_L, text=&apos;厚德&apos;, font=(&apos;Arial&apos;, 15)).pack(side=TOP) Label(frm_L, text=&apos;博学&apos;, font=(&apos;Arial&apos;, 15)).pack(side=TOP) frm_L.pack(side=LEFT) # right frm_R = Frame(frm) Label(frm_R, text=&apos;敬业&apos;, font=(&apos;Arial&apos;, 15)).pack(side=TOP) Label(frm_R, text=&apos;乐群&apos;, font=(&apos;Arial&apos;, 15)).pack(side=TOP) frm_R.pack(side=RIGHT) frm.pack() root.mainloop() 效果 Entry说明 创建单行文本框 用法 创建:lb =Entry(根对象, [属性列表]) 绑定变量 var=StringVar() lb=Entry(根对象, textvariable = var) 获取文本框中的值 var.get() 设置文本框中的值 var.set(item1) 举例 from Tkinter import * root = Tk() root.title(&quot;hello world&quot;) root.geometry() var = StringVar() e = Entry(root, textvariable = var) var.set(&quot;hello&quot;) e.pack() root.mainloop() 效果 Text说明 向该空间内输入文本 用法 t = Text(根对象) 插入:t.insert(mark, 内容) 删除:t.delete(mark1, mark2) 其中,mark可以是行号,或者特殊标识,例如 INSERT:光标的插入点CURRENT:鼠标的当前位置所对应的字符位置 END:这个Textbuffer的最后一个字符 SEL_FIRST:选中文本域的第一个字符，如果没有选中区域则会引发异常 SEL_LAST：选中文本域的最后一个字符，如果没有选中区域则会引发 异常 举例 from Tkinter import * root = Tk() root.title(&quot;hello world&quot;) root.geometry(&apos;300x200&apos;) t = Text(root) t.insert(1.0, &apos;hello\n&apos;) t.insert(END, &apos;hello000000\n&apos;) t.insert(END, &apos;nono&apos;) t.pack() root.mainloop() 效果 Button说明 创建按钮 用法 Button(根对象, [属性列表]) 举例 from Tkinter import * root = Tk() root.title(&quot;hello world&quot;) root.geometry() def printhello(): t.insert(&apos;1.0&apos;, &quot;hello\n&quot;) t = Text() t.pack() Button(root, text=&quot;press&quot;, command = printhello).pack() root.mainloop() 效果 Listbox说明 列表控件,可以含有一个或多个文本想,可单选也可多选 用法 创建:lb = ListBox(根对象, [属性列表]) 绑定变量 var=StringVar() lb=ListBox(根对象, listvariable = var) 得到列表中的所有值 var.get() 设置列表中的所有值 var.set((item1, item2, …..)) 添加:lb.insert(item) 删除:lb.delete(item,…) 绑定事件 lb.bind(‘‘, 函数) 获得所选中的选项 lbl.get(lb.curselection()) 属性 selectmode可以为BROWSE MULTIPL SINGLE 举例 from Tkinter import * root = Tk() root.title(&quot;hello world&quot;) root.geometry() def print_item(event): print(lb.get(lb.curselection())) var = StringVar() lb = Listbox(root, listvariable = var) list_item = [1, 2, 3, 4] #控件的内容为1 2 3 4 for item in list_item: lb.insert(END, item) lb.delete(2, 4) #此时控件的内容为1 3 var.set((&apos;a&apos;, &apos;ab&apos;, &apos;c&apos;, &apos;d&apos;)) #重新设置了，这时控件的内容就编程var的内容了 print var.get() lb.bind(&apos;&lt;ButtonRelease-1&gt;&apos;, print_item) lb.pack() root.mainloop() 效果 Scrollbar说明 在屏幕上创建一块矩形区域,多作为容器来布局窗体 用法 Frame(根对象, [属性列表]), 最长用的用法是和别的控件一起使用. 举例 from Tkinter import * root = Tk() root.title(&quot;hello world&quot;) root.geometry() def print_item(event): print lb.get(lb.curselection()) var = StringVar() lb = Listbox(root, height=5, selectmode=BROWSE, listvariable = var) lb.bind(&apos;&lt;ButtonRelease-1&gt;&apos;, print_item) list_item = [1, 2, 3, 4, 5, 6, 7, 8, 9, 0] for item in list_item: lb.insert(END, item) scrl = Scrollbar(root) scrl.pack(side=RIGHT, fill=Y) lb.configure(yscrollcommand = scrl.set) lb.pack(side=LEFT, fill=BOTH) scrl[&apos;command&apos;] = lb.yview root.mainloop() 效果]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>tkinter</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python tkinter pack布局]]></title>
    <url>%2F2018%2F05%2F24%2Fpython-tkinter-pack%E5%B8%83%E5%B1%80%2F</url>
    <content type="text"><![CDATA[一、pack参数： &emsp;&emsp;side:按扭停靠在窗口的哪个位置 left: 左 top: 上 right: 右 botton: 下 fill:填充 x:水平方向填充 y:竖直方向填充 both:水平和竖直方向填充 none:不填充 expand: yes:扩展整个空白区 no:不扩展 anchor: N:北 下 E:东 右 S:南 下 W:西 左 CENTER:中间 padx:x方向的外边距 pady:y方向的外边距 ipadx:x方向的内边距 ipady：y方向的内边距 二、代码示例：12345678910from Tkinter import *root = Tk()Button(root,text=&apos;A&apos;).pack(side=LEFT,expand=YES,fill=Y)Button(root,text=&apos;B&apos;).pack(side=TOP,expand=YES,fill=BOTH)Button(root,text=&apos;C&apos;).pack(side=RIGHT,expand=YES,fill=NONE)Button(root,text=&apos;D&apos;).pack(side=LEFT,expand=NO,fill=Y)Button(root,text=&apos;E&apos;).pack(side=TOP,expand=YES,fill=BOTH)Button(root,text=&apos;F&apos;).pack(side=BOTTOM,expand=YES)Button(root,text=&apos;G&apos;).pack(anchor=SE)root.mainloop()]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>tkinter</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[12306查票订票]]></title>
    <url>%2F2018%2F04%2F16%2F12306%E6%9F%A5%E7%A5%A8%E8%AE%A2%E7%A5%A8%2F</url>
    <content type="text"><![CDATA[参考链接：https://blog.csdn.net/lzqwebsoft/article/details/18674635https://www.lanindex.com/12306%E8%B4%AD%E7%A5%A8%E6%B5%81%E7%A8%8B%E5%85%A8%E8%A7%A3%E6%9E%90/ 模拟查票订票操作如下：1.首先12306是一个需要登录操作的网站，然而12306的登录验证大家都知道需要验证码。另外12306的验证码很坑~，需要人工选择对应的物品，这个用代码识别网上我也没找到好的教程，于是… 于是只能人工识别啦。。2.登录之后我们需要输入起始地，目的地，时间等信息，然后查询3.此时我们可以查询到车次信息了，根据自己的时间然后订合适时间和合适座位的票4.选择乘坐人5.建立好订单6.付款，订票成功 显然我们做到第5步已经达到我们用爬虫的目的。1.登录操作请参考：http://www.cnblogs.com/fangtaoa/p/8321449.html2.查票操作请参考：http://www.cnblogs.com/fangtaoa/p/8360460.html3.下面补充订票操作:按照置顶的参考链接里的步骤获取url和data数据，具体可以看代码类buy确实没什么地方需要多说的，有前驱者已经铺好路了，只需按照步骤一步一步理解就可以了下面补充操作方式： 每一步都有相应的步骤名称，如果哪一步出错了只需在代码中寻找具体是哪个函数没对即可。下面给出代码：1.login.py123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172import requestsimport chardetimport userimport settingsfrom coordinate import coorfrom lxml import etreeclass Login: def __init__(self): self.headers = settings.headers self.session = settings.session self.id = user.id self.psw = user.psw def down_captcha(self): # &apos;&apos;&apos; # 下载验证码 # &apos;&apos;&apos; response = self.session.get(&apos;https://kyfw.12306.cn/passport/captcha/captcha-image?login_site=E&amp;module=login&amp;rand=sjrand&amp;0.7067378301290344&apos;) codeImg = response.content fp = open(&apos;code.png&apos;, &apos;wb&apos;) fp.write(codeImg) fp.close() def get_pos(self): # &apos;&apos;&apos; # 输入验证码坐标 # &apos;&apos;&apos; coordinate = coor() return coordinate def captcha_check(self): # &apos;&apos;&apos; # 验证码初验证 # &apos;&apos;&apos; check_flag = False data = &#123; &apos;answer&apos;: self.get_pos(), &apos;login_site&apos;:&apos;E&apos;, &apos;rand&apos;: &apos;sjrand&apos; &#125; url = &apos;https://kyfw.12306.cn/passport/captcha/captcha-check&apos; response = self.session.post(url, data=data, headers=self.headers) result = response.json() if result[&apos;result_code&apos;] == &apos;4&apos;: print(&apos;验证码通过!&apos;) check_flag = True else: print(&apos;验证码验证失败!&apos;) return check_flag def login(self, check_flag): # &apos;&apos;&apos; # 进行第一步登录 # &apos;&apos;&apos; if not check_flag: print(&apos;login() error: check_flag为False.&apos;) return False login_flag=False login_data = &#123; &apos;username&apos;: self.id, &apos;password&apos;: self.psw, &apos;appid&apos;: &apos;otn&apos; &#125; login_url = &apos;https://kyfw.12306.cn/passport/web/login&apos; login_response = self.session.post(login_url, data=login_data, headers=self.headers) #设置网页编码 if chardet.detect(login_response.content).get(&apos;encoding&apos;) != &apos;UTF-8&apos;: login_response.encoding = &apos;UTF-8&apos; if login_response.status_code == 200 and &apos;error&apos; not in login_response.url: print(&apos;登录成功！&apos;) login_flag = True else: print(&apos;登录失败！&apos;) return login_flag def auth_uamtk(self,login_flag): # &apos;&apos;&apos; # 进行登录的验证 # &apos;&apos;&apos; data = &#123; &apos;appid&apos;: &apos;otn&apos;, &#125; url = &apos;https://kyfw.12306.cn/passport/web/auth/uamtk&apos; resp = self.session.post(url, data=data, headers=self.headers) if resp.status_code == 200: result = dict(resp.json()) print(&apos;auth_uamtk():&apos;, result[&apos;result_message&apos;]) if result.get(&apos;result_code&apos;) == 0:## return result.get(&apos;newapptk&apos;) else: return None else: print(&apos;登录验证失败！&apos;) return None def uamatuth_client(self, newapptk): # &apos;&apos;&apos; # 确认是否真正的登录成功 # :param newapptk: # :return: # &apos;&apos;&apos; if newapptk is None: print(&apos;并没有真正的登录成功！&apos;) return None data = &#123; &apos;tk&apos;: newapptk, &#125; url = &apos;https://kyfw.12306.cn/otn/uamauthclient&apos; resp = self.session.post(url, data=data, headers=self.headers) if resp.status_code == 200: result = dict(resp.json()) print(&apos;uamatuth_client()&apos;, result.get(&apos;result_message&apos;)) if result.get(&apos;result_code&apos;) == 0: username = result.get(&apos;username&apos;) print(&apos;&#123;&#125;初始化登录成功!&apos;.format(username)) return username else: print(&apos;uamatuth_client() error! status_code:&#123;&#125;, url:&#123;&#125;&apos; .format(resp.status_code, resp.url)) def init_my_12306(self, username): if username is None: print(&apos;init_my_12306() error: username 为None!&apos;) return url = &apos;https://kyfw.12306.cn/otn/index/initMy12306&apos; resp = self.session.get(url, headers=self.headers) if resp.status_code == 200: content = etree.HTML(resp.content) #先用etree转化 name = content.xpath(&apos;//*[@id=&quot;login_user&quot;]/span/text()&apos;) print(&apos;init_my_12306(): name&apos;, name) if name == username: print(&apos;init_my_12306():你已经登录成功了!&apos;) else: print(&apos;init_my_12306() error! status_code:&#123;&#125;, url:&#123;&#125;&apos;. format(resp.status_code, resp.url))def main(): login = Login() login.down_captcha() check_flag = login.captcha_check() login_flag = login.login(check_flag) if login_flag: newapptk = login.auth_uamtk(login_flag) username = login.uamatuth_client(newapptk) login.init_my_12306(username) else: print(&apos;main():login_flag为Flase&apos;)if __name__ == &apos;__main__&apos;: main() 2.user.py此处根据自己账户和名称写出id 和 psw 即可 id = ‘1111111’#账户名psw = ‘222222’#密码 3.settings.py 123456789101112131415import randomimport requests#随机选择一个有效的UA来请求头信息User_Agent = [ &apos;Mozilla/5.0 (Macintosh; U; Intel Mac OS X 10_6_8; en-us) AppleWebKit/534.50 (KHTML, like Gecko) Version/5.1 Safari/534.50&apos;, &apos;Mozilla/5.0 (Windows; U; Windows NT 6.1; en-us) AppleWebKit/534.50 (KHTML, like Gecko) Version/5.1 Safari/534.50&apos;, &apos;Mozilla/5.0 (compatible; MSIE 9.0; Windows NT 6.1; Trident/5.0&apos;, &apos;Mozilla/5.0 (Macintosh; Intel Mac OS X 10.6; rv:2.0.1) Gecko/20100101 Firefox/4.0.1&apos;, &apos;Opera/9.80 (Macintosh; Intel Mac OS X 10.6.8; U; en) Presto/2.8.131 Version/11.11&apos;, &apos;Opera/9.80 (Windows NT 6.1; U; en) Presto/2.8.131 Version/11.11&apos;, &apos;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_7_0) AppleWebKit/535.11 (KHTML, like Gecko) Chrome/17.0.963.56 Safari/535.11&apos;,]session = requests.Session()headers = &#123;&apos;user-agent&apos;: random.choice(User_Agent)&#125; 4.stations.py 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287from login import Loginimport osimport jsonimport timefrom collections import deque, OrderedDictclass Station: &quot;&quot;&quot; 查询车票信息 &quot;&quot;&quot; def __init__(self): # 使用登录时候的session,这样好一些! self.headers = Login().headers self.session = Login().session self.station_info = deque() def station_name_code(self): &quot;&quot;&quot; 功能:获取每个站点的名字和对应的代码,并保存到本地 :return: 无 &quot;&quot;&quot; filename = &apos;station_name.txt&apos; url = &apos;https://kyfw.12306.cn/otn/resources/js/framework/station_name.js&apos; resp = self.session.get(url, headers=self.headers) if resp.status_code == 200: print(&apos;station_name_code():获取站点信息成功!&apos;) with open(filename, &apos;w&apos;) as f: for each in resp.text.split(&apos;=&apos;)[1].split(&apos;@&apos;): if each != &quot;&apos;&quot;: f.write(each) f.write(&apos;\n&apos;) else: print(&apos;station_name_code() error! status_code:&#123;&#125;, url: &#123;&#125;&apos; .format(resp.status_code, resp.url)) def save_station_code(self, filename): &quot;&quot;&quot; 功能:从站点文件中提取站点与其对应的代码,并保存到文件中 :return: &quot;&quot;&quot; if not os.path.exists(filename): print(&apos;save_station_code():&apos;, filename, &apos;不存在,正在下载!&apos;) self.station_name_code() file = &apos;name_code.json&apos; name_code_dict = &#123;&#125; with open(filename, &apos;r&apos;) as f: for line in f: # 对读取的行都进行split操作,然后提取站点名和其代码 name = line.split(&apos;|&apos;)[1] # 站点名字 code = line.split(&apos;|&apos;)[2] # 每个站点对应的代码 # 每个站点肯定都是唯一的 name_code_dict[name] = code # 把name,code保存到本地文件中,方便以后使用 with open(file, &apos;w&apos;) as f: # 不以ascii码编码的方式保存 json.dump(name_code_dict, f, ensure_ascii=False) def query_ticket(self): &quot;&quot;&quot; 功能:查票操作 :return: 返回查询到的所有车次信息 &quot;&quot;&quot; data = self._query_prompt() if not data: print(&apos;query_ticket() error: &#123;&#125;&apos;.format(data)) _, from_station, to_station = data.keys() train_date = data.get(&apos;train_date&apos;) from_station_code = data.get(from_station) to_station_code = data.get(to_station) query_param = &apos;leftTicketDTO.train_date=&#123;&#125;&amp;&apos; \ &apos;leftTicketDTO.from_station=&#123;&#125;&amp;&apos; \ &apos;leftTicketDTO.to_station=&#123;&#125;&amp;&apos; \ &apos;purpose_codes=ADULT&apos;\ .format(train_date, from_station_code, to_station_code) url = &apos;https://kyfw.12306.cn/otn/leftTicket/query?&apos; full_url = url + query_param resp = self.session.get(full_url, headers=self.headers) if resp.status_code == 200 and resp.url == full_url: print(&apos;query_ticket() 成功!然后进行车票清理工作!&apos;) self._get_train_info(resp.json(), from_station, to_station) else: print(&apos;query_ticket() error! status_code:&#123;&#125;, url:&#123;&#125;\norigin_url:&#123;&#125;&apos; .format(resp.status_code, resp.url, full_url)) return self.station_info, train_date, from_station_code, to_station_code def _get_train_info(self, text, from_station, to_station): &quot;&quot;&quot; 功能:提取出查询到的列车信息 :param text: 包含所有从起点站到终点站的车次信息 :return: 返回所有车次信息 &quot;&quot;&quot; if not text: print(&apos;_query_train_info() error: text为:&apos;, text) # 把json文件转变成字典形式 result = dict(text) # 判断有无车次的标志 if result.get(&apos;data&apos;).get(&apos;map&apos;): train_info = result.get(&apos;data&apos;).get(&apos;result&apos;) train_list = deque() for item in train_info: split_item = item.split(&apos;|&apos;) item_dict = &#123;&#125; # for index, item in enumerate(split_item,0): # print(&apos;&#123;&#125;:\t&#123;&#125;&apos;.format(index, item)) if split_item[11] == &apos;Y&apos;: # 已经开始卖票了 item_dict[&apos;train_id&apos;] = split_item[0] item_dict[&apos;train_name&apos;] = split_item[3] # 车次名 item_dict[&apos;depart_time&apos;] = split_item[8] # 出发时间 item_dict[&apos;arrive_time&apos;] = split_item[9] # 到站时间 item_dict[&apos;spend_time&apos;] = split_item[10] # 经历时长 item_dict[&apos;wz&apos;] = split_item[29] # 无座 item_dict[&apos;yz&apos;] = split_item[28] # 硬座 item_dict[&apos;yw&apos;] = split_item[26] # 硬卧 item_dict[&apos;rw&apos;] = split_item[23] # 软卧 item_dict[&apos;td&apos;] = split_item[32] # 特等座 item_dict[&apos;yd&apos;] = split_item[31] # 一等座 item_dict[&apos;ed&apos;] = split_item[30] # 二等座 item_dict[&apos;dw&apos;] = split_item[33] # 动卧 train_list.append(item_dict) self.station_info.append(item_dict) # 无法买票的车次,有可能是已卖光,也有可能是还不开卖 elif split_item[0] == &apos;&apos;: print(&apos;_query_train_info():车次&#123;&#125;的票暂时不能购买!&apos; .format(split_item[3])) else: print(&apos;_query_train_info():车次&#123;&#125;还未开始卖票,起售时间为:&#123;&#125;&apos; .format(split_item[3], split_item[1])) # 调用方法来打印列车结果 self._print_train(train_list, from_station, to_station) else: print(&apos;_get_train_info() error: 从&#123;&#125;站到&#123;&#125;站有没列车!&apos; .format(from_station, to_station)) def _print_train(self, train_info, from_station, to_station): &quot;&quot;&quot; 功能:打印查询到的车次信息 :param train_info: 提取出来的车次信息 :return: &quot;&quot;&quot; if not train_info: print(&apos;_print_train() error: train_info是None!&apos;) return print(&apos;从&#123;&#125;到&#123;&#125;还有余票的列车有:&apos;.format(from_station, to_station)) for item in train_info: if &apos;G&apos; in item[&apos;train_name&apos;]: # 高铁 self._print_high_train_info(item) elif &apos;D&apos; in item[&apos;train_name&apos;]: # 动车 self._print_dong_train_info(item) else: self._print_train_info(item) def _print_high_train_info(self, item): &quot;&quot;&quot; 功能:打印高铁车次信息 :param item: 所有高铁车次 :return: &quot;&quot;&quot; print(&apos;车次:&#123;:4s&#125;\t起始时间:&#123;:4s&#125;\t到站时间:&#123;:4s&#125;\t&apos; &apos;经历时长:&#123;:4s&#125;\t特等座:&#123;:4s&#125;\t一等座:&#123;:4s&#125;\t二等座:&#123;:4s&#125;&apos; .format(item[&apos;train_name&apos;], item[&apos;depart_time&apos;],item[&apos;arrive_time&apos;], item[&apos;spend_time&apos;],item[&apos;td&apos;], item[&apos;yd&apos;], item[&apos;ed&apos;])) def _print_dong_train_info(self, item): &quot;&quot;&quot; 功能:打印动车的车票信息 :param item: 所有动车车次 :return: &quot;&quot;&quot; print(&apos;车次:&#123;:4s&#125;\t起始时间:&#123;:4s&#125;\t到站时间:&#123;:4s&#125;\t&apos; &apos;经历时长:&#123;:4s&#125;\t一等座:&#123;:4s&#125;\t二等座:&#123;:4s&#125;\t软卧:&#123;:4s&#125;\t动卧:&#123;:4s&#125;&apos; .format(item[&apos;train_name&apos;], item[&apos;depart_time&apos;], item[&apos;arrive_time&apos;], item[&apos;spend_time&apos;],item[&apos;yd&apos;],item[&apos;ed&apos;], item[&apos;rw&apos;], item[&apos;dw&apos;])) def _print_train_info(self,item): &quot;&quot;&quot; 功能:打印普通列出的车次信息 :param item: 所有普通车次 :return: &quot;&quot;&quot; print(&apos;车次:&#123;:4s&#125;\t起始时间:&#123;:4s&#125;\t到站时间:&#123;:4s&#125;\t经历时长:&#123;:4s&#125;\t&apos; &apos;软卧:&#123;:4s&#125;\t硬卧:&#123;:4s&#125;\t硬座:&#123;:4s&#125;\t无座:&#123;:4s&#125;&apos; .format(item[&apos;train_name&apos;], item[&apos;depart_time&apos;], item[&apos;arrive_time&apos;], item[&apos;spend_time&apos;],item[&apos;rw&apos;], item[&apos;yw&apos;], item[&apos;yz&apos;], item[&apos;wz&apos;])) def _query_prompt(self): &quot;&quot;&quot; 功能: 与用户交互,让用户输入:出发日期,起始站和终点站并判断其正确性 :return: 返回正确的日期,起始站和终点站 &quot;&quot;&quot; time_flag, train_date = self._check_date() if not time_flag: print(&apos;_query_prompt() error:&apos;, &apos;乘车日期不合理,请检查!!&apos;) return # 创建有序字典,方便取值 query_data = OrderedDict() from_station = input(&apos;请输入起始站:&apos;) to_station = input(&apos;请输入终点站:&apos;) station_flag = True filename = &apos;name_code.json&apos; with open(filename, &apos;r&apos;) as f: data = dict(json.load(f)) stations = data.keys() if from_station not in stations or to_station not in stations: station_flag = False print(&apos;query_prompt() error: &#123;&#125;或&#123;&#125;不在站点列表中!!&apos; .format(from_station, to_station)) # 获取起始站和终点站的代码 from_station_code = data.get(from_station) to_station_code = data.get(to_station) query_data[&apos;train_date&apos;] = train_date query_data[from_station] = from_station_code query_data[to_station] = to_station_code if time_flag and station_flag: return query_data else: print(&apos;query_prompt() error! time_flag:&#123;&#125;, station_flag:&#123;&#125;&apos; .format(time_flag, station_flag)) def _check_date(self): &quot;&quot;&quot; 功能:检测乘车日期的正确性 :return: 返回时间是否为标准的形式的标志 &quot;&quot;&quot; # 获取当前时间的时间戳 local_time = time.localtime() local_date = &apos;&#123;&#125;-&#123;&#125;-&#123;&#125;&apos;.\ format(local_time.tm_year, local_time.tm_mon, local_time.tm_mday) curr_time_array = time.strptime(local_date, &apos;%Y-%m-%d&apos;) curr_time_stamp = time.mktime(curr_time_array) # 获取当前时间 curr_time = time.strftime(&apos;%Y-%m-%d&apos;, time.localtime(curr_time_stamp)) # 计算出预售时长的时间戳 delta_time_stamp = &apos;2505600&apos; # 算出预售票的截止日期时间戳 dead_time_stamp = int(curr_time_stamp) + int(delta_time_stamp) dead_time = time.strftime(&apos;%Y-%m-%d&apos;, time.localtime(dead_time_stamp)) print(&apos;合理的乘车日期范围是:(&#123;&#125;)~(&#123;&#125;)&apos;.format(curr_time, dead_time)) train_date = input(&apos;请输入乘坐日期(year-month-day):&apos;) # 把乘车日期转换成时间戳来比较 # 先生成一个时间数组 time_array = time.strptime(train_date, &apos;%Y-%m-%d&apos;) # 把时间数组转化成时间戳 train_date_stamp = time.mktime(time_array) # 获取标准的乘车日期 train_date_time = time.strftime(&apos;%Y-%m-%d&apos;, time.localtime(train_date_stamp)) # 做上面几步主要是把用户输入的时间格式转变成标准的格式 # 如用户输入:2018-2-22,那么形成的查票URL就不是正确的 # 只有是: 2018-02-22,组合的URL才是正确的! # 通过时间戳来比较时间的正确性 if int(train_date_stamp) &gt;= int(curr_time_stamp) and \ int(train_date_stamp) &lt;= dead_time_stamp: return True, train_date_time else: print(&apos;_check_date() error: 乘车日期:&#123;&#125;, 当前系统时间:&#123;&#125;, 预售时长为:&#123;&#125;&apos; .format(train_date_time, curr_time, dead_time)) return False, Nonedef main(): filename = &apos;station_name.txt&apos; station = Station() station.station_name_code() station.save_station_code(filename) station.query_ticket()if __name__ == &apos;__main__&apos;: main() 5.coordinate.py(验证码坐标 1234567891011121314def coor(): arr = [[],[&apos;45&apos;,&apos;45&apos;],[&apos;110&apos;,&apos;45&apos;],[&apos;175&apos;,&apos;45&apos;],[&apos;240&apos;,&apos;45&apos;], [&apos;45&apos;,&apos;110&apos;],[&apos;110&apos;,&apos;110&apos;],[&apos;175&apos;,&apos;110&apos;],[&apos;240&apos;,&apos;110&apos;]] cnt = input(&apos;请输入验证码坐标，以,隔开\n&apos;) Str = [] for i in cnt: if i == &apos;,&apos;: continue else: Str = Str + arr[int(i)] return &apos;,&apos;.join(Str) 6.buy.py 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238import requestsimport chardetimport urllib.parseimport settingsfrom login import Loginfrom stations import Stationimport reimport timeimport datetimeimport stationsclass Buy: def __init__(self): # 使用登录时候的session,这样好一些! self.headers = settings.headers self.session = settings.session def checkUser(self): &quot;&quot;&quot; 功能:验证登录 :return: 无 &quot;&quot;&quot; url = &apos;https://kyfw.12306.cn/otn/login/checkUser&apos; data = &#123; &apos;_json_att&apos;: &apos;&apos;, &#125; resp = self.session.post(url, data=data, headers=self.headers) result = resp.json() checkUser_flag = result[&apos;status&apos;] if checkUser_flag == True: print(&apos;验证登录成功！&apos;) def get_secretStr(self, station_info): &quot;&quot;&quot; 功能:返回高铁车次信息 :param item: 单车次信息 :return: &quot;&quot;&quot; val = str(input(&apos;请输入订票的车次:&apos;)) for item in station_info: if item[&apos;train_name&apos;] == val: return item[&apos;train_id&apos;] def submitOrderRequest(self, station_info): url = &apos;https://kyfw.12306.cn/otn/leftTicket/submitOrderRequest&apos; cnt = self.get_secretStr(station_info) Str = urllib.parse.unquote(cnt) # 获取当前时间的时间戳 local_time = time.localtime() local_date = &apos;&#123;&#125;-&#123;&#125;-&#123;&#125;&apos;.\ format(local_time.tm_year, local_time.tm_mon, local_time.tm_mday) curr_time_array = time.strptime(local_date, &apos;%Y-%m-%d&apos;) curr_time_stamp = time.mktime(curr_time_array) # 获取当前时间 curr_time = time.strftime(&apos;%Y-%m-%d&apos;, time.localtime(curr_time_stamp)) train_date = input(&apos;请再次确认乘坐日期(year-month-day):&apos;) query_from_station_name = input(&apos;请再次输入起始站:&apos;) query_to_station_name = input(&apos;请再次输入终点站:&apos;) data = &#123; &apos;secretStr&apos;: Str, &apos;train_date&apos;: train_date, &apos;back_train_date&apos;: curr_time, &apos;tour_flag&apos;: &apos;dc&apos;, &apos;purpose_codes&apos;: &apos;ADULT&apos;, &apos;query_from_station_name&apos;: query_from_station_name, &apos;query_to_station_name&apos;: query_to_station_name, &apos;undefined&apos;: &apos;&apos;, &#125; resp = self.session.post(url, data=data, headers=self.headers) if resp.status_code == 200: print(&apos;submitOrderRequest成功！&apos;) else: print(&apos;submitOrderRequest() error! status_code:&#123;&#125;, url:&#123;&#125;&apos;. format(resp.status_code, resp.url)) def initDc(self): &quot;&quot;&quot; 功能:请求提交购票人信息和选择购票坐票或者卧铺类型页面 :return: 无 &quot;&quot;&quot; url = &apos;https://kyfw.12306.cn/otn/confirmPassenger/initDc&apos; data = &#123; &apos;_json_att&apos;: &apos;&apos;, &#125; resp = self.session.post(url, data=data, headers=self.headers) #设置网页编码 if chardet.detect(resp.content).get(&apos;encoding&apos;) != &apos;UTF-8&apos;: resp.encoding = &apos;UTF-8&apos; match = re.search(&quot;var globalRepeatSubmitToken = &apos;(.*?)&apos;;&quot;, resp.text) ticketToken = match.group(1) people_url = &apos;https://kyfw.12306.cn/otn/confirmPassenger/getPassengerDTOs&apos; people_resp = self.session.post(people_url, data=&#123;&quot;REPEAT_SUBMIT_TOKEN&quot;:ticketToken,&quot;_json_att&quot;:&quot;&quot;&#125;, headers=self.headers) people_json = people_resp.json() result = dict(people_json) info = result[&apos;data&apos;][&apos;normal_passengers&apos;][1] train_no = re.search(&quot;&apos;train_no&apos;:&apos;(.*?)&apos;&quot;, resp.text).group(1) leftTicket = re.search(&quot;&apos;ypInfoDetail&apos;:&apos;(.*?)&apos;&quot;, resp.text).group(1) purpose_codes = re.search(&quot;&apos;purpose_codes&apos;:&apos;(.*?)&apos;&quot;, resp.text).group(1) station_train_code = re.search(&quot;&apos;station_train_code&apos;:&apos;(.*?)&apos;&quot;, resp.text).group(1) to_station_telecode = re.search(&quot;&apos;to_station_telecode&apos;:&apos;(.*?)&apos;&quot;, resp.text).group(1) train_location = re.search(&quot;&apos;train_location&apos;:&apos;(.*?)&apos;&quot;, resp.text).group(1) key_check_isChange = re.search(&quot;&apos;key_check_isChange&apos;:&apos;(.*?)&apos;&quot;, resp.text).group(1) return info, ticketToken, train_no, leftTicket, purpose_codes, station_train_code, to_station_telecode, train_location, key_check_isChange def checkOrderInfo(self, info, ticketToken): url = &apos;https://kyfw.12306.cn/otn/confirmPassenger/checkOrderInfo&apos; passengerTicketStr = &apos;O,0,1,&apos; + info[&apos;passenger_name&apos;] + &apos;,1,&apos; + info[&apos;passenger_id_no&apos;] + &apos;,&apos; + info[&apos;mobile_no&apos;] + &apos;,N&apos; oldPassengerStr = info[&apos;passenger_name&apos;] + &apos;,1,&apos; + info[&apos;passenger_id_no&apos;] + &apos;,1_&apos; data = &#123; &apos;cancel_flag&apos;: &apos;2&apos;, &apos;bed_level_order_num&apos;: &apos;000000000000000000000000000000&apos;, &apos;passengerTicketStr&apos;: passengerTicketStr, &apos;oldPassengerStr&apos;: oldPassengerStr,# &apos;tour_flag&apos;: &apos;dc&apos;, &apos;randCode&apos;: &apos;&apos;, &apos;whatsSelect&apos;: &apos;1&apos;, &apos;_json_att&apos;: &apos;&apos;, &apos;REPEAT_SUBMIT_TOKEN&apos;: ticketToken,# &#125; resp = self.session.post(url, data=data, headers=self.headers) result = dict(resp.json()) if result[&apos;data&apos;][&apos;submitStatus&apos;] == True: print(&apos;checkOrderInfo成功！&apos;) else: print(&apos;checkOrderInfo失败！&apos;) return passengerTicketStr, oldPassengerStr def getQueueCount(self, trainDate, train_no, leftTicket, ticketToken, station_train_code, fromStationTelecode, to_station_telecode, purpose_codes, train_location, passengerTicketStr, oldPassengerStr, key_check_isChange): url = &apos;https://kyfw.12306.cn/otn/confirmPassenger/getQueueCount&apos; data = &#123; &apos;train_date&apos;: datetime.datetime.fromtimestamp(time.mktime(time.strptime(trainDate, &apos;%Y-%m-%d&apos;))).strftime(&apos;%a %b %d %Y %H:%M:%S GMT+0800&apos;), &apos;train_no&apos;: train_no, &apos;stationTrainCode&apos;: station_train_code, &apos;seatType&apos;: &apos;O&apos;, &apos;fromStationTelecode&apos;: fromStationTelecode, &apos;toStationTelecode&apos;: to_station_telecode, &apos;leftTicket&apos;: leftTicket, &apos;purpose_codes&apos;: purpose_codes, &apos;train_location&apos;: train_location, &apos;_json_att&apos;: &apos;&apos;, &apos;REPEAT_SUBMIT_TOKEN&apos;: ticketToken, &#125; resp = self.session.post(url, data=data, headers=self.headers) queueCountJson = resp.json() if queueCountJson.get(&quot;status&quot;) == False or queueCountJson.get(&quot;httpstatus&quot;) != 200: raise Exception(&quot;获取队列错误&quot;) url = &apos;https://kyfw.12306.cn/otn/confirmPassenger/confirmSingleForQueue&apos; data = &#123; &apos;passengerTicketStr&apos;: passengerTicketStr, &apos;oldPassengerStr&apos;: oldPassengerStr, &apos;randCode&apos;: &apos;&apos;, &apos;purpose_codes&apos;: purpose_codes, &apos;key_check_isChange&apos;: key_check_isChange, &apos;leftTicketStr&apos;: leftTicket, &apos;train_location&apos;: train_location, &apos;choose_seats&apos;: &apos;&apos;, &apos;seatDetailType&apos;: &apos;000&apos;, &apos;whatsSelect&apos;: &apos;1&apos;, &apos;roomType&apos;: &apos;00&apos;, &apos;dwAll&apos;: &apos;N&apos;, &apos;_json_att&apos;: &apos;&apos;, &apos;REPEAT_SUBMIT_TOKEN&apos;: ticketToken, &#125; singleForQueueReq = self.session.post(url, data=data, headers=self.headers) singleForQueueJson = singleForQueueReq.json() print(singleForQueueJson) def queryOrderWaitTime(self, ticketToken): url = &apos;https://kyfw.12306.cn/otn/confirmPassenger/queryOrderWaitTime&apos; data = &#123; &apos;random&apos;: time.time(), &apos;tourFlag&apos;: &apos;dc&apos;, &apos;_json_att&apos;: &apos;&apos;, &apos;REPEAT_SUBMIT_TOKEN&apos;: ticketToken, &#125; resp = self.session.post(url, data=data, headers=self.headers) orderWaitJson = resp.json() orderId = orderWaitJson.get(&quot;data&quot;).get(&quot;orderId&quot;)#此处有问题 print(orderWaitJson) print(orderId) url = &apos;https://kyfw.12306.cn/otn/confirmPassenger/resultOrderForDcQueue&apos; data = &#123; &apos;orderSequence_no&apos;: orderId, &apos;_json_att&apos;: &apos;&apos;, &apos;REPEAT_SUBMIT_TOKEN&apos;: ticketToken, &#125; dcQueueReq = self.session.post(url, data=data, headers=self.headers) dcQueueJson = dcQueueReq.json() if dcQueueJson.get(&quot;status&quot;) and dcQueueJson.get(&quot;httpstatus&quot;) == 200 and dcQueueJson.get( &quot;data&quot;) is not None and dcQueueJson.get(&quot;data&quot;).get(&quot;submitStatus&quot;): print(&quot;订票成功&quot;) else: print(dcQueueJson) print(&quot;订票失败&quot;)def start(): login = Login() login.down_captcha() check_flag = login.captcha_check() login_flag = login.login(check_flag) if login_flag: newapptk = login.auth_uamtk(login_flag) username = login.uamatuth_client(newapptk) login.init_my_12306(username) else: print(&apos;main():login_flag为Flase&apos;)def query(): filename = &apos;station_name.txt&apos; station = Station() station.station_name_code() station.save_station_code(filename) station_info, train_date, from_station_code, to_station_code = station.query_ticket() return station_info, train_date, from_station_code, to_station_codedef shop(station_info, trainDate, fromStationTelecode, to_station_telecode): buy = Buy() buy.checkUser() buy.submitOrderRequest(station_info) info, ticketToken, train_no, leftTicket, purpose_codes, station_train_code, to_station_telecode, train_location, key_check_isChange = buy.initDc() passengerTicketStr, oldPassengerStr = buy.checkOrderInfo(info, ticketToken) buy.getQueueCount(trainDate, train_no, leftTicket, ticketToken, station_train_code, fromStationTelecode, to_station_telecode, purpose_codes, train_location, passengerTicketStr, oldPassengerStr, key_check_isChange) buy.queryOrderWaitTime(ticketToken)def main(): start() station_info, train_date, from_station_code, to_station_code = query() shop(station_info, train_date, from_station_code, to_station_code)if __name__ == &apos;__main__&apos;: main()]]></content>
      <categories>
        <category>爬虫</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>爬虫</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[初学爬虫]]></title>
    <url>%2F2018%2F04%2F16%2F%E5%88%9D%E5%AD%A6%E7%88%AC%E8%99%AB%2F</url>
    <content type="text"><![CDATA[今天作为例子的网站：http://www.xiaohua100.cn/daxue/啊哈，这个也是无意间找的网站，不是故意找的（大雾）（作为例子来说还是挺好的例子…个人理解的爬虫分为以下几步：1.获取网站url2.搞清楚是get请求还是post请求3.request或者session访问后，注意编码格式4.正则表达式或者用匹配出信息5.是否要从访问之后的返回信息得出data以及下个网站url 那么今天的例子：1.首先我们很清楚url = ‘http://www.xiaohua100.cn/daxue/&#39;2.这个网站由get请求访问3.我们今天的目的是寻找这些图片并进行下载，那么我们要做的是找到图片的url4.然后通过正则表达式储存这些url到一个列表里面5.通过requests.content 二进制下载这些图片即可 代码如下：123456789101112131415161718192021import requestsimport reurl = &apos;http://www.xiaohua100.cn/daxue/&apos;response = requests.get(url)response.encoding = &apos;utf-8&apos;html = response.textmain_url = &apos;http://www.xiaohua100.cn&apos;img_urls = re.findall(r&apos;/uploads/allimg/\d+/\d-\w+-\w+.jpg&apos;, html)for i in range(len(img_urls)): img_urls[i] = main_url + img_urls[i]index = 0for img_url in img_urls: img_data = requests.get(img_url).content filename = str(index) + &apos;.jpg&apos; with open(filename, &apos;wb&apos;) as f: f.write(img_data) print(img_url) index += 1]]></content>
      <categories>
        <category>爬虫</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>爬虫</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[爬UbuntuPaste代码]]></title>
    <url>%2F2018%2F04%2F16%2F%E7%88%ACUbuntuPaste%E4%BB%A3%E7%A0%81%2F</url>
    <content type="text"><![CDATA[直接贴代码啦。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061# -*- coding:utf-8 -*-import urllib.requestimport reimport osclass UbtSpider: def __init__(self) : self.pageIndex = 25317600 self.user_agent = &apos;Mozilla/4.0 (compatible; MSIE 5.5; Windows NT)&apos; def getPage(self,pageIndex): url = &apos;http://paste.ubuntu.com/&apos; + str(pageIndex) headers = &#123;&apos;User-Agent&apos;: self.user_agent, &apos;Referer&apos;: url&#125; request = urllib.request.Request(url, headers=headers) with urllib.request.urlopen(request) as response: html = response.read() content = html.decode(&apos;utf-8&apos;) patten = re.compile(&apos;&lt;div class=&quot;paste&quot;&gt;&lt;pre&gt;(.*?)&lt;/pre&gt;&lt;/div&gt;&apos;, re.S) # re.S (.*?）表示分组 items = patten.findall(content) for item in items: #替换 item = item.replace(&apos;&amp;nbsp;&apos;, &apos; &apos;) item = item.replace(&apos;&amp;gt;&apos;, &apos;&gt;&apos;) item = item.replace(&apos;&amp;lt;&apos;, &apos;&lt;&apos;) item = item.replace(&apos;&amp;quot;&apos;, &apos;&quot;&apos;) item = item.replace(&apos;&amp;amp;&apos;, &apos;&amp;&apos;) item = item.replace(&apos;&amp;#39;&apos;, &apos;\&apos;&apos;) item = re.sub(&apos;&lt;span.*?&gt;&apos;,&apos;&apos;,item) item = re.sub(&apos;&lt;/span&gt;&apos;, &apos;&apos;, item) # print(item) patten2 = re.compile(&quot;.*include&quot;, re.S) if (patten2.match(item)): fileName = str(pageIndex) + &apos;.txt&apos; print( u&quot;正在写入: &gt;&gt;&gt; &quot; + str(pageIndex)) isSuccess = True with open(fileName,&apos;w&apos;) as f: try: f.write(item) except UnicodeError as e: if hasattr(e,&quot;reason&quot;): print (str(pageIndex)+u&quot; 写入失败,原因: &quot; + e.reason) isSuccess = False f.close() try:os.remove(fileName) except Exception as ose: print(str(pageIndex)+u&quot; 删除失败&quot; ) if isSuccess: print(str(pageIndex) + u&quot; 写入成功!&quot; ) f.close() def start(self): start = 25545700 end = 25545692 start = input(&quot;请输入起始页码: &quot;) end = input(&quot;请输入结束页码: &quot;) print(u&quot;开始爬取 UbuntuPaste 代码 ........&quot;) for pageIndex in range(int(start),int(end)): # 起始范围 self.getPage(pageIndex)spider = UbtSpider()spider.start()]]></content>
      <categories>
        <category>爬虫</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>爬虫</tag>
      </tags>
  </entry>
</search>
