<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[内核原子变量的说明和使用]]></title>
    <url>%2F2020%2F11%2F17%2F%E5%86%85%E6%A0%B8%E5%8E%9F%E5%AD%90%E5%8F%98%E9%87%8F%E7%9A%84%E8%AF%B4%E6%98%8E%E5%92%8C%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[static atomic_t can_open = ATOMIC_INIT(1); atomic_dec_and_test 先减一，如果结果是0返回true，否则返回false。 第一次可以打开，第二次进入if。 atomic_inc 再加一，不会被打断。 原子的加法分三步，最底层调用汇编代码。]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[semaphore内核源码的实现]]></title>
    <url>%2F2020%2F11%2F15%2Fsemaphore%E5%86%85%E6%A0%B8%E6%BA%90%E7%A0%81%E7%9A%84%E5%AE%9E%E7%8E%B0%2F</url>
    <content type="text"><![CDATA[首先down 是获取锁，如果获取到可以独占临界区资源执行下面语句，如果获取不到不断轮询去获取。 第一个进程只是把count–，而第二个进程才会去__down函数里 current 当前进程，把等待在信号量上的task加入waiter结构体里。 (如果有信号打断goto interrupted) 自旋锁的开销非常大，尽可能尽量少的代码在自旋锁的粒度里，所以才会有外面加锁，里面解锁又加锁。schedule_timeout会睡眠，所以没办法放进自旋锁的保护区里，当到进程二唤醒的时候接着加锁，waiter.up == true 返回 同理。进程count++，如果wait_list空，那么调用__up函数 从刚才的容器里拿出来waiter， waiter-&gt;up = true]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[用户态协议栈TCPIP]]></title>
    <url>%2F2020%2F11%2F15%2F%E7%94%A8%E6%88%B7%E6%80%81%E5%8D%8F%E8%AE%AE%E6%A0%88TCPIP%2F</url>
    <content type="text"><![CDATA[网卡是属于协议栈哪一层网卡不属于任何一层。物理层传输的是：光电信号数据链路层对应：数字信号 网卡作用：将光电信号转化成数字信号，数字信号转化为光电信号。 利用 netmap 实现协议栈123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133#include &lt;stdio.h&gt;#include &lt;sys/poll.h&gt;#define NETMAP_WITH_LIBS#include &lt;net/netmap_user.h&gt;#pragma pack(1)#define PROTO_IP 0x0800#define PROTO_UDP 17#define ETH_LEN 6struct ethhdr &#123; unsigned char h_dest[ETH_LEN]; //mac unsigned char h_src[ETH_LEN]; unsigned short h_proto;&#125;;// sizeof(struct ethhdr) == 14struct iphdr &#123; unsigned char version:4, hdrlen:4; unsigned char tos; // unsigned short length; unsigned short id; unsigned short flag:3, offset:13; unsigned char ttl; unsigned char proto; unsigned short check; unsigned int sip; unsigned int dip;&#125;;// sizeof(struct ip) == 20struct udphdr &#123; unsigned short sport; unsigned short dport; unsigned short length; unsigned short check;&#125;;// sizeof(udphdr) 8struct udppkt &#123; struct ethhdr eh; // 14 struct iphdr ip; // 20 struct udphdr udp; // 8 unsigned char body[0]; // sizeof(body)=0; &#125;;// sizeof(udppkt) = 44// sizeof()// f-stack// dpdk + bsd // netmap , dpdk, raw_socket// netmap:eth0// eth0int main() &#123; // eth0 --&gt; ens33 struct nm_desc *nmr = nm_open(&quot;netmap:eth0&quot;, NULL, 0, NULL); if (nmr == NULL) &#123; return -1; &#125; struct pollfd pfd = &#123;0&#125;; pfd.fd = nmr-&gt;fd; // pfd.events = POLLIN;// select/poll or epoll// poll --&gt; select while (1) &#123; int ret = poll(&amp;pfd, 1, -1); if (ret &lt; 0) continue; if (pfd.revents &amp; POLLIN) &#123; struct nm_pkthdr h; unsigned char *stream = nm_nextpkt(nmr, &amp;h); // read struct ethhdr *eh = (struct ethhdr*)stream; // 0x0800 if (ntohs(eh-&gt;h_proto) == PROTO_IP) &#123; struct udppkt *udp = (struct udppkt *)stream; if (udp-&gt;ip.proto == PROTO_UDP) &#123; // int udp_length = ntohs(udp-&gt;udp.length); udp-&gt;body[udp_length-8] = &apos;\0&apos;; printf(&quot;udp --&gt; %s\n&quot;, udp-&gt;body); &#125; &#125; &#125; &#125; return 0;&#125; 为什么一会儿就不能接受发送到这个端口的数据了因为arp过期了，icmp 会ping 对端，但是这个程序没有一直ping对端，导致arp过期。 不能再找到主机的MAC地址，所以发送不过去了。 fd端口只有65535，为什么并发能做到上百万fd –&gt; 五元组(sip,dip,sport,dport,proto) send(fd)的时候，fd 通过五元组判断客户端的唯一性 三次握手 syn 队列 accept队列满时，会造成真正要连接的fd阻塞。只能加外网防火墙拦截。 滑动窗口 如果接收到ACK，那么说明从这个包之前的包都已经成功接受到，可以往后滑动，发送新的包。对端ACK应答把窗口大小带上。 快速重传当接收端收到比期望序号大的报文段时，便会重复发送最近一次确认的报文段的确认信号，我们称之为冗余ACK。报文段1成功接收并被确认ACK 2，接收端的期待序号为2，当报文段2丢失，报文段3失序到来，与接收端的期望不匹配，接收端重复发送冗余ACK 2。 拥塞控制滑动窗口可以是动态控制大小的。跟rtt有关系。 rtt = 0.9 oldrtt + 0.1 newrtt 而cwnd 由慢启动 cwnd = cwnd * 2 再到拥塞控制 1/2这个过程逐步趋于一个平稳值。 为什么会用udp做可靠传输 下载的时候，TCP可以限制包数量，但是UDP不行。 游戏打团得实时，TCP要保持有序，卡了怎么办，所以可以牺牲效率保证实时。 四次挥手 为什么四次挥手是四次因为对端都需要对方的确认，就像男女朋友，A提出分手，B先接受这个消息，表示我知道你要分手了。但是还需要一点时间消化，同意了再告诉A，我同意了。而且A提出分手的时候，B还有一些数据还在传，传完了之后再告诉A断开联系。所以必须是四次 为什么还有fin_wait2状态因为还要收B的数据 time_wait作用害怕最后一次ACK丢失，发送fin的时候有定时器，如果最后一次ACK可能丢失，如果在LAST_ACK状态的B收不到这个ACK的确认。B会超时重传FIN，所以time_wait是2MSL.A就能在这个时间内再次发送ACK确认，重新启动2MSL的计时器。并且有效防止了旧ACK的出现影响连接。下一个新的连接不会再出现这种旧的连接请求报文段。 出现大量close_wait状态因为B端 recv() 没有调用close() 或者时机不对 如图，ACK丢失会怎样A先收到FIN就出现closing状态，再收到ACK变为time_wait状态。 中间ACK和FIN同时调用出现A也发送关闭FIN，B也同时发送FIN，那么两边都会成为closing状态，各自收到ACK变成time_wait状态，四次挥手就变成了三次 time_wait状态太多等待时间过长 tcp与epoll的触发]]></content>
      <categories>
        <category>基础</category>
      </categories>
      <tags>
        <tag>TCP/IP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[redis理解]]></title>
    <url>%2F2020%2F11%2F11%2Fredis%E7%90%86%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[redis的Hash如何解决冲突链表法 123456typedef struct dictht &#123; dictEntry **table; unsigned long size; unsigned long sizemask; unsigned long used;&#125; dictht; table 属性是⼀个数组，数组中的每个元素都是⼀个指向 dict.h/dictEntry 结构的指针，每个dictEntry 结构保存着⼀个键值对；size 属性记录了哈希表的⼤⼩,也即是 table 数组的⼤⼩，⽽ used 属性则记录了哈希表⽬前已有节点（键值对）的数量；sizemask 属性的值总是等于 size - 1 ，这个属性和哈希值⼀起决定⼀个键应该被放到 table 数组的哪个索引上⾯；used属性，表示hash表⾥已有的数量。如下图展示了⼀个空的hash表： hash表的节点哈希表节点使⽤ dictEntry 结构表示， 每个 dictEntry 结构都保存着⼀个键值对 123456789101112131415typedef struct dictEntry &#123; // 键 void *key; // 值 union &#123; void *val; uint64_t u64; int64_t s64; double d; &#125; v; // 指向下个哈希表节点，形成链表 struct dictEntry *next;&#125; dictEntry; 举个例⼦，下图就展示了如何通过 next 指针，将两个索引值相同的键 k1 和 k0 连接在⼀起。 hash表是随着K-V数量的增⼤⽽逐步增⼤的，并不直接以key的hash值为下标去取值得，⽽是以hash &amp; sizemask去获取hash表的对应节点的；hash表的节点实际上是⼀个链表，如果hash &amp;sizemask有冲突，则也把冲突key放在hash表的链表上，取值得时候还得遍历hash表⾥的链表。 rehash随着操作的不断执⾏，哈希表保存的键值对会逐渐地增多或者减少，为了让哈希表的负载因⼦（ratio）维持在⼀个合理的范围之内，当哈希表保存的键值对数量太多或者太少时，程序需要对哈希表的⼤⼩进⾏相应的扩展或者收缩。 扩容的步骤如下：1、为字典ht[1]哈希表分配合适的空间；2、将ht[0]中所有的键值对rehash到ht[1]：rehash 指的是重新计算键的哈希值和索引值，然后将键值对放置到 ht[1] 哈希表的指定位置上；3、当 ht[0] 包含的所有键值对都迁移到了 ht[1] 之后（ht[0] 变为空表） 释放 ht[0] ，将 ht[1] 设置为 ht[0] ，并在 ht[1] 新创建⼀个空⽩哈希表，为下⼀次 rehash 做准备。 当然rehash指渐进式hash，如果在服务器运作直接扩容，那么会影响服务器性能。以下是哈希表渐进式 rehash 的详细步骤： 为 ht[1] 分配空间，让字典同时持有 ht[0] 和 ht[1] 两个哈希表。 在字典中维持⼀个索引计数器变量 rehashidx ，并将它的值设置0 ， 表示 rehash ⼯作正式开始。 在 rehash 进⾏期间，每次对字典执⾏添加、删除、查找或者更新操作时，程序除了执⾏指定的操作以外，还会顺带将 ht[0] 哈希表rehashidx 索引上的所有键值对 rehash 到 ht[1] ，当 rehash ⼯作完成之后，程序将 rehashidx 属性的值增⼀。 随着字典操作的不断执⾏，最终在某个时间点上 ht[0] 的所有键对都会被 rehash ⾄ ht[1] ，这时程序将 rehashidx 属性的值设为 -1 ， 表示 rehash 操作已完成。 插曲： keys hkeys 枚举形式，是通过高位加1的方式进行next，这样的好处是让每次扩缩容，前面的for不用再进行遍历。 跳表跳表与红黑树区别：1) 结构的区别： 多层有序链表，二叉树2）搜索的区别： 大概率的o(logn)3) 功能性的区别： o(logn) zrange logn * o(logn) 主从复制2.8版本以前的方案：全量同步1.master 持久化，之后的命令写入缓冲区，发送rdb2.slave接受rdb，加载至内存3.master 发送缓冲区的命令，slave依次处理 下面三种情况如何保证效率问题：a.新加入从结点 b.主从连接故障 c.从结点重启 其实如果是b情况，只需要将少量写操作同步给从数据库就行了于是引入2.8版本 2.8版本1.记录偏移量 psync2.主master运行id 之后版本rdb保存运行id以及offset主切换 从需要记录之前运行id以及偏移量]]></content>
      <categories>
        <category>redis</category>
      </categories>
      <tags>
        <tag>redis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[x86段页式内存管理和页表映射机制]]></title>
    <url>%2F2020%2F11%2F11%2Fx86%E6%AE%B5%E9%A1%B5%E5%BC%8F%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E5%92%8C%E9%A1%B5%E8%A1%A8%E6%98%A0%E5%B0%84%E6%9C%BA%E5%88%B6%2F</url>
    <content type="text"><![CDATA[页表映射如图二级页表： 简单来说CPU在页表映射的时候，Dir 代表页目录表的索引，Offset是偏移，Table是页表的索引。 先定位页表地址，通过Table定位到物理块地址，再加上offset得到真正的物理地址。 内核用一个页目录表，但不同进程有各自的页目录表。 逻辑地址到物理地址的转换从虚拟地址段页式的转化转化成线性地址，再线性地址页表映射转化成物理地址。]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[内核空间和用户空间]]></title>
    <url>%2F2020%2F11%2F10%2F%E5%86%85%E6%A0%B8%E7%A9%BA%E9%97%B4%E5%92%8C%E7%94%A8%E6%88%B7%E7%A9%BA%E9%97%B4%2F</url>
    <content type="text"><![CDATA[内核空间与用户空间拷贝的时候，需要在用户空间找到物理地址，再拷贝到内核空间的物理地址中。如果物理地址刚好在一张页上，那么可以一次完成拷贝；但如果物理地址跨页，那么会进行跨页的拷贝，性能有所降低；再者，如果在内存中没有找到，那么会引发缺页中断，去对应磁盘地址上拷贝，性能会更低。]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[skynet]]></title>
    <url>%2F2020%2F11%2F08%2Fskynet%2F</url>
    <content type="text"><![CDATA[多核开发与actor模型 多进程 a) 消息队列 i. 协议问题 ii. 断线重连 iii. 进程启动顺序问题 iv. 负载均衡问题 v. 数据同步问题 b) RPC i. 两个系统保持同步问题 c) zk i. 配置项管理问题 ii. 集群管理 iii. 统一命名问题 iv. 状态同步问题 v. 分布式锁问题 d) 拆分 i. 功能拆分 ii. 热点拆分 多线程 并发模型：CSP 模型 与 actor 模型 结论：多进程并发实体是进程，多线程并发实体是线程，go 并发实体是 goroutine（协程），actor 并发实体是 actor（语言层面抽象出来的“进程”）。它们都是在隔离性（运行环境）与统一性（数据统一）之间作取舍平衡，而 actor 模型在语言层面做运行环境的隔离，数据同步依然需要通过消息来同步。actor 模型是加强版的多进程解决方案，进程间通信由socket 转为指针的传递，从而通信变得更加可靠，同时多进程解决方案中，公共开源组件（消息队列，rpc，zookeeper）解决的问题，在 actor 模型中处理起来更方便。 actor 定义： a) 用于并行计算 b) actor 是最基本的计算单元 c) 基于消息计算 d) actor 之间通过消息沟通并且相互隔离 skynet中的actor模型 结构组成 a) 隔离的环境（内存块或 lua 虚拟机） b) 消息队列 c) 回调函数 实现 a) logger 服务 service-src/service_logger.c b) lua 服务启动器 service-src/service_snlua.c actor运行以及消息调度 消息队列 a) 全局消息队列 b) actor 消息队列 skynet 中锁的使用 a) 互斥锁 {% asset_img 2.png %} b) 自旋锁 worker 轮询消息队列 {% asset_img 3.png %} c) 读写锁 handle_storage d) 条件变量 worker 线程的休眠 skynet 中线程 a) timer b) socket c) workeri. “权重”来定制消费消息的数量（-1 消费一个，0 全部消费，1 消费一半） ii. 休眠（条件变量）与唤醒（timer 和 socket） d) monitor i. 检查服务消息过载 skynet网络层actor 需要网络事件绑定？1.connetfd 跟 redis 接受redis的数据2.clientfd3.listenfd clientfd = accept(); skynet作为客户端连接其他服务fd4.管道fd 管道读端 work 线程往管道写端写数据 socket线程在管道读端读数据 worker在发送数据的时候 try_spinlock() 拿到锁，直接在worker线程将数据发送出去，其他情况在socket线程 阻塞IO与非阻塞IO的区别 阻塞网络线程 在于没有数据到达的时候是否立刻返回 fnctl fd noblock(recv/send read/write)决定了IO是否阻塞 read(fd,buf,sz)recv(fd,buf,sz,0) lua 与 c 接口编程 元表 a) 定制行为 index, newindex b) 只有 table 和 userdata 对象有独自的元表，其他类型只有类型元表 c) 只有 table 可以在 lua 中修改设置元表 d) userdata 只能在 c 中修改设置元表，lua 中不能修改 userdata 元表 协程 a) 一段独立的执行线程 b) 一个 lua 虚拟机中同时只能有一个协程在运行 c) 目的：写的时候是同步的书写方式，而实际内部是异步非阻塞的实现 闭包 a) 表现 i. 函数内部可以访问函数外部的变量 ii. lua 文件是一个匿名函数 b) 实现 i. c 函数以及绑定在 c 函数上的 upvalues(上值) c) 用 lua_pushcclosure 用来创建 c 闭包 d) 通过 lua_upvalueindex 伪索引来获取上值 虚拟栈 通过虚拟栈实现两者的读写数据操作 注册表 a) 预定义的表，用来保存任何 c 代码想保存的 lua 值 b) 使用 LUA_REGISTRYINDEX 来索引 actor 通信 skynet.send/skynet.call skynet.redirect skynet.response skynet.ret]]></content>
      <categories>
        <category>skynet</category>
      </categories>
      <tags>
        <tag>skynet</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[工作中遇到的问题]]></title>
    <url>%2F2020%2F11%2F04%2F%E5%B7%A5%E4%BD%9C%E4%B8%AD%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[1.result 等字段可重用的可以考虑重用节约内存2.不要在客户端请求的时候处理数据，提前处理好，客户端请求直接返回3.从数据库拿出来的数据都是数组，需要取ret[1]4.可以从过参数传递函数，做定时器处理5.数据库日志分得越详细越好，不同功能的表尽量分开6.节点与节点间尽量一次性调用，避免绕圈调用7.逻辑不与客户端同步，尽量保持单请求也能有反馈8.在agent的监听，下线记得清除或者在task_msg_center.lua去统一9.lua是协程，有的情况也得考虑下锁的问题10.mysql中，varchar 存储变长的字符串，但需要1个或2个额外字节记录字符串长度；char 存储定长的字符串。DataTime 8字节，TimeStamp 4字节。能用TinyInt的话不要用Int。索引在where条件查询和group by查询的时候特别有效。11.查询优化：(1 避免查找无关列(2 分解关联查询，减少锁竞争(3 用=不用&lt;&gt;，”=” 增加了索引使用几率(4 UNION ALL 不去重，效率高于UNION(5 数据行长度不要超过8020字节，超过这个长度会占用两行(6 能用数字类型的字段尽量选择数字类型而不用字符串类型（电话号码），这会降低查询和连接性能，并会增加存储开销(7 对于不可变char和可变varchar，char查询快，但是耗空间，varchar慢一些，但是节省存储空间(8 避免在where子句进行null判断或者用or来连接条件select id from t where num = 10 or num = 20;select id from t where num = 10 union all select id from t where num = 20;(9 in 和 not in 慎用。对于连续的数值能用between就不要用inselect id from t where num in (1,2,3);select id from t where num between 1 and 3;(10 避免在where子句中对字段进行操作select id from t where substring(name,1,3) = ‘abc’;select from T1 where F1 = 100 2;12.DATA.match_config.signup_data_config.signup_dur 变量过长用简写local变量代替13.数据结构先行，不能到后面再来补数据结构14.有些数据可以考虑不写数据库15.lua for k,v in pairs(table) 如果v是普通类型，直接修改v不会导致table的数据变化，如果v也是table 修改v同时会修改table16.用local变量等于一张表的时候，对local变量修改之后，最后把变量重新赋值给表 local s = _table or {} s.v = 1 _table = s 17.设计功能时，考虑多方面情况，例如托管节点崩溃，上一场的崩溃是否影响下一场，避免这种情况18.脑里构建模块化，无论是函数还是功能，可以分函数，分文件来写19.做完功能，设计好处理崩溃的函数，例如查询在比赛里的人或者PUBLIC.exit()]]></content>
      <categories>
        <category>基础</category>
      </categories>
      <tags>
        <tag>基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Nginx添加Handle模块]]></title>
    <url>%2F2020%2F11%2F03%2FNginx%E6%B7%BB%E5%8A%A0Handle%E6%A8%A1%E5%9D%97%2F</url>
    <content type="text"><![CDATA[nginx 三种类型 1.upstream 负载均衡，只转发不返回2.handle 接受请求，直接可以处理3.filter 服务器reponse 验证 ngx_http_pagecount_module.c 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279#include &lt;ngx_http.h&gt;#include &lt;ngx_config.h&gt;#include &lt;ngx_core.h&gt;/*#include &lt;arpa/inet.h&gt;#include &lt;netinet/in.h&gt;*/#define ENABLE_RBTREE 1static char *ngx_http_count_module_set(ngx_conf_t *cf, ngx_command_t *cmd, void *conf);static ngx_int_t ngx_http_count_module_handler(ngx_http_request_t *r);static ngx_command_t count_commands[] = &#123; &#123; ngx_string(&quot;count&quot;), NGX_HTTP_LOC_CONF | NGX_CONF_NOARGS, ngx_http_count_module_set, NGX_HTTP_LOC_CONF_OFFSET, 0, NULL &#125;, ngx_null_command&#125;;// 8个NULLstatic ngx_http_module_t count_ctx = &#123; NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL,&#125;;//ngx_http_count_module ngx_module_t ngx_http_count_module = &#123; NGX_MODULE_V1, &amp;count_ctx, count_commands, NGX_HTTP_MODULE, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NGX_MODULE_V1_PADDING&#125;;typedef struct &#123; int count; //count struct in_addr addr; //ip&#125; ngx_pv_table;ngx_pv_table pv_table[256];#if ENABLE_RBTREEngx_rbtree_t ngx_pv_tree; // 红黑树ngx_rbtree_node_t sentinel; // 哨兵结点static voidngx_pagecount_rbtree_insert_value(ngx_rbtree_node_t *temp, ngx_rbtree_node_t *node, ngx_rbtree_node_t *sentinel)&#123; ngx_rbtree_node_t **p; for ( ;; ) &#123; if (node-&gt;key &lt; temp-&gt;key) &#123; p = &amp;temp-&gt;left; &#125; else if (node-&gt;key &gt; temp-&gt;key) &#123; p = &amp;temp-&gt;right; &#125; else &#123; /* node-&gt;key == temp-&gt;key */ return ; &#125; if (*p == sentinel) &#123; break; &#125; temp = *p; &#125; *p = node; node-&gt;parent = temp; node-&gt;left = sentinel; node-&gt;right = sentinel; ngx_rbt_red(node);&#125;#endifstatic char *ngx_http_count_module_set(ngx_conf_t *cf, ngx_command_t *cmd, void *conf) &#123;#if ENABLE_RBTREE ngx_rbtree_init(&amp;ngx_pv_tree, &amp;sentinel, ngx_pagecount_rbtree_insert_value); //初始化红黑树#endif ngx_http_core_loc_conf_t *corecf = ngx_http_conf_get_module_loc_conf(cf, ngx_http_core_module); corecf-&gt;handler = ngx_http_count_module_handler; //注册handler return NGX_CONF_OK;&#125;#if ENABLE_RBTREE//char content[1024];//回调html组装函数void ngx_http_count_rbtree_iterator(ngx_rbtree_node_t *node, char *html) &#123; char buffer[128] = &#123;0&#125;; struct in_addr addr = &#123;0&#125;; memcpy(&amp;addr, &amp;node-&gt;key, sizeof(struct in_addr)); sprintf(buffer, &quot;req from : %s, count: %d &lt;br/&gt;&quot;, inet_ntoa(addr), node-&gt;value); strcat(html, buffer);&#125;static int ngx_encode_http_page_rb(char *html) &#123; sprintf(html, &quot;&lt;h1&gt;Source Insight &lt;/h1&gt;&quot;); strcat(html, &quot;&lt;h2&gt;&quot;); ngx_rbtree_traversal(&amp;ngx_pv_tree, ngx_pv_tree.root, ngx_http_count_rbtree_iterator, html); strcat(html, &quot;&lt;/h2&gt;&quot;); return 0;&#125;#else#if 1static int ngx_encode_http_page(char *html) &#123; sprintf(html, &quot;&lt;h1&gt;Source Insight &lt;/h1&gt;&quot;); strcat(html, &quot;&lt;h2&gt;&quot;); int i = 0; for (i = 0;i &lt; 256;i ++) &#123; if (pv_table[i].count != 0) &#123; char str[INET_ADDRSTRLEN] = &#123;0&#125;; char buffer[128] = &#123;0&#125;; sprintf(buffer, &quot;req from : %s, count: %d &lt;br/&gt;&quot;, inet_ntop(AF_INET, &amp;pv_table[i].addr, str, sizeof(str)), pv_table[i].count); strcat(html, buffer); &#125; &#125; strcat(html, &quot;&lt;/h2&gt;&quot;); return 0;&#125;#endif#endifstatic ngx_int_t ngx_http_count_module_handler(ngx_http_request_t *r) &#123;#if 0 u_char html[1024] = &quot;&lt;h1&gt; bailang, Reese, feifei, qizhewoniuqukandahai, huihuisasa, magic, jianyuebujiandan, yuan &lt;/h1&gt;&quot;; int len = sizeof(html);#elif 1 u_char html[1024] = &#123;0&#125;; int len = sizeof(html); #if ENABLE_RBTREE ngx_rbtree_node_t *node = NULL; ngx_rbtree_key_t key = 0;#endif struct sockaddr_in *client_addr = (struct sockaddr_in*)r-&gt;connection-&gt;sockaddr; //rbtree &lt;key, value&gt; --&gt; &lt;addr, count&gt; int idx = client_addr-&gt;sin_addr.s_addr &gt;&gt; 24; //rbtree --&gt; (key, value) pv_table[idx].count ++; memcpy(&amp;pv_table[idx].addr, &amp;client_addr-&gt;sin_addr, sizeof(client_addr-&gt;sin_addr)); #if ENABLE_RBTREE key = (ngx_rbtree_key_t)client_addr-&gt;sin_addr.s_addr; ngx_log_error(NGX_LOG_EMERG, r-&gt;connection-&gt;log, ngx_errno, &quot; ngx_http_count_module_handler --&gt; %x\n&quot;, key); node = ngx_rbtree_search(&amp;ngx_pv_tree, key); // 从红黑树中找 ngx_log_error(NGX_LOG_EMERG, r-&gt;connection-&gt;log, ngx_errno, &quot; 11111 --&gt; %x\n&quot;, key); // 处理红黑树存储结点 if (node == &amp;sentinel) &#123; ngx_log_error(NGX_LOG_EMERG, r-&gt;connection-&gt;log, ngx_errno, &quot; new node insert rbtree\n&quot;, key); node = ngx_pcalloc(r-&gt;pool, sizeof(ngx_rbtree_node_t)); node-&gt;key = (ngx_rbtree_key_t)client_addr-&gt;sin_addr.s_addr; node-&gt;value = 1; ngx_rbtree_insert(&amp;ngx_pv_tree, node); &#125; else &#123; node-&gt;value ++; ngx_log_error(NGX_LOG_EMERG, r-&gt;connection-&gt;log, ngx_errno, &quot; node is exist, value:%d\n&quot;, node-&gt;value); &#125; //memset(content, 0, 1024); ngx_encode_http_page_rb((char*)html); ngx_log_error(NGX_LOG_EMERG, r-&gt;connection-&gt;log, ngx_errno, &quot; html: %s\n&quot;, html); //memcpy(html, content, len);#else ngx_encode_http_page((char*)html);#endif#else // ---------------------------- 下面组装 http response ------------------------- struct sockaddr_in *client_addr = (struct sockaddr_in*)r-&gt;connection-&gt;sockaddr; ngx_rbtree_node_t *node = ngx_pcalloc(r-&gt;pool, sizeof(ngx_rbtree_node_t)); memcpy(&amp;node-&gt;key, &amp;client_addr-&gt;sin_addr.s_addr, sizeof(node-&gt;key)); #endif //header r-&gt;headers_out.status = 200; ngx_str_set(&amp;r-&gt;headers_out.content_type, &quot;text/html&quot;); ngx_http_send_header(r); //body ngx_buf_t *b = ngx_pcalloc(r-&gt;pool, sizeof(ngx_buf_t)); // 从内存池中malloc ngx_chain_t out; out.buf = b; out.next = NULL; b-&gt;pos = html; b-&gt;last = html+len; b-&gt;memory = 1; b-&gt;last_buf = 1; return ngx_http_output_filter(r, &amp;out); //http response &#125; config 123ngx_addon_name=ngx_http_pagecount_moduleHTTP_MODULES=&quot;$HTTP_MODULES ngx_http_pagecount_module&quot;NGX_ADDON_SRCS=&quot;$NGX_ADDON_SRCS $ngx_addon_dir/pagecount_module.c&quot;]]></content>
      <categories>
        <category>nginx</category>
      </categories>
      <tags>
        <tag>nginx</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mysql面试前看]]></title>
    <url>%2F2020%2F11%2F02%2Fmysql%E9%9D%A2%E8%AF%95%E5%89%8D%E7%9C%8B%2F</url>
    <content type="text"><![CDATA[InnoDB MyISAM 区别InnoDB 支持崩溃后安全恢复，MyISAM 不支持崩溃后安全恢复；InnoDB 支持行级锁，MyISAM 不支持行级锁，只支持到表锁；InnoDB 支持外键，MyISAM 不支持外键；MyISAM 性能比 InnoDB 高；MyISAM 支持 FULLTEXT 类型的全文索引，InnoDB 不支持 FULLTEXT 类型的全文索引，但是 InnoDB 可以使用 sphinx 插件支持全文索引，并且效果更好；InnoDB 主键查询性能高于 MyISAM。 InnoDB1）插入缓冲2）两次写两次写给 InnoDB 带来的是可靠性，主要用来解决部分写失败 3）自适应哈希索引 InnoDB 自增主键持久化 Mysql重启后在redo log日志中恢复InnoDB 使用事务实现，而事务的设计使用了多版本并发控制，不能把总条数记录下来。 在 InnoDB 引擎中 count()、count(1)、count(主键)、count(字段) 哪个性能最高？count(字段)&lt;count(主键 id)&lt;count(1)≈count() 题目解析： 对于 count(主键 id) 来说，InnoDB 引擎会遍历整张表，把每一行的 id 值都取出来，返回给 server 层。server 层拿到 id 后，判断是不可能为空的，就按行累加。对于 count(1) 来说，InnoDB 引擎遍历整张表，但不取值。server 层对于返回的每一行，放一个数字“1”进去，判断是不可能为空的，按行累加。对于 count(字段) 来说，如果这个“字段”是定义为 not null 的话，一行行地从记录里面读出这个字段，判断不能为 null，按行累加；如果这个“字段”定义允许为 null，那么执行的时候，判断到有可能是 null，还要把值取出来再判断一下，不是 null 才累加。对于 count(*) 来说，并不会把全部字段取出来，而是专门做了优化，不取值，直接按行累加。 重建表的执行流程建立一个临时文件，扫描表 t 主键的所有数据页；用数据页中表 t 的记录生成 B+ 树，存储到临时文件中；生成临时文件的过程中，将所有对 t 的操作记录在一个日志文件（row log）中；临时文件生成后，将日志文件中的操作应用到临时文件，得到一个逻辑数据上与表 t相同的数据文件；用临时文件替换表 t 的数据文件。 并发事务带来哪些问题脏读 修改丢失 不可重复读 幻读 什么是脏读和幻读？脏读是一个事务在处理过程中读取了另外一个事务未提交的数据；幻读是指同一个事务内多次查询返回的结果集不一样（比如增加了或者减少了行记录）。 如何避免幻读使用间隙锁的方式来避免出现幻读。间隙锁，是专门用于解决幻读这种问题的锁，它锁的了行与行之间的间隙，能够阻塞新插入的操作 间隙锁的引入也带来了一些新的问题，比如：降低并发度，可能导致死锁。 delete 和 truncate 区别delete 可以添加 where 条件删除部分数据，truncate 不能添加 where 条件只能删除整张表；delete 的删除信息会在 MySQL 的日志中记录，而 truncate 的删除信息不被记录在 MySQL 的日志中，因此 detele 的信息可以被找回而 truncate 的信息无法被找回；truncate 因为不记录日志所以执行效率比 delete 快。 视图优点获取数据更容易，相对于多表查询来说；视图能够对机密数据提供安全保护；视图的修改不会影响基本表，提供了独立的操作单元，比较轻量。 索引唯一索引和普通索引哪个性能更好？对于查询操作来说：普通索引和唯一索引的性能相近，都是从索引树中进行查询；对于更新操作来说：唯一索引要比普通索引执行的慢，因为唯一索引需要先将数据读取到内存中，再在内存中进行数据的唯一效验，所以执行起来要比普通索引更慢。 如何优化身份证的索引？在中国因为前 6 位代表的是地区，所以很多人的前六位都是相同的，如果我们使用前缀索引为 6 位的话，性能提升也并不是很明显，但如果设置的位数过长，那么占用的磁盘空间也越大，数据页能放下的索引值就越少，搜索效率也越低。针对这种情况优化方案有以下两种： 使用身份证倒序存储，这样设置前六位的意义就很大了；使用 hash 值，新创建一个字段用于存储身份证的 hash 值。 事务原子性（Atomic）：要么全部执行，要么全部不执行；一致性（Consistency）：事务的执行使得数据库从一种正确状态转化为另一种正确状态；隔离性（Isolation）：在事务正确提交之前，不允许把该事务对数据的任何改变提供给其他事务；持久性（Durability）：事务提交后，其结果永久保存在数据库中。 四种事务隔离级别read uncommited：未提交读，读到未提交数据；read committed：读已提交，也叫不可重复读，两次读取到的数据不一致；repetable read：可重复读；serializable：串行化，读写数据都会锁住整张表，数据操作不会出错，但并发性能极低，开发中很少用到。 MVCCMVCC 全称是多版本并发控制系统，InnoDB 和 Falcon 存储引擎通过多版本并发控制（MVCC，Multiversion Concurrency Control）机制解决幻读问题。 InnoDB 的 MVCC 是通过在每行记录后面保存两个隐藏的列来实现，这两个列一个保存了行的创建时间，一个保存行的过期时间（删除时间）。当然存储的并不是真实的时间而是系统版本号（system version number）。每开始一个新的事务，系统版本号都会自动新增，事务开始时刻的系统版本号会作为事务的版本号，用来查询到每行记录的版本号进行比较。]]></content>
      <categories>
        <category>mysql</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[云盘项目]]></title>
    <url>%2F2020%2F11%2F02%2F%E4%BA%91%E7%9B%98%E9%A1%B9%E7%9B%AE%2F</url>
    <content type="text"><![CDATA[待补…..]]></content>
      <categories>
        <category>项目</category>
      </categories>
      <tags>
        <tag>项目</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[FastDFS]]></title>
    <url>%2F2020%2F10%2F28%2FFastDFS%2F</url>
    <content type="text"><![CDATA[FastDFS 是一个开源的分布式文件系统，它对文件进行管理，功能包括：文件存储、文件同步、文件访问（文件上传、文件下载）等，解决了大容量存储和负载均衡的问题。特别适合以文件为载体的在线服务，如相册网站、视频网站等等。 简述 fastDFS 概述：○ 是用 c 语言编写的一款开源的分布式文件系统。○ 为互联网量身定制，充分考虑了冗余备份、负载均衡、线性扩容等机制，并注重高可用、高性能等指标○ 可以很容易搭建一套高性能的文件服务器集群提供文件上传、下载等服务。 fastDFS 特点:○ 应用层级的文件系统○ 不能挂载和卸载，也就是不能进行 mount 操作 fastDFS 框架中的三个角色○ 追踪器 - tracker○ 存储节点 - storage○ 客户端 - client fastDFS 三个角色之间的关系○ Client 和 Storage 主动连接 Tracker。○ Storage 主动向 Tracker 报告其状态信息§ 磁盘剩余空间§ 文件同步状况§ 文件上传下载次数○ Storage 会启动一个单独的线程来完成对一台 Tracker 的连接和定时报告。一个组包含的 Storage 不是通过配置文件设定的，而是通过 Tracker 获取到的。 配置 默认配置文件位置：○ /etc/fdfs Tracker（追踪器）○ 修改配置文件§ bind_addr=192.168.52.139□ 当前主机的 IP§ port=22122□ 绑定的端口§ base_path=/home/milo/fastDFS/tracker□ log 目录○ 启动 Tracker 服务§ fdfs_trackerd /etc/fdfs/tracker.conf§ sudo fdfs_trackerd /etc/fdfs/tracker.conf restart§ sudo fdfs_trackerd /etc/fdfs/tracker.conf stop Storage（存储节点）○ 修改配置文件§ group_name=group1□ 存储节点所属的组§ bind_addr=192.168.52.139□ 存储节点绑定的 IP§ port=23000□ 绑定的端口§ base_path=/home/milo/fastDFS/storage□ 存储日志文件的目录§ store_path_count=1□ 存储目录的个数§ store_path0=/home/milo/fastDFS/storage□ 配置具体的存储目录§ tracker_server=192.168.52.139:22122□ 连接 tracker 的时候使用的 IP 和端口○ 启动 Stroage 服务§ fdfs_storaged /etc/fdfs/storage.conf§ sudo fdfs_storaged /etc/fdfs/storage.conf restart§ sudo fdfs_storaged /etc/fdfs/storage.conf stop Client○ 修改配置文件§ base_path=/home/milo/fastDFS/client□ log 日志目录§ tracker_server=192.168.52.139:22122□ 连接 tracker 时候需要的 iP 和端口信息 检测当前 fdfs 环境是否是通的 Storage server 同步过程从 fastdfs 文件同步原理中我们知道 Storage server 之间的同步都是由一个独立线程负责的，这个线程中的所有操作都是以同步方式执行的。比如一组服务器有 A、B、C 三台机器，那么在每台机器上都有两个线程负责同步，如 A 机器，线程 1 负责同步数据到 B，线程 2 负责同步数据到 C。每个同步线程负责到一台 Storage 的同步，以阻塞方式进行。以 IP 为 192.168.1.1 的 Storage server 的 服 务 器 为 例 ， 它 的 同 步 目 录 下 有192.168.1.2_33450.mark 192.168.1.3_33450.mark binlog.100 等文件现在 Storage server 将会从ip 为 192.168.1.2 的 Storage server 的存储里面同步数据。1 ） 打 开 对 应 Storage server 的 mark 文 件 ， 如 负 责 到 192.168.1.1 的 同 步 则 打 开192.168.1.2_33450.mark 文件，从中读取 binlog_index、binlog_offset 两个字段值，如取到值为：100、1000，那么就打开 binlog.100 文件，seek 到 1000 这个位置。2）进入一个 while 循环，尝试着读取一行，若读取不到则睡眠等待。若读取到一行，并且该行的操作方式为源操作，如 C、A、D、T（大写的都是），则将该行指定的操作同步给对方（非源操作不需要同步），同步成功后更新 binlog_offset 标志，该值会定期写入到192.168.1.2_33450.mark 文件之中。同步过程中可能因为同步较为缓慢，导致可能在同步一个文件之前，文件已经被客户端删除，此时同步线程将打印一条日志，然后直接处理后面的 Binlog。 代码实现 fastDFS 文件上传和下载 fastDFS api 实现 进程方式实现○ 创建匿名管道○ 创建子进程○ 子进程中执行 execlp&nbsp;§ 关闭读端&nbsp;§ 将得到的文件 ID 写入管道○ 父进程&nbsp;§ 读管道&nbsp;&nbsp;&nbsp;□ 关闭写端&nbsp;&nbsp;&nbsp;□ 将 fileID 读到内存&nbsp;&nbsp;&nbsp;□ 回收子进程 pcb 1.execlp()/execl 的区别 1234int execlp(const char * file,const char * arg,....); 直接指定可执行程序的名字，在执行时会搜索环境变量。/use/bin/fdfs_upload_file int execl(const char *path, const char *arg, ...); 用户自己生成的，绝对路径 2 父子进程始终共享的东西 ○ 文件描述符&nbsp;§ open&nbsp;§ pipe○ 内存映射区 - - mmap(函数) 3.子进程写管道父进程读管道]]></content>
      <categories>
        <category>分布式</category>
      </categories>
      <tags>
        <tag>FastDFS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[FastCGI]]></title>
    <url>%2F2020%2F10%2F27%2FFastCGI%2F</url>
    <content type="text"><![CDATA[FastCGICGI公共网关接口Common Gateway Interface， 简称 CGI在物理层面上是一段程序， 运行在服务器上，提供同客户端 HTML 页面的接口 浏览器请求流程 CGI 工作流程 FastCGICGI每次都需要fork一个进程去处理，导致浪费服务器资源。于是有了FastCGI管理CGI FastCGI 进程管理器fastcgi 可使用 spawn-fcgi 或者 php-fpm 来管理 (fastcgi 进程管理器，有很多不同类型的)nginx 下 fastcgi 与服务器是分离的 spawn-fcgi• 相当一个代理工具• 角色完成 nginx 和 fastcgi 之间的进程间通信 环境配置nginx 处理不了的指令, 交给 fastcgi 处理• 数据需要转发• 数据需要发送到指定的端口• 处理一个指令 test• url: http://192.168.52.139/test 12345678910location /test&#123; #配置 fastcgi 模块 fastcgi_pass 127.0.0.1:9001; #IP: #127.0.0.1/localhost/192.168.52.139 #端口: #将要处理的数据发送到 9001 端口 #9001 端口对应一个进程, 该进程可以收到 nginx 发送过来的数据 include fastcgi.conf;&#125; fastCGI 协议、Spawn-fcgi、Nginx 三者关系Nginx 是 web 服务器，只提供 HTTP 协议的输入和输出。spawn-fcgi 服务器，只支持 Fastcgi 协议的输入和输出。它们 2 者直接由 Nginx 将 HTTP 协议转换为 Fastcgi 协议传输给 fastCGI 进程处理。 与Tomcat区别]]></content>
      <categories>
        <category>FastCGI</category>
      </categories>
      <tags>
        <tag>FastCGI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Makefile]]></title>
    <url>%2F2020%2F10%2F22%2FMakefile%2F</url>
    <content type="text"><![CDATA[Makefile就是在命令前加了⼀个‘@’。 这⼀符号告诉 make，在运⾏时不要将这⼀⾏命令显示出来。 make 在检查⼀个规则时，采⽤的⽅法是：如果先决条件中相关的⽂件的时间戳⼤于⽬标的时间戳，即先决条件中的⽂件⽐⽬标更新，则知道有变化，那么需要运⾏规则当中的命令重新构建⽬标。 假目标.PHONY: clean 变量自动变量$@⽤于表示⼀个规则中的⽬标。当我们的⼀个规则中有多个⽬标时，$@所指的是其中任何造成命令被运⾏的⽬标。$^则表示的是规则中的所有先择条件。$&lt;表示的是规则中的第⼀个先决条件。 变量类别“=” 可递归 “:=” make 只对其进⾏⼀次扫描和替换 “?=” 条件赋值的意思是当变量以前没有定义时，就定义它并且将左边的值赋值给它，如果已经定义了那么就不再改变其值。条件赋值类似于提供了给变量赋缺省值的功能。 引用替换Makefile.PHONY: allfoo = a.o b.o c.obar := $(foo:.o=.c)all:@echo “bar = $(bar)” 执⾏$makebar = a.c b.c c.c override手动替换 函数 包含文件include $(DEPS) -include $(DEPS) 忽略文件 实例123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172PHONY: all cleanMKDIR = mkdirRM = rmRMFLAGS = -frCC = gccAR = arARFLAGS = crsDIR_OBJS = objsDIR_EXES = $(ROOT)/build/exesDIR_DEPS = depsDIR_LIBS = $(ROOT)/build/libsDIRS = $(DIR_DEPS) $(DIR_OBJS) $(DIR_EXES) $(DIR_LIBS)RMS = $(DIR_OBJS) $(DIR_DEPS)ifneq ($(EXE), &quot;&quot;)EXE := $(addprefix $(DIR_EXES)/, $(EXE))RMS += $(EXE)endififneq ($(LIB), &quot;&quot;)LIB := $(addprefix $(DIR_LIBS)/, $(LIB))RMS += $(LIB)endifSRCS = $(wildcard *.c)OBJS = $(SRCS:.c=.o)OBJS := $(addprefix $(DIR_OBJS)/, $(OBJS))DEPS = $(SRCS:.c=.dep)DEPS := $(addprefix $(DIR_DEPS)/, $(DEPS))ifneq ($(EXE), &quot;&quot;)all: $(EXE)endififneq ($(LIB), &quot;&quot;)all: $(LIB)endififneq ($(MAKECMDGOALS), clean)include $(DEPS)endififneq ($(INC_DIRS), &quot;&quot;)INC_DIRS := $(strip $(INC_DIRS))INC_DIRS := $(addprefix -I, $(INC_DIRS))endififneq ($(LINK_LIBS), &quot;&quot;)LINK_LIBS := $(strip $(LINK_LIBS))LINK_LIBS := $(addprefix -l, $(LINK_LIBS))endif$(DIRS):$(MKDIR) $@$(EXE): $(DIR_EXES) $(OBJS)$(CC) -L$(DIR_LIBS) -o $@ $(filter %.o, $^) $(LINK_LIBS)$(LIB): $(DIR_LIBS) $(OBJS)$(AR) $(ARFLAGS) $@ $(filter %.o, $^)$(DIR_OBJS)/%.o: $(DIR_OBJS) %.c$(CC) $(INC_DIRS) -o $@ -c $(filter %.c, $^)$(DIR_DEPS)/%.dep: $(DIR_DEPS) %.c@echo &quot;Making $@ ...&quot;set -e ; \$(RM) $(RMFLAGS) $@.tmp ; \$(CC) $(INC_DIRS) -E -MM $(filter %.c, $^) &gt; $@.tmp ; \sed &apos;s,\(.*\)\.o[ :]*,objs/\1.o $@: ,g&apos; &lt; $@.tmp &gt; $@ ; \$(RM) $(RMFLAGS) $@.tmpclean:$(RM) $(RMFLAGS) $(RMS)source/foo/src/MakefileEXE =LIB = libfoo.aINC_DIRS = $(ROOT)/source/foo/incLINK_LIBS =include $(ROOT)/build/make.rulesource/huge/src/MakefileEXE = hugeLIB =INC_DIRS = $(ROOT)/source/foo/incLINK_LIBS = fooinclude $(ROOT)/build/make.rule 执行1234567891011⽬录 /Makefile/huge/source/huge/src$make/Makefile/huge/build/make.rule:43: deps/main.dep: No such file or directorymkdir depsMaking deps/main.dep ...mkdir objsgcc -I/Makefile/huge/source/foo/inc -o objs/main.o -c main.cgcc -L/Makefile/huge/build/libs -o /Makefile/huge/build/exes/huge objs/main.o -lfoo⽬录 /Makefile/huge/source/huge/src$$ROOT/build/exes/hugeThis is foo ()! 123456789101112131415161718192021222324252627source/build/Makefile.PHONY: all cleanDIRS = $(ROOT)/source/foo/src \$(ROOT)/source/bar/src \$(ROOT)/source/huge/srcRM = rmRMFLAGS = -frRMS = $(ROOT)/build/exes $(ROOT)/build/libsall:@set -e; \for dir in $(DIRS); \do \cd $$dir &amp;&amp; $(MAKE) ; \done@echo &quot;&quot;@echo &quot;:-) Completed&quot;@echo &quot;&quot;clean:@set -e; \for dir in $(DIRS); \do \cd $$dir &amp;&amp; $(MAKE) clean;\done$(RM) $(RMFLAGS) $(RMS)@echo &quot;&quot;@echo &quot;:-) Completed&quot;@echo &quot;&quot; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950⽬录 /Makefile/build$makemake[1]: Entering directory `/Makefile/huge/source/foo/src&apos;/Makefile/huge/build/make.rule:43: deps/foo.dep: No such file or directorymkdir depsMaking deps/foo.dep ...make[1]: Leaving directory `/Makefile/huge/source/foo/src&apos;make[1]: Entering directory `/Makefile/huge/source/foo/src&apos;mkdir /Makefile/huge/build/libsmkdir objsgcc -I/Makefile/huge/source/foo/inc -o objs/foo.o -c foo.car crs /Makefile/huge/build/libs/libfoo.a objs/foo.omake[1]: Leaving directory `/Makefile/huge/source/foo/src&apos;make[1]: Entering directory `/Makefile/huge/source/bar/src&apos;/Makefile/huge/build/make.rule:43: deps/bar.dep: No such file or directormkdir depsMaking deps/bar.dep ...make[1]: Leaving directory `/Makefile/huge/source/bar/src&apos;make[1]: Entering directory `/Makefile/huge/source/bar/src&apos;mkdir objsgcc -I/Makefile/huge/source/bar/inc -o objs/bar.o -c bar.car crs /Makefile/huge/build/libs/libbar.a objs/bar.omake[1]: Leaving directory `/Makefile/huge/source/bar/src&apos;make[1]: Entering directory `/Makefile/huge/source/huge/src&apos;/Makefile/huge/build/make.rule:43: deps/main.dep: No such file or directorymkdir depsMaking deps/main.dep ...make[1]: Leaving directory `/Makefile/huge/source/huge/src&apos;make[1]: Entering directory `/Makefile/huge/source/huge/src&apos;mkdir /Makefile/huge/build/exesmkdir objsgcc -I/Makefile/huge/source/foo/inc -I/Makefile/huge/source/bar/inc -o objs/main.o -cmain.cgcc -L/Makefile/huge/build/libs -o /Makefile/huge/build/exes/huge objs/main.o -lfoo -lbarmake[1]: Leaving directory `/Makefile/huge/source/huge/src&apos;:-) Completed⽬录 /Makefile/build$make cleanmake[1]: Entering directory `/Makefile/huge/source/foo/src&apos;rm -fr objs deps /Makefile/huge/build/libs/libfoo.amake[1]: Leaving directory `/Makefile/huge/source/foo/src&apos;make[1]: Entering directory `/Makefile/huge/source/bar/src&apos;rm -fr objs deps /Makefile/huge/build/libs/libbar.amake[1]: Leaving directory `/Makefile/huge/source/bar/src&apos;make[1]: Entering directory `/Makefile/huge/source/huge/src&apos;rm -fr objs deps /Makefile/huge/build/exes/hugemake[1]: Leaving directory `/Makefile/huge/source/huge/src&apos;rm -fr /Makefile/huge/build/exes /Makefile/huge/build/libs:-) Completed]]></content>
      <categories>
        <category>基础</category>
      </categories>
      <tags>
        <tag>makefile</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux系统命令]]></title>
    <url>%2F2020%2F10%2F19%2FLinux%E7%B3%BB%E7%BB%9F%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[grep grep login -r msg_server/反向查找，查找文件中，不包含 hello 的行。 grep -v login ImUser.cpp找出文件中包含 login 的行，并打印出行号 grep -n login ImUser.cpp找出文件中包含 login 的行，打印出行号，并显示前后 3 行 grep -C 3 -n login ImUser.cpp找出文件中包含 login 的行，打印出行号，并显示前后 3 行，并忽略大小写 grep -C 3 -i -n login ImUser.cpp findfind . -name FILE_NAMEfind . -iname FILE_NAME 忽略文件名称大小写 scpscp liaoqingfu@122.152.222.180:/home/liaoqingfu/test.txt . //下载文件scp mi9.aac liaoqingfu@122.152.222.180:/home/liaoqingfu/ //上传文件scp ‐r liaoqingfu@122.152.222.180:/home/liaoqingfu/ . //下载目录scp ‐r test liaoqingfu@122.152.222.180:/home/liaoqingfu/ //上传目录 ls -t 可以查看最新修改的时间 -l 每行显示一个条目 -h 可以结合显示文件的 GB，MB 等(human)； -R 递归显示 -n 显示组 id 和 gid ls -lt 按最新修改的时间排序，新修改的在前面显示。ls -ltR 按最新修改的时间排序，新修改的在前面显示，并显示子目录的文件信息ls -lh 以单位显示文件大小 wcwc 命令用于计算字数。 利用 wc 指令我们可以计算文件的 Byte 数、字数、或是列数，若不指定文件名称、或是所给予的文件名为”-“，则 wc 指令会从标准输入设备读取数据。 语法wc [-clw][–help][–version][文件…] 参数：-c 或–bytes 或–chars 只显示 Bytes 数。-l 或–lines 只显示行数。-w 或–words 只显示字数。–help 在线帮助。–version 显示版本信息。 pidstatpidstat 用于监控全部或指定的进程占用系统资源的情况，包括 CPU、内存、磁盘 I/O、程切换、线程数等数据。 • -u：表示查看 cpu 相关的性能指标• -w：表示查看上下文切换情况• -t：查看线程相关的信息，默认是进程的;常与-w 结合使用(cpu 的上下文切换包括进程的切换、线程的切换、中断的切换)• -d：展示磁盘 I/O 统计数据• -p：指明进程号使用方式：pidstat [option] interval [count] [root@VM_0_3_centos ~]# pidstat -urd -p 24615Linux 3.10.0-957.5.1.el7.x86_64 (VM_0_3_centos) 08/22/2019 _x86_64_ (1CPU)输出 CPU 的使用信息 -u03:48:12 PM UID PID %usr %system %guest %CPU CPU Command03:48:12 PM 0 24615 0.00 0.00 0.00 0.00 0 nginx输出内存的使用信息 -r03:48:12 PM UID PID minflt/s majflt/s VSZ RSS %MEMCommand03:48:12 PM 0 24615 0.00 0.00 58252 24940 1.32 nginx输出磁盘 I/O 的使用信息 -d03:48:12 PM UID PID kB_rd/s kB_wr/s kB_ccwr/s Command03:48:12 PM 0 24615 0.07 0.00 0.00 nginx 03:20:54 PM UID PID cswch/s nvcswch/s Command03:20:54 PM 0 24615 0.03 0.00 nginx free此命令用于显示系统内存的使用情况，包括总体内存、己经使用的内存；还可用于显示系统内核使用的缓冲区，包括缓冲（buffer）和缓存（cache）等。使用方式：free命令输出： buffer: 攒数据，然后批量写入，比如硬盘数据的写入 cache: 低速设备到高速设备的缓存（预读），比如从硬盘读取数据，读取100字节，但实际读了4K到cache里面，下次直接从cache里取 mpstat此命令用于实时监控系统 CPU 的一些统计信息，这些信息存放在/proc/stat 文件中，在多核 CPU 系统里，不但能查看所有 CPU 的平均使用信息，还能查看某个特定 CPU 的信息。使用方式：mpstat [-P {cpu|ALL}] [internal [count]]当 mpstat 不带参数时，输出为从系统启动以来的平均值。 df硬盘使用情况 df -h nc验证服务器端口有没有开放 参数-l 用于指定 nc 将处于侦听模式。指定该参数，则意味着 nc 被当作 server，侦听并接受连接，而非向其它地址发起连接。-p 暂未用到（老版本的 nc 可能需要在端口号前加-p 参数，下面测试环境是centos6.6，nc 版本是 nc-1.84，未用到-p 参数）-s 指定发送数据的源 IP 地址，适用于多网卡机-u 指定 nc 使用 UDP 协议，默认为 TCP-v 输出交互或出错信息，新手调试时尤为有用-w 超时秒数，后面跟数字 nslookup解析IP地址 nslookup sina.com tcpdumptcpdump 是网络状况分析和跟踪工具，是可以用来抓包的实用命令，使用前需要对TCP/IP 有所熟悉，因为过滤使用的信息都是 TCP/IP 格式。 procLinux 系统内核提供了通过/proc 文件系统查看运行时内核内部数据结构的能力，也可以改变内核参数设置。 显示 CPU 信息：cat /proc/cpuinfo 显示内存信息：cat /proc/meminfo 显示详细的内存映射信息：cat /proc/zoneinfo 显示磁盘映射信息：cat /proc/mounts 查看系统平均负载命令：cat /proc/loadavg]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Valgrind/gdb]]></title>
    <url>%2F2020%2F10%2F15%2FValgrind-gdb%2F</url>
    <content type="text"><![CDATA[ValgrindValgrind 是一套 Linux 下，开放源代码（ GPL V2）的仿真调试工具的集合。 Valgrind由内核（ core）以及基于内核的其他调试工具组成。内核类似于一个框架（ framework），它模拟了一个 CPU 环境，并提供服务给其他工具；而其他工具则类似于插件 (plug-in)，利用内核提供的服务完成各种特定的内存调试任务。 1.编译安装 Valgrind123456789101112131415161718192021222324252627282930313233wget https://fossies.org/linux/misc/valgrind-3.15.0.tar.bz2tar -jxvf valgrind-3.15.0.tar.bz2cd valgrind-3.15.0./configuremakesudo make install示例：alpha@alpha:~/share/gdb/valgrind$-g sample.c -o samplealpha@alpha:~/share/gdb/valgrind$ lsbadacc.c badleak2.cpp badloop.c README.md sample.c valgrind-3.15.0badlap.c badleak.cpp badmac.cpp sample uninitial.c valgrind-3.15.0.tar.bz2alpha@alpha:~/share/gdb/valgrind$ valgrind ./sample==31558== Memcheck, a memory error detector==31558== LEAK SUMMARY:==31558== definitely lost: 40 bytes in 1 blocks==31558== indirectly lost: 0 bytes in 0 blocks==31558== possibly lost: 0 bytes in 0 blocks==31558== still reachable: 0 bytes in 0 blocks==31558== suppressed: 0 bytes in 0 blocks==31558== Rerun with --leak-check=full to see details of leaked memory#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;void fun( )&#123; int *p = (int *)malloc(10*sizeof(int)); p[10] = 0;&#125;int main(void)&#123; fun(); return 0;&#125; 申请了空间，但是没有被释放物理内存不一定连续，虚拟地址是连续的 gdb在编译时需要加上-g123456789101112131415161718192021–g –o hello_server hello_server.calpha@alpha:~/share/gdb/gdb$ lscore_dump.c hello_server.c jump.c next.c redis-4.0.11.tar.gz step1.c watch.calpha@alpha:~/share/gdb/gdb$-o hello_server hello_server.calpha@alpha:~/share/gdb/gdb$ gdb hello_serverGNU gdb (Ubuntu 7.7.1-0ubuntu5~14.04.3) 7.7.1Copyright (C) 2014 Free Software Foundation, Inc.License GPLv3+: GNU GPL version 3 or later &lt;http://gnu.org/licenses/gpl.html&gt;This is free software: you are free to change and redistribute it.There is NO WARRANTY, to the extent permitted by law. Type &quot;show copying&quot;and &quot;show warranty&quot; for details.This GDB was configured as &quot;x86_64-linux-gnu&quot;.Type &quot;show configuration&quot; for configuration details.For bug reporting instructions, please see:&lt;http://www.gnu.org/software/gdb/bugs/&gt;.Find the GDB manual and other documentation resources online at:&lt;http://www.gnu.org/software/gdb/documentation/&gt;.For help, type &quot;help&quot;.Type &quot;apropos word&quot; to search for commands related to &quot;word&quot;...Reading symbols from hello_server...(no debugging symbols found)...done. 调试 redis安装 redis1.下载源码并解压wget http://download.redis.io/releases/redis-4.0.11.tar.gztar zxvf redis-4.0.11.tar.gz 进入 redis 源码目录并编译，注意编译时要生成调试符号并且关闭编译器优化选项。cd redis-4.0.11make CFLAGS=”-g -O0” -j 2由于 redis 是纯 C 项目，使用的编译器是 ，因而这里设置编译器的选项时使用的是 CFLAGS 选项；如果项目使用的语言是 C++，那么使用的编译器一般是 g++，相对应的编译器选项是 CXXFLAGS。这点请读者注意区别。另外，这里 makefile 使用了 -j 选项，其值是 2，表示开启 2 个进程同时编译，加快编译速度。编译成功后，会在 src 目录下生成多个可执行程序，其中 redis-server 和 redis-cli 是需要调试的程序。 进入 src 目录，使用 GDB 启动 redis-server 这个程序：cd srcgdb ./redis-server gdb三种调试方式gdb filename 直接调试目标程序gdb ./hello_server gdb attach pid 附加进程在某些情况下，一个程序已经启动了，我们想调试这个程序，但是又不想重启这个程序。 比如调试 redis。 得到 redis 进程 PID 为 35456，然后使用 gdb attach 35456，如果不是 root 权限需要加上 sudo，即是sudo gdb attach 35456。 当用 gdb attach 上目标进程后，调试器会暂停下来，此时可以使用 continue 命令让程序继续运行，或者加上相应的断点再继续运行程序。当调试完程序想结束此次调试时，而且不对当前进程 redis 有任何影响，也就是说想让这个程序继续运行，可以在GDB 的命令行界面输入 detach 命令让程序与 GDB调试器分离，这样 redis 就可以继续运行了： gdb filename corename 调试 core 文件ulimit –c unlimited 暂时生效产生 coredump 的条件发现 core file size 那一行默认是 0，表示关闭生成 core 文件，可以使用“ ulimit 选项名 设置值”来修改。例如，可以将 core 文件生成改成具体某个值（最大允许的字节数），这里我们使用 ulimit -c unlimited （ unlimited 是 -c 选项值）直接修改成不限制大小。将 ulimit -c unlimited 放入/etc/profile 中，然后执行 source /etc/profile 即可立即生效。即是：（ 1） 将 ulimit -c unlimited 放入/etc/profile（ 2） source /etc/profile（ 3） 再次查看 ulimit -aalpha@alpha:~/share/redis-4.0.11/src$ ulimit -a core file size (blocks, -c) unlimited 范例测试 编译运行]]></content>
      <categories>
        <category>测试</category>
      </categories>
      <tags>
        <tag>测试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[log4cpp]]></title>
    <url>%2F2020%2F10%2F13%2Flog4cpp%2F</url>
    <content type="text"><![CDATA[]]></content>
      <categories>
        <category>日志</category>
      </categories>
      <tags>
        <tag>log4cpp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[reactor模型]]></title>
    <url>%2F2020%2F10%2F12%2Freactor%E6%A8%A1%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[作为一个高性能服务器程序通常需要考虑处理三类事件： I/O 事件，定时事件及信号。 应用程序需要提供相应的接口并注册到 Reactor 上，如果相应的时间发生，Reactor 将主动调用应用程序注册的接口，所以Reactor译为反应堆。 Reactor 模型有三个重要的组件： 多路复用器：由操作系统提供，在 linux 上一般是 select, poll, epoll 等系统调用。 事件分发器：将多路复用器中返回的就绪事件分到对应的处理函数中。 事件处理器：负责处理特定事件的处理函数。 问题在于他是单线程，CPU现在的发展状况是以核心数上升。当程序需要使用多核资源时，Reactor 模型就会悲剧。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#include &lt;sys/socket.h&gt;#include &lt;sys/epoll.h&gt;#include &lt;arpa/inet.h&gt;#include &lt;fcntl.h&gt;#include &lt;unistd.h&gt;#include &lt;errno.h&gt;#define BUFFER_LENGTH 4096#define MAX_EPOLL_EVENTS 1024#define SERVER_PORT 8888typedef int NCALLBACK(int ,int, void*);struct ntyevent &#123; int fd; int events; void *arg; int (*callback)(int fd, int events, void *arg); int status; char buffer[BUFFER_LENGTH]; int length; long last_active;&#125;;/* * 核心是epoll和反应堆的管理 */struct ntyreactor &#123; int epfd; struct ntyevent *events;&#125;;int recv_cb(int fd, int events, void *arg);int send_cb(int fd, int events, void *arg);void nty_event_set(struct ntyevent *ev, int fd, NCALLBACK callback, void *arg) &#123; ev-&gt;fd = fd; ev-&gt;callback = callback; ev-&gt;events = 0; ev-&gt;arg = arg; ev-&gt;last_active = time(NULL); return ; &#125;int nty_event_add(int epfd, int events, struct ntyevent *ev) &#123; struct epoll_event ep_ev = &#123;0, &#123;0&#125;&#125;; ep_ev.data.ptr = ev; ep_ev.events = ev-&gt;events = events; int op; if (ev-&gt;status == 1) &#123; op = EPOLL_CTL_MOD; &#125; else &#123; op = EPOLL_CTL_ADD; ev-&gt;status = 1; &#125; if (epoll_ctl(epfd, op, ev-&gt;fd, &amp;ep_ev) &lt; 0) &#123; printf(&quot;event add failed [fd=%d], events[%d]\n&quot;, ev-&gt;fd, events); return -1; &#125; return 0;&#125;int nty_event_del(int epfd, struct ntyevent *ev) &#123; struct epoll_event ep_ev = &#123;0, &#123;0&#125;&#125;; if (ev-&gt;status != 1) &#123; return -1; &#125; ep_ev.data.ptr = ev; ev-&gt;status = 0; epoll_ctl(epfd, EPOLL_CTL_DEL, ev-&gt;fd, &amp;ep_ev); return 0;&#125;int recv_cb(int fd, int events, void *arg) &#123; struct ntyreactor *reactor = (struct ntyreactor*)arg; struct ntyevent *ev = reactor-&gt;events+fd; int len = recv(fd, ev-&gt;buffer, BUFFER_LENGTH, 0); nty_event_del(reactor-&gt;epfd, ev); if (len &gt; 0) &#123; ev-&gt;length = len; ev-&gt;buffer[len] = &apos;\0&apos;; printf(&quot;C[%d]:%s\n&quot;, fd, ev-&gt;buffer); nty_event_set(ev, fd, send_cb, reactor); nty_event_add(reactor-&gt;epfd, EPOLLOUT, ev); &#125; else if (len == 0) &#123; close(ev-&gt;fd); printf(&quot;[fd=%d] pos[%ld], closed\n&quot;, fd, ev-reactor-&gt;events); &#125; else &#123; close(ev-&gt;fd); printf(&quot;recv[fd=%d] error[%d]:%s\n&quot;, fd, errno, strerror(errno)); &#125; return len;&#125;int send_cb(int fd, int events, void *arg) &#123; struct ntyreactor *reactor = (struct ntyreactor*)arg; struct ntyevent *ev = reactor-&gt;events+fd; int len = send(fd, ev-&gt;buffer, ev-&gt;length, 0); if (len &gt; 0) &#123; printf(&quot;send[fd=%d], [%d]%s\n&quot;, fd, len, ev-&gt;buffer); nty_event_del(reactor-&gt;epfd, ev); nty_event_set(ev, fd, recv_cb, reactor); nty_event_add(reactor-&gt;epfd, EPOLLIN, ev); &#125; else &#123; close(ev-&gt;fd); nty_event_del(reactor-&gt;epfd, ev); printf(&quot;send[fd=%d] error %s\n&quot;, fd, strerror(errno)); &#125; return len;&#125;int accept_cb(int fd, int events, void *arg) &#123; struct ntyreactor *reactor = (struct ntyreactor*)arg; if (reactor == NULL) return -1; struct sockaddr_in client_addr; socklen_t len = sizeof(client_addr); int clientfd; if ((clientfd = accept(fd, (struct sockaddr*)&amp;client_addr, &amp;len)) == -1) &#123; if (errno != EAGAIN &amp;&amp; errno != EINTR) &#123; &#125; printf(&quot;accept: %s\n&quot;, strerror(errno)); return -1; &#125; int i = 0; do &#123; for (i = 0;i &lt; MAX_EPOLL_EVENTS;i ++) &#123; if (reactor-&gt;events[i].status == 0) &#123; break; &#125; &#125; if (i == MAX_EPOLL_EVENTS) &#123; printf(&quot;%s: max connect limit[%d]\n&quot;, __func__, MAX_EPOLL_EVENTS); break; &#125; int flag = 0; if ((flag = fcntl(clientfd, F_SETFL, O_NONBLOCK)) &lt; 0) &#123; printf(&quot;%s: fcntl nonblocking failed, %d\n&quot;, __func__, MAX_EPOLL_EVENTS); break; &#125; nty_event_set(&amp;reactor-&gt;events[clientfd], clientfd, recv_cb, reactor); nty_event_add(reactor-&gt;epfd, EPOLLIN, &amp;reactor-&gt;events[clientfd]); &#125; while (0); printf(&quot;new connect [%s:%d][time:%ld], pos[%d]\n&quot;, inet_ntoa(client_addr.sin_addr), ntohs(client_addr.sin_port), reactor-&gt;events[i].last_active, i); return 0;&#125;int init_sock(short port) &#123; int fd = socket(AF_INET, SOCK_STREAM, 0); fcntl(fd, F_SETFL, O_NONBLOCK); struct sockaddr_in server_addr; memset(&amp;server_addr, 0, sizeof(server_addr)); server_addr.sin_family = AF_INET; server_addr.sin_addr.s_addr = htonl(INADDR_ANY); server_addr.sin_port = htons(port); bind(fd, (struct sockaddr*)&amp;server_addr, sizeof(server_addr)); if (listen(fd, 20) &lt; 0) &#123; printf(&quot;listen failed : %s\n&quot;, strerror(errno)); &#125; return fd;&#125;int ntyreactor_init(struct ntyreactor *reactor) &#123; if (reactor == NULL) return -1; memset(reactor, 0, sizeof(struct ntyreactor)); reactor-&gt;epfd = epoll_create(1); if (reactor-&gt;epfd &lt;= 0) &#123; printf(&quot;create epfd in %s err %s\n&quot;, __func__, strerror(errno)); return -2; &#125; reactor-&gt;events = (struct ntyevent*)malloc((MAX_EPOLL_EVENTS) * sizeof(struct ntyevent)); if (reactor-&gt;events == NULL) &#123; printf(&quot;create epfd in %s err %s\n&quot;, __func__, strerror(errno)); close(reactor-&gt;epfd); return -3; &#125;&#125;int ntyreactor_destory(struct ntyreactor *reactor) &#123; close(reactor-&gt;epfd); free(reactor-&gt;events);&#125;int ntyreactor_addlistener(struct ntyreactor *reactor, int sockfd, NCALLBACK *acceptor) &#123; if (reactor == NULL) return -1; if (reactor-&gt;events == NULL) return -1; nty_event_set(&amp;reactor-&gt;events[sockfd], sockfd, acceptor, reactor); nty_event_add(reactor-&gt;epfd, EPOLLIN, &amp;reactor-&gt;events[sockfd]); return 0;&#125;int ntyreactor_run(struct ntyreactor *reactor) &#123; if (reactor == NULL) return -1; if (reactor-&gt;epfd &lt; 0) return -1; if (reactor-&gt;events == NULL) return -1; struct epoll_event events[MAX_EPOLL_EVENTS+1]; int checkpos = 0, i; while (1) &#123; long now = time(NULL); for (i = 0;i &lt; 100;i ++, checkpos ++) &#123; if (checkpos == MAX_EPOLL_EVENTS) &#123; checkpos = 0; &#125; if (reactor-&gt;events[checkpos].status != 1) &#123; continue; &#125; long duration = now - reactor-&gt;events[checkpos].last_active; if (duration &gt;= 60) &#123; close(reactor-&gt;events[checkpos].fd); printf(&quot;[fd=%d] timeout\n&quot;, reactor-&gt;events[checkpos].fd); nty_event_del(reactor-&gt;epfd, &amp;reactor-&gt;events[checkpos]); &#125; &#125; int nready = epoll_wait(reactor-&gt;epfd, events, MAX_EPOLL_EVENTS, 1000); if (nready &lt; 0) &#123; printf(&quot;epoll_wait error, exit\n&quot;); continue; &#125; for (i = 0;i &lt; nready;i ++) &#123; struct ntyevent *ev = (struct ntyevent*)events[i].data.ptr; if ((events[i].events &amp; EPOLLIN) &amp;&amp; (ev-&gt;events &amp; EPOLLIN)) &#123; ev-&gt;callback(ev-&gt;fd, events[i].events, ev-&gt;arg); &#125; if ((events[i].events &amp; EPOLLOUT) &amp;&amp; (ev-&gt;events &amp; EPOLLOUT)) &#123; ev-&gt;callback(ev-&gt;fd, events[i].events, ev-&gt;arg); &#125; &#125; &#125;&#125;int main(int argc, char *argv[]) &#123; unsigned short port = SERVER_PORT; if (argc == 2) &#123; port = atoi(argv[1]); &#125; int sockfd = init_sock(port); struct ntyreactor *reactor = (struct ntyreactor*)malloc(sizeof(struct ntyreactor)); ntyreactor_init(reactor); ntyreactor_addlistener(reactor, sockfd, accept_cb); ntyreactor_run(reactor); ntyreactor_destory(reactor); close(sockfd); return 0;&#125; 如何使用reactor实现百万并发服务需要解决的问题：1.操作系统fd的限制2.Segmentation fault(core dumped)3.端口的问题 客户端端口以及服务器端口，并且同时listen多个端口 遇到问题考虑tcp五元组(sip, dip, sport, dport, proto)]]></content>
      <categories>
        <category>基础</category>
      </categories>
      <tags>
        <tag>reactor</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[消息队列和ZeroMQ]]></title>
    <url>%2F2020%2F10%2F09%2F%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E5%92%8CZeroMQ%2F</url>
    <content type="text"><![CDATA[消息可靠性处理(1) 确认ACK，如果没有ACK就超时重传；(2) 定义序列号，消息序号是连续，中间发现消息不连续的时候就知道丢了信息；(3) 备份；(4) 持久化 RocketMQ 消息吞吐量 流量削峰使用消息队列隔离网关和后端服务，以达到流量控制和保护后端服务的目的 模型]]></content>
      <categories>
        <category>ZeroMQ</category>
      </categories>
      <tags>
        <tag>ZeroMQ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[内存池]]></title>
    <url>%2F2020%2F10%2F09%2F%E5%86%85%E5%AD%98%E6%B1%A0%2F</url>
    <content type="text"><![CDATA[123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249#include &lt;stdlib.h&gt;#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;unistd.h&gt;#include &lt;fcntl.h&gt;#define MP_ALIGNMENT 32#define MP_PAGE_SIZE 4096#define MP_MAX_ALLOC_FROM_POOL (MP_PAGE_SIZE-1)#define mp_align(n, alignment) (((n)+(alignment-1)) &amp; ~(alignment-1))#define mp_align_ptr(p, alignment) (void *)((((size_t)p)+(alignment-1)) &amp; ~(alignment-1))struct mp_large_s &#123; struct mp_large_s *next; void *alloc;&#125;;struct mp_node_s &#123; unsigned char *last; // 已经使用区段末尾 unsigned char *end; // 整个数据区段末尾 struct mp_node_s *next; size_t failed;&#125;;struct mp_pool_s &#123; size_t max; struct mp_node_s *current; // 指向mp_node_s 结点 struct mp_large_s *large; //大块内存 struct mp_node_s head[0];&#125;;//内存池创建struct mp_pool_s *mp_create_pool(size_t size) &#123; struct mp_pool_s *p; int ret = posix_memalign((void **)&amp;p, MP_ALIGNMENT, size + sizeof(struct mp_pool_s) + sizeof(struct mp_node_s)); if (ret) &#123; return NULL; &#125; p-&gt;max = (size &lt; MP_MAX_ALLOC_FROM_POOL) ? size : MP_MAX_ALLOC_FROM_POOL; p-&gt;current = p-&gt;head; p-&gt;large = NULL; p-&gt;head-&gt;last = (unsigned char *)p + sizeof(struct mp_pool_s) + sizeof(struct mp_node_s); p-&gt;head-&gt;end = p-&gt;head-&gt;last + size; p-&gt;head-&gt;failed = 0; return p;&#125;//内存池销毁void mp_destory_pool(struct mp_pool_s *pool) &#123; struct mp_node_s *h, *n; struct mp_large_s *l; for (l = pool-&gt;large; l; l-&gt;next) &#123; if (l-&gt;alloc) &#123; free(l-&gt;alloc); &#125; &#125; h = pool-&gt;head-&gt;next; while(h) &#123; n = h-&gt;next; free(h); h = n; &#125; free(pool);&#125;//释放大页内存void mp_free(struct mp_pool_s *pool, void *p) &#123; struct mp_large_s *l; for (l = pool-&gt;large; l; l = l-&gt;next) &#123; if (p == l-&gt;alloc) &#123; free(l-&gt;alloc); l-&gt;alloc = NULL; return ; &#125; &#125;&#125;//内存池重置//1.释放large//2.将node节点last重置void mp_reset_pool(struct mp_pool_s *pool) &#123; struct mp_node_s *h; struct mp_large_s *l; for (l = pool-&gt;large; l; l = l-&gt;next) &#123; if (l-&gt;alloc) &#123; free(l-&gt;alloc); &#125; &#125; pool-&gt;large = NULL; for (h = pool-&gt;head; h; h = h-&gt;next) &#123; h-&gt;last = (unsigned char *)h + sizeof(struct mp_node_s); &#125;&#125;//分配小块内存static void *mp_alloc_block(struct mp_pool_s *pool, size_t size) &#123; unsigned char *m; struct mp_node_s *h = pool-&gt;head; size_t psize = (size_t)(h-&gt;end - (unsigned char *)h); int ret = posix_memalign((void **)&amp;m, MP_ALIGNMENT, psize); if (ret) return NULL; struct mp_node_s *p, *new_node, *current; new_node = (struct mp_node_s*)m; new_node-&gt;end = m + psize; new_node-&gt;next = NULL; new_node-&gt;failed = 0; m += sizeof(struct mp_node_s); m = mp_align_ptr(m, MP_ALIGNMENT); new_node-&gt;last = m + size; current = pool-&gt;current; for(p = current; p-&gt;next; p = p-&gt;next) &#123; if (p-&gt;failed++ &gt; 4) &#123; current = p-&gt;next; &#125; &#125; p-&gt;next = new_node; pool-&gt;current = current ? current : new_node; return m;&#125;//分配大块内存static void *mp_alloc_large(struct mp_pool_s *pool, size_t size) &#123; void *p = malloc(size); if (p == NULL) return NULL; size_t n = 0; struct mp_large_s *large; for (large = pool-&gt;large; large; large = large-&gt;next) &#123; if (large-&gt;alloc == NULL) &#123; large-&gt;alloc = p; return p; &#125; if (n ++ &gt; 3) break; &#125; large = mp_alloc(pool, sizeof(struct mp_large_s)); if (large == NULL) &#123; free(p); return NULL; &#125; large-&gt;alloc = p; large-&gt;next = pool-&gt;large; pool-&gt;large = large; return p;&#125;//内存池分配void *mp_alloc(struct mp_pool_s *pool, size_t size) &#123; unsigned char *m; struct mp_node_s *p; if (size &lt;= pool-&gt;max) &#123; p = pool-&gt;current; do &#123; m = mp_align_ptr(p-&gt;last, MP_ALIGNMENT); if((size_t)(p-&gt;end - m) &gt;= size) &#123; p-&gt;last = m + size; return m; &#125; p = p-&gt;next; &#125; while (p); return mp_alloc_block(pool, size); &#125; return mp_alloc_large(pool, size);&#125;int main(int argc, char *argv[]) &#123; int size = 1 &lt;&lt; 12; struct mp_pool_s *p = mp_create_pool(size); int i = 0; for (i = 0;i &lt; 10;i ++) &#123; void *mp = mp_alloc(p, 512);// mp_free(mp); &#125; //printf(&quot;mp_create_pool: %ld\n&quot;, p-&gt;max); printf(&quot;mp_align(123, 32): %d, mp_align(17, 32): %d\n&quot;, mp_align(24, 32), mp_align(17, 32)); //printf(&quot;mp_align_ptr(p-&gt;current, 32): %lx, p-&gt;current: %lx, mp_align(p-&gt;large, 32): %lx, p-&gt;large: %lx\n&quot;, mp_align_ptr(p-&gt;current, 32), p-&gt;current, mp_align_ptr(p-&gt;large, 32), p-&gt;large); int j = 0; for (i = 0;i &lt; 5;i ++) &#123; char *pp = mp_calloc(p, 32); for (j = 0;j &lt; 32;j ++) &#123; if (pp[j]) &#123; printf(&quot;calloc wrong\n&quot;); &#125; printf(&quot;calloc success\n&quot;); &#125; &#125; //printf(&quot;mp_reset_pool\n&quot;); for (i = 0;i &lt; 5;i ++) &#123; void *l = mp_alloc(p, 8192); mp_free(p, l); &#125; mp_reset_pool(p); //printf(&quot;mp_destory_pool\n&quot;); for (i = 0;i &lt; 58;i ++) &#123; mp_alloc(p, 256); &#125; mp_destory_pool(p); return 0;&#125;]]></content>
      <categories>
        <category>基础</category>
      </categories>
      <tags>
        <tag>内存池</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[字符编码Unicode原理数据流压缩Zlib与Miniz的实现]]></title>
    <url>%2F2020%2F10%2F08%2F%E5%AD%97%E7%AC%A6%E7%BC%96%E7%A0%81Unicode%E5%8E%9F%E7%90%86%E6%95%B0%E6%8D%AE%E6%B5%81%E5%8E%8B%E7%BC%A9Zlib%E4%B8%8EMiniz%E7%9A%84%E5%AE%9E%E7%8E%B0%2F</url>
    <content type="text"><![CDATA[字符Unicode其实是根据码表转化映射出图形。根据码表找到位图文件显示出文字。 UTF-8 1-6字节UTF-16 2或4字节UTF-32 4字节 通过前缀码，编译器可以知道是这个文件是按什么格式编码的。 Mysql的“uft8”不是真正的UTF-8，“utf8”只支持每个字符最多3个字节。 Mysql真正的UTF-8是”utf8mb4”。]]></content>
      <categories>
        <category>基础</category>
      </categories>
      <tags>
        <tag>基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Golang 系统监控]]></title>
    <url>%2F2020%2F10%2F07%2FGolang-%E7%B3%BB%E7%BB%9F%E7%9B%91%E6%8E%A7%2F</url>
    <content type="text"><![CDATA[系统监控程序会定期的检查上次垃圾回收器什么时候执行的，如果发现已经有很长时间没有执行垃圾回收操作了，它就强制执行一次回收。 它来定期扫描自由内存块，如果长时间不用，它就会建议操作系统把物理内存收回去。 在函数头部插入一段汇编指令：第一件事用来判断栈帧空间够不够用，不够用进行扩张第二件事检查当前的G执行多长，如果系统调度发出抢占通知，立即中止G执行。]]></content>
      <categories>
        <category>基础</category>
      </categories>
      <tags>
        <tag>Golang</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Golang 并发]]></title>
    <url>%2F2020%2F10%2F07%2FGolang-%E5%B9%B6%E5%8F%91%2F</url>
    <content type="text"><![CDATA[PMG模型 第一本地队列超过 256 个任务转移一半任务到全局队列，第二本地队列执行 60 个任务则到全局队列执行一个确保公平性。 runnextG对象有runnext属性，记录最后一个G对象。执行 runnext 优先，然后 runq 队列。 栈内存M 的所有的状态都保存在 G 任务栈，优点是在任意时 M 都能上下文切换。 M 使用的栈保存在 G 栈上，切换时只需要把 M 使用的 SP 等寄存器保存到 G 的寄存器上，保存后 M 就可以上下文切换。 G 自带栈可以从 2KB 扩容到 1GB，那么怎么扩容呢？实际上重新分配两倍的内存，然后把数据拷贝进来，栈指针指向新的地址，原来的释放掉，称之为拷贝栈。收缩也一样，创建小一点的块，把数据拷贝进来，用它来替换原来的释放。]]></content>
      <categories>
        <category>基础</category>
      </categories>
      <tags>
        <tag>Golang</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[垃圾回收]]></title>
    <url>%2F2020%2F10%2F07%2F%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%2F</url>
    <content type="text"><![CDATA[引用计数引用计数实现方式非常简单，每个对象头部有一个计数器，引用对象时计数器加一，取消引用时计数器减一，等于零时释放内存。 缺点：1.易内存泄漏2.不支持循环引用 代龄代龄机制是这样的，对象通常分成三级代龄 0、1、2。新创建的对象的代龄是 0，每级代龄都有阈值，当 0 级对象数量超过阈值就会启动垃圾回收，垃圾回收扫描所有 0 级代龄对象，扫描完对象是活着或者死着两种状态。理论来说在第一次回收活着对象在第二次回收活着几率很高，垃圾回收器把第一次扫描活着对象标记为 1 级代龄对象，下次扫描 0 级代龄对象不用扫描第一次扫描过的对象，减少扫描对象的数量。当 1 级代龄对象数量超过阈值便扫描 1 级代龄对象，如果 1 级代龄还活着说明这个对象生命周期更长，就标记为 2 级代龄对象。 优点1：减少扫描对象数量优点2：支持内存压缩 标记清理回收器启动把所有对象标记成白色。A引用B，B变成灰色。白色可以释放。下次扫描灰色。B变成黑色，如果B引用C。C依然是灰色。不断递归，只剩黑色和白色。那么黑色的都是活着的白色的都是死的。 并发清理回收白色对象的时候可以和用户逻辑并发。 写屏障一旦进入垃圾回收状态时进行短暂 STW 暂停，打开标记位标记为正在执行垃圾回收。扫描当时状态。在垃圾回收阶段重新引用另外新对象，这个屏障把这种行为重新过滤。 信用授权回收的速度跟不上分配的速度垃圾回收器会把用户逻辑暂停，用户逻辑暂停后不会有新的对象出现。黑白对象标记完的对象数量累计到公共账户信用值，如果小于等于零则调度切换为垃圾回收，切换后不停的增加信用值和检查公共账户信用值，尽早提前结束切换执行用户代码，保证用户代码和垃圾回收的并行。]]></content>
      <categories>
        <category>基础</category>
      </categories>
      <tags>
        <tag>垃圾回收</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[内存分配器]]></title>
    <url>%2F2020%2F10%2F07%2F%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E5%99%A8%2F</url>
    <content type="text"><![CDATA[为了避免程序频繁的向操作系统申请，占用更多的空间延长内存的使用时间。可以一次性申请多一部分的内存重复使用。例如：对象池、连接池。并且一次性申请大块内存可以做到连续分配，通过相邻的地址空间的合并减少碎片化。 虚拟地址空间如何使用每个进程有一个虚拟地址空间，内存分配在某段虚拟地址空间内就能保证是连续的。 1.让操作系统随机开始，保留一段地址空间，如果失败，加上或者减去偏移量重新选择。2.如果连续的方式不行使用分段的方式。空间扩展尝试同一方向扩展，失败则换个相反方向扩展，这样空间还是连续的。操作系统随机从两个方向扩展的方式称之为稀疏堆。3.使用一个数组。数组存储内存指针指向自由块，自由块有各种状态，比如当前使用多少内存、是否是空闲状态等，形成类似反查表的作用。自由块的内存起始地址减去初始位置得到偏移量，偏移量按页大小对齐作为数组索引。这样的优点是只需检查数组就知道内存分配的信息、检查相邻的两项的是否空闲可以合并成大块内存。通过反查表实现碎片化问题。 Go管理内存框架 内存分配的完整流程首先检查 Cache 里有没有自由块，有的话直接返回；没有的话计算向哪个 Central 申请，如果 Central 有则取回一批，如果没有，则向Heap申请大块自由块切割，如果Heap没有多余的自由块，Heap向操作系统申请。Go语言在初始化时建立一个静态表，通过静态表知道一次取多少个，这个数字是基于大量的统计得到的，有些语言根据程序运行期动态调整这个数字。 任何时候内存管理都会涉及两个核心问题。 第一个快速分配，比如实现无锁操作或者减少锁。因为 Central 被很多Cache共享，操作数据必须加锁处理，Heap 被很多 Central 共享，操作数据要加锁。 第二个尽可能在内存复用方面做到平衡。快速操作意味着用批处理代替单次处理实现性能提升，但是批处理会浪费大量的资源。所以一来用批处理来实现快速分配操作的性能，一来实现内存节约避免快速消耗，需要在中间找到平衡点。]]></content>
      <categories>
        <category>基础</category>
      </categories>
      <tags>
        <tag>内存</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[线程池]]></title>
    <url>%2F2020%2F10%2F07%2F%E7%BA%BF%E7%A8%8B%E6%B1%A0%2F</url>
    <content type="text"><![CDATA[123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#include &lt;assert.h&gt;#include &lt;stdarg.h&gt;#include &lt;pthread.h&gt;#define LL_ADD(item, list) do &#123; \ item-&gt;prev = NULL; \ item-&gt;next = list; \ list = item; \&#125; while(0)#define LL_REMOVE(item, list) do &#123; \ if (item-&gt;prev != NULL) item-&gt;prev-&gt;next = item-&gt;next; \ if (item-&gt;next != NULL) item-&gt;next-&gt;prev = item-&gt;prev; \ if (list == item) list = item-&gt;next; \ item-&gt;prev = item-&gt;next = NULL; \&#125; while(0)//执行（线程ID，终止标识，池管理组件对象）typedef struct NWORKER &#123; pthread_t thread; int terminate; struct NWORKQUEUE *workqueue; struct NWORKER *prev; struct NWORKER *next;&#125; nWorker;//任务（任务回调函数，任务执行的参数）typedef struct NJOB &#123; void (*job_function)(struct NJOB *job); void *user_data; struct NJOB *prev; struct NJOB *next;&#125; nJob;//池管理组件（互斥锁，条件变量，执行队列，任务队列）typedef struct NWORKQUEUE &#123; struct NWORKER *workers; struct NJOB *waiting_jobs; pthread_mutex_t jobs_mtx; pthread_cond_t jobs_cond;&#125; nWorkQueue;typedef nWorkQueue nThreadPool;static void *ntyWorkerThread(void *ptr) &#123; nWorker *worker = (nWorker*)ptr; while (1) &#123; pthread_mutex_lock(&amp;worker-&gt;workqueue-&gt;jobs_mtx); while (worker-&gt;workqueue-&gt;waiting_jobs == NULL) &#123; if (worker-&gt;terminate) break; pthread_cond_wait(&amp;worker-&gt;workqueue-&gt;jobs_cond, &amp;worker-&gt;workqueue-&gt;jobs_mtx); &#125; if (worker-&gt;terminate) &#123; pthread_mutex_unlock(&amp;worker-&gt;workqueue-&gt;jobs_mtx); break; &#125; nJob *job = worker-&gt;workqueue-&gt;waiting_jobs; if (job != NULL) &#123; LL_REMOVE(job, worker-&gt;workqueue-&gt;waiting_jobs); &#125; pthread_mutex_unlock(&amp;worker-&gt;workqueue-&gt;jobs_mtx); if (job == NULL) continue; job-&gt;job_function(job); &#125; free(worker); pthread_exit(NULL);&#125;int ntyThreadPoolCreate(nThreadPool *workqueue, int numWorkers) &#123; if (numWorkers &lt; 1) numWorkers = 1; memset(workqueue, 0, sizeof(nThreadPool)); pthread_cond_t blank_cond = PTHREAD_COND_INITIALIZER; memcpy(&amp;workqueue-&gt;jobs_cond, &amp;blank_cond, sizeof(workqueue-&gt;jobs_cond)); pthread_mutex_t blank_mutex = PTHREAD_MUTEX_INITIALIZER; memcpy(&amp;workqueue-&gt;jobs_mtx, &amp;blank_mutex, sizeof(workqueue-&gt;jobs_mtx)); int i = 0; for (i = 0;i &lt; numWorkers;i ++) &#123; nWorker *worker = (nWorker*)malloc(sizeof(nWorker)); if (worker == NULL) &#123; perror(&quot;malloc&quot;); return 1; &#125; memset(worker, 0, sizeof(nWorker)); worker-&gt;workqueue = workqueue; //printf(&quot;pthread_create --&gt; %d\n&quot;, i); int ret = pthread_create(&amp;worker-&gt;thread, NULL, ntyWorkerThread, (void *)worker); if (ret) &#123; perror(&quot;pthread_create&quot;); free(worker); return 1; &#125; LL_ADD(worker, worker-&gt;workqueue-&gt;workers); &#125; return 0;&#125;void ntyThreadPoolShutdown(nThreadPool *workqueue) &#123; nWorker *worker = NULL; for (worker = workqueue-&gt;workers;worker != NULL;worker = worker-&gt;next) &#123; worker-&gt;terminate = 1; &#125; pthread_mutex_lock(&amp;workqueue-&gt;jobs_mtx); workqueue-&gt;workers = NULL; workqueue-&gt;waiting_jobs = NULL; pthread_cond_broadcast(&amp;workqueue-&gt;jobs_cond); pthread_mutex_unlock(&amp;workqueue-&gt;jobs_mtx); &#125;void ntyThreadPoolQueue(nThreadPool *workqueue, nJob *job) &#123; pthread_mutex_lock(&amp;workqueue-&gt;jobs_mtx); LL_ADD(job, workqueue-&gt;waiting_jobs); pthread_cond_signal(&amp;workqueue-&gt;jobs_cond); pthread_mutex_unlock(&amp;workqueue-&gt;jobs_mtx); &#125;#define KING_MAX_THREAD 80#define KING_COUNTER_SIZE 1000void king_counter(nJob *job) &#123; int index = *(int*)job-&gt;user_data; printf(&quot;index : %d, selfid : %lu\n&quot;, index, pthread_self()); free(job-&gt;user_data); free(job);&#125;int main(int argc, char *argv[]) &#123; nThreadPool pool; ntyThreadPoolCreate(&amp;pool, KING_MAX_THREAD); int i = 0; for (i = 0;i &lt; KING_COUNTER_SIZE;i ++) &#123; nJob *job = (nJob*)malloc(sizeof(nJob)); if (job == NULL) &#123; perror(&quot;malloc&quot;); exit(1); &#125; job-&gt;job_function = king_counter; job-&gt;user_data = malloc(sizeof(int)); *(int*)job-&gt;user_data = i; ntyThreadPoolQueue(&amp;pool, job); &#125; getchar(); printf(&quot;\n&quot;); &#125;]]></content>
      <categories>
        <category>基础</category>
      </categories>
      <tags>
        <tag>线程池</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[无锁CAS无锁队列]]></title>
    <url>%2F2020%2F10%2F07%2F%E6%97%A0%E9%94%81CAS%E6%97%A0%E9%94%81%E9%98%9F%E5%88%97%2F</url>
    <content type="text"><![CDATA[#include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;pthread.h&gt; #include &lt;mutex&gt; #include &lt;time.h&gt; #include &lt;atomic&gt; #include &lt;list&gt; #include &lt;memory&gt; #define MAX_THREAD_NUM 1 #define FOR_LOOP_COUNT 10000000 static int counter = 0; static pthread_spinlock_t spinlock; static std::mutex s_mutex; static int s_count_push = 0; static int s_count_pop = 0; // using namespace lock_free; // 有锁队列，直接使用list static std::list&lt;int&gt; s_list; typedef void *(*thread_func_t)(void *argv); static int lxx_atomic_add(int *ptr, int increment) { int old_value = *ptr; __asm__ volatile(&quot;lock; xadd %0, %1 \n\t&quot; : &quot;=r&quot;(old_value), &quot;=m&quot;(*ptr) : &quot;0&quot;(increment), &quot;m&quot;(*ptr) : &quot;cc&quot;, &quot;memory&quot;); return *ptr; } template &lt;typename ElemType&gt; struct qnode // 链表节点 { struct qnode *_next; ElemType _data; }; template &lt;typename ElemType&gt; class Queue { private: struct qnode&lt;ElemType&gt; *volatile _head = NULL; // 随着pop后指向的位置是不一样的, head不是固定的 struct qnode&lt;ElemType&gt; *volatile _tail = NULL; public: Queue() { _head = _tail = new qnode&lt;ElemType&gt;; _head-&gt;_next = NULL; _tail-&gt;_next = NULL; printf(&quot;Queue _head:%p\n&quot;, _head); } void push(const ElemType &amp;e) { struct qnode&lt;ElemType&gt; *p = new qnode&lt;ElemType&gt;; p-&gt;_data = e; p-&gt;_next = NULL; struct qnode&lt;ElemType&gt; *t = _tail; // 获取尾部 t-&gt;_next = p; // 插到尾部 _tail = p; // 更新尾部节点 } void push2(const ElemType &amp;e) { struct qnode&lt;ElemType&gt; *p = new qnode&lt;ElemType&gt;; // printf(&quot;push head:%p, p:%p\n&quot;, _head, p); p-&gt;_next = NULL; p-&gt;_data = e; struct qnode&lt;ElemType&gt; *t = _tail; struct qnode&lt;ElemType&gt; *old_t = _tail; int count = 0; do { while (t-&gt;_next != NULL) // 非空的时候要去更新 t-&gt;_next t = t-&gt;_next; // 找到最后的节点 if (count++ &gt;= 1) { printf(&quot;push count:%d, t-&gt;_next:%p\n&quot;, count, t-&gt;_next); } // 将null换为p即是插入的节点 } while (!__sync_bool_compare_and_swap(&amp;t-&gt;_next, NULL, p)); // 将最后的节点_tail更换为p节点 __sync_bool_compare_and_swap(&amp;_tail, old_t, p); } bool pop(ElemType &amp;e) { struct qnode&lt;ElemType&gt; *p = _head; // 头结点 struct qnode&lt;ElemType&gt; *np = _head-&gt;_next; // 首元素节点 if (!np) { return false; } e = np-&gt;_data; _head-&gt;_next = np-&gt;_next; delete np; return true; } bool pop2(ElemType &amp;e) { struct qnode&lt;ElemType&gt; *p = NULL; struct qnode&lt;ElemType&gt; *np = NULL; int count = 0; do { p = _head; // 头节点，不真正存储数据 np = p-&gt;_next; if (p-&gt;_next == NULL) // 首元节点为空，则返回 { return false; } if (count++ &gt;= 1) { printf(&quot;pop count:%d, p-&gt;_next:%p\n&quot;, count, p-&gt;_next); } // 更新头结点位置 } while (!__sync_bool_compare_and_swap(&amp;_head, p, p-&gt;_next)); e = p-&gt;_next-&gt;_data; // printf(&quot;pop p:%p\n&quot;, p); delete p; // 因为我们已经将头部节点换成了p-&gt;_next, 所以可以释放掉 return true; } ~Queue() { struct qnode&lt;ElemType&gt; *volatile tmp; while (_head) { tmp = _head-&gt;_next; printf(&quot;_head:%p\n&quot;, _head); delete _head; _head = tmp; } } }; void *mutex_thread_push(void *argv) { for (int i = 0; i &lt; FOR_LOOP_COUNT; i++) { s_mutex.lock(); s_count_push++; s_list.push_back(i); s_mutex.unlock(); } return NULL; } void *mutex_thread_pop(void *argv) { while (true) { int value = 0; s_mutex.lock(); if (s_list.size() &gt; 0) { value = s_list.front(); s_list.pop_front(); s_count_pop++; } s_mutex.unlock(); if (s_count_pop &gt;= FOR_LOOP_COUNT * MAX_THREAD_NUM) { printf(&quot;%s dequeue:%d\n&quot;, __FUNCTION__, value); break; } } printf(&quot;%s exit\n&quot;, __FUNCTION__); return NULL; } static Queue&lt;int&gt; s_queue; void *queue_free_thread_push(void *argv) { for (int i = 0; i &lt; FOR_LOOP_COUNT; i++) { s_queue.push2(i); lxx_atomic_add(&amp;s_count_push, 1); // printf(&quot;s_count_push:%d\n&quot;,s_count_push); } return NULL; } void *queue_free_thread_pop(void *argv) { // for (int i = 0; i &lt; FOR_LOOP_COUNT*5; i++) int last_value = 0; static int s_pid_count = 0; s_pid_count++; int pid = s_pid_count; while (true) { int value = 0; if (s_queue.pop2(value)) { last_value = value; if (s_count_pop != value) { printf(&quot;pid:%d, -&gt; value:%d, expected:%d\n&quot;, pid, value, s_count_pop); } s_count_pop++; // printf(&quot;pid:%d, -&gt; value:%d\n&quot;, pid, value); } else { // printf(&quot;pid:%d, null\n&quot;, pid); } if (s_count_pop &gt;= FOR_LOOP_COUNT * MAX_THREAD_NUM) { printf(&quot;%s dequeue:%d\n&quot;, __FUNCTION__, last_value); break; } } printf(&quot;%s exit\n&quot;, __FUNCTION__); return NULL; } int test_queue(thread_func_t func_push, thread_func_t func_pop, char **argv) { clock_t start = clock(); pthread_t tid_push[MAX_THREAD_NUM] = {0}; for (int i = 0; i &lt; MAX_THREAD_NUM; i++) { int ret = pthread_create(&amp;tid_push[i], NULL, func_push, argv); if (0 != ret) { printf(&quot;create thread failed\n&quot;); } } pthread_t tid_pop[MAX_THREAD_NUM] = {0}; for (int i = 0; i &lt; MAX_THREAD_NUM; i++) { int ret = pthread_create(&amp;tid_pop[i], NULL, func_pop, argv); if (0 != ret) { printf(&quot;create thread failed\n&quot;); } } for (int i = 0; i &lt; MAX_THREAD_NUM; i++) { pthread_join(tid_push[i], NULL); } for (int i = 0; i &lt; MAX_THREAD_NUM; i++) { pthread_join(tid_pop[i], NULL); } clock_t end = clock(); printf(&quot;spend clock : %ld, push:%d, pop:%d\n&quot;, (end - start) / CLOCKS_PER_SEC, s_count_push, s_count_pop); return 0; } // 多尝试几次 g++ -o 4_test_queue 4_test_queue.cpp -lpthread -latomic -std=c++11 int main(int argc, char **argv) { printf(&quot;THREAD_NUM:%d\n\n&quot;, MAX_THREAD_NUM); for (int i = 0; i &lt; 100; i++) { s_count_push = 0; s_count_pop = 0; printf(&quot;\n\n---------&gt;i:%d\n\n&quot;, i); printf(&quot;use mutex queue -----------&gt;\n&quot;); test_queue(mutex_thread_push, mutex_thread_pop, NULL); s_count_push = 0; s_count_pop = 0; printf(&quot;\nuse queue_free queue -----------&gt;\n&quot;); test_queue(queue_free_thread_push, queue_free_thread_pop, NULL); } printf(&quot;finish\n&quot;); return 0; }]]></content>
      <categories>
        <category>基础</category>
      </categories>
      <tags>
        <tag>CAS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[进程协程线程]]></title>
    <url>%2F2020%2F09%2F27%2F%E8%BF%9B%E7%A8%8B%E5%8D%8F%E7%A8%8B%E7%BA%BF%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[进程是一种资源单位，操作系统按照进程来分配资源管理资源。线程是进程内的，专门用来执行。 线程线程我们严格意义上来说指的是任务加上任务执行所需的资源，称之为线程，如果线程只是执行单位没有任何资源，称之为任务，它是可复用的，线程本身有状态的，因为线程执行时有线程栈，所以任务加上任务执行所需的线程栈等资源称之为线程。 系统线程与用户线程 系统线程指的是操作系统提供的的任务单元。用户线程指的是在用户空间实现的一些并发任务，跟操作系统没关系。 线程池模型使用池模型不再需要频繁的创建系统线程，用户态可以创建很多用来存储状态的执行单位。执行时把它绑定到一个系统线程上去执行，执行完把系统线程释放，系统线程把绑定状态删除放到池中，不需要杀掉系统线程，接下来另外一个执行单位重新的绑定到这个系统线程上去执行。 如下图所示： 首先创建一定数量的系统线程专门用来执行的。其次在用户态空间创建一些对象专门用来保存执行时所需要的状态，包括线程栈。它不负责执行，它只是很普通的数据抽象容器。它执行时把它绑定到某个系统线程上，这个系统线程就具备了普通线程状态然后去执行，执行完把这个线程的状态全部剥离，这个线程就恢复成原始状态，接下来可以执行其他的任务。 实现用户态的执行和系统态的执行分离，避免反复系统调用所消耗的资源。 协程为了充分利用时间片，利用异步机制，在用户态实现调度机制把阻塞的时间片执行其他的任务，当任务执行完成时，下次再执行时去检查返回的事件，把事件返回的结果返还给原先任务。 很明显，协程是串行不是并行，它的执行序是执行 A 任务，当 A 任务阻塞时唤醒 B 任务，B 任务执行结束检查 A 的结果是否有返回，不断的切换实现多任务并发。 上下文切换对性能的影响无论进程级别、线程级别、主动系统调用引发的上下文切换都会造成一定的性能损失。尽可能的减少系统调用实际上是减少上下文切换造成的性能损失。因为离 CPU 近的资源比如 L 级的 Cache，寄存器数据都要写回到主存，系统代码执行完要把主存数据读回来，相对 CPU 执行速度从主存操作数据非常慢。]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式]]></title>
    <url>%2F2020%2F09%2F26%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[策略模式策略模式定义了算法族，分别封装起来，让他们之间可以互相替换，此模式让算法的变化独立于使用算法的客户。 装饰器模式装饰器模式中主要有两个角色： 1.装饰器 2.被装饰的对象 12345678910111213141516171819202122老王（ 被装饰的对象 ）：public interface Person &#123; /** * 计算累计消费 * @return */ public Double cost(); public void show();&#125;public class LaoWang implements Person&#123; @Override public Double cost() &#123; return 0.0; //赤果果的时候累计消费为0 &#125; @Override public void show() &#123; System.out.println(&quot;我是赤果果的老王&quot;); &#125;&#125; 12345678910装饰器超类，和被装饰的对象实现同一个接口 Person ：public abstract class ClothesDecorator implements Person &#123; //装饰器中要使用被装饰器的对象，构造方法中传入 protected Person person; public ClothesDecorator(Person person)&#123; this.person = person; &#125;&#125; 123456789101112131415161718192021222324252627282930313233343536具体的装饰，夹克和帽子：public class Jacket extends ClothesDecorator &#123; public Jacket(Person person) &#123; super(person); &#125; @Override public void show() &#123; person.show(); System.out.println(&quot;穿上夹克，累计消费&quot; + this.cost()); &#125; @Override public Double cost() &#123; return person.cost() + 100; //夹克100元 &#125;&#125;public class Hat extends ClothesDecorator &#123; public Hat(Person person) &#123; super(person); &#125; @Override public void show() &#123; //执行已有功能 person.show(); //此处是附加的功能 System.out.println(&quot;戴上帽子，累计消费&quot; + this.cost()); &#125; @Override public Double cost() &#123; return person.cost() + 50; //帽子50元 &#125;&#125; 123456789测试：Person laowang = new LaoWang();//穿上夹克laowang = new Jacket(laowang);//戴上帽子laowang = new Hat(laowang);laowang.show();System.out.println(&quot;买单，老王总共消费：&quot;+laowang.cost()); 观察者模式观察者模式定义了对象之间的一对多依赖，这样一来，当一个对象改变状态时，它的所有依赖者都会收到通知并自动更新。 123456789101112131415161718观察者（客户）:public abstract class Customer &#123; public abstract void update();&#125;public class CustomerA extends Customer &#123; @Override public void update() &#123; System.out.println(&quot;我是客户A,我收到报纸啦&quot;); &#125;&#125;public class CustomerB extends Customer &#123; @Override public void update() &#123; System.out.println(&quot;我是客户B,我收到报纸啦&quot;); &#125;&#125; 12345678910111213141516171819被观察者（报社）：public class NewsOffice &#123; private List&lt;Customer&gt; customers = new ArrayList&lt;&gt;(); public void addCustomer(Customer customer)&#123; this.customers.add(customer); &#125; //模拟报纸来了 public void newspaperCome()&#123; this.notifyAllObservers(); &#125; public void notifyAllObservers()&#123; for (Customer customer : customers)&#123; customer.update(); &#125; &#125;&#125; 1234567891011测试：NewsOffice office= new NewsOffice();Customer customerA = new CustomerA();Customer customerB = new CustomerB();//客户A订阅报纸office.addCustomer(customerA);//客户B订阅报纸office.addCustomer(customerB);//报纸来了office.newspaperCome(); 适配器模式适配器适合用于解决新旧系统（ 或新旧接口 ）之间的兼容问题，而不建议在一开始就直接使用。 123456789定义接口：public interface MusicPlayer &#123; /** * 播放音乐 * @param type 音乐格式 * @param filename 文件 */ public void play(String type, String filename);&#125; 123456789101112现成的库：public class ExistPlayer &#123; public void playMp3(String filename)&#123; System.out.println(&quot;play mp3 : &quot;+filename); &#125; public void playWma(String filename)&#123; System.out.println(&quot;play wma : &quot;+filename); &#125;&#125; 123456789101112131415161718public class PlayerAdapter implements MusicPlayer&#123; //在适配器中使用旧接口 private ExistPlayer player; public PlayerAdapter()&#123; player = new ExistPlayer(); &#125; @Override public void play(String type, String filename) &#123; if(type == &quot;mp3&quot;)&#123; player.playMp3(filename); &#125;else if(type == &quot;wma&quot;)&#123; player.playWma(filename); &#125; &#125;&#125; 1234测试： MusicPlayer player = new PlayerAdapter(); player.play(&quot;mp3&quot;,&quot;xxx.mp3&quot;); player.play(&quot;mp4&quot;,&quot;xxx.mp4&quot;); 单例模式与工厂模式单例模式懒汉式：12345678910111213public class SingleObject &#123; private static SingleObject instance; private SingleObject()&#123;&#125; public static SingleObject getInstance()&#123; if(instance == null)&#123; instance = new SingleObject(); &#125; return instance; &#125;&#125; 解决线程安全问题：12345678910111213public class SingleObject &#123; private static SingleObject instance; private SingleObject()&#123;&#125; public static synchronized SingleObject getInstance()&#123; if(instance == null)&#123; instance = new SingleObject(); &#125; return instance; &#125;&#125; Not Lazy Loading：12345678910public class SingleObject &#123; private static SingleObject instance = new SingleObject(); private SingleObject()&#123;&#125; public static SingleObject getInstance()&#123; return instance; &#125;&#125; 工厂模式简单工厂模式1234567891011121314public class Factory &#123; public Girl createGirl(String whatYouLike)&#123; Girl girl = null; if(whatYouLike == &quot;fat&quot;)&#123; girl = new FatGirl(); &#125;else if(whatYouLike == &quot;thin&quot;)&#123; girl = new ThinGirl(); &#125; return girl; &#125;&#125; 12测试:Girl girl = (new GirlFactory()).createGirl(&quot;fat&quot;); 工厂提供者1234567891011121314151617public class GirlStore &#123; GirlFactory factory; /** * 可以动态选择工厂 * @param factory */ public GirlStore(GirlFactory factory)&#123; this.factory = factory; &#125; public Girl createGirl(String whatYouLike)&#123; return factory.createGirl(whatYouLike); &#125;&#125; 123测试：GirlStore store = new GirlStore(new GirlFactory());store.createGirl(&quot;thin&quot;); 抽象工厂模式 某某程序猿现在不满足于选择 Girl 的胖瘦，他的口味有点特殊，喜欢美国产的长发姑娘，遵循开闭原则，我们需要使用抽象工厂 抽象工厂：123456789public abstract class AbstractGirlFactory &#123; /** * * @param whatYouLike 高矮胖瘦等类型 * @return */ public abstract Girl createGirl(String whatYouLike);&#125; 美国工厂：1234567891011121314public class AmericanGirlFactory extends AbstractGirlFactory&#123; @Override public Girl createGirl(String whatYouLike) &#123; Girl girl = null; if(whatYouLike == &quot;fat&quot;)&#123; girl = new FatGirl(); &#125;else if(whatYouLike == &quot;thin&quot;)&#123; girl = new ThinGirl(); &#125; return girl; &#125;&#125; 中国工厂：1234567891011public class ChineseGirlFactory extends AbstractGirlFactory&#123; @Override public Girl createGirl(String whatYouLike) &#123; Girl girl = null; if(whatYouLike.equals(&quot;longhair&quot;))&#123; //girl = new LongHairGirl(); &#125; return girl; &#125;&#125; 工厂提供者：1234567891011121314151617181920public class GirlStore &#123; AbstractGirlFactory factory; /** * 可以动态选择工厂 * @param factory */ public GirlStore(AbstractGirlFactory factory)&#123; this.factory = factory; &#125; public Girl createGirl(String whatYouLike)&#123; return factory.createGirl(whatYouLike); &#125; //也可以返回工厂，让客户端自己去createGirl() //public abstract AbstractGirlFactory createFactory(String country);&#125; 客户端调用：12GirlStore store = new GirlStore(new AmericanGirlFactory());Girl girl = store.createGirl(&quot;longhair&quot;); 外观模式123456789101112131415161718//CPUpublic class CPU &#123; public void start()&#123; System.out.println(&quot;启动CPU&quot;); &#125;&#125;//硬盘public class Disk &#123; public void start()&#123; System.out.println(&quot;启动硬盘&quot;); &#125;&#125;//内存public class Memory &#123; public void start()&#123; System.out.println(&quot;启动内存&quot;); &#125;&#125; 123456789//开机键public class StartBtn &#123; public void start()&#123; new CPU().start(); new Disk().start(); new Memory().start(); &#125;&#125; 1new StartBtn().start(); 代理模式12345678910111213141516171819202122232425262728293031323334353637383940414243444546public class LazyLoadList&lt;E&gt; implements List &#123; /** * 关联外键 */ private Integer key; private boolean hasSelect = false; public LazyLoadList(Integer key)&#123; this.key = key; &#125; private List list = new ArrayList(); /** * 真正查询数据库 */ private void doSelect()&#123; //已查询过不用再查询 if(hasSelect) return; System.out.println(&quot;开始查询&quot;); String sql = &quot; select * from address where user_id = &quot; + this.key; // sql查询 //使用反射，注解等机制组装查询结果，此处模拟一下即可 list.add(new Address(&quot;地址1&quot;)); list.add(new Address(&quot;地址2&quot;)); hasSelect = true; &#125; @Override public int size() &#123; this.doSelect(); return list.size(); &#125; @Override public Object get(int index) &#123; this.doSelect(); return list.get(index); &#125;&#125; 责任链模式论坛用户发表帖子，但是常常会有用户发一些不良的信息，如广告信息、涉黄信息、涉及政治的敏感词等。这时我们就可以使用责任链模式来过滤用户发表的信息。 父类：12345678910111213141516171819202122/** * 帖子处理器 */public abstract class PostHandler &#123; /** * 后继者 */ protected PostHandler successor; public void setSuccessor(PostHandler handler)&#123; this.successor = handler; &#125; public abstract void handlerRequest(Post post); protected final void next(Post post)&#123; if(this.successor != null)&#123; this.successor.handlerRequest(post); &#125; &#125;&#125; 123456789101112131415161718/** * 广告处理器 */public class AdHandler extends PostHandler &#123; @Override public void handlerRequest(Post post) &#123; //屏蔽广告内容 String content = post.getContent(); //..... content = content.replace(&quot;广告&quot;,&quot;**&quot;); post.setContent(content); System.out.println(&quot;过滤广告...&quot;); //传递给下一个处理器 next(post); &#125;&#125; 123456789101112131415161718/** * 涉黄处理器 */public class YellowHandler extends PostHandler &#123; @Override public void handlerRequest(Post post) &#123; //屏蔽涉黄内容 String content = post.getContent(); //..... content = content.replace(&quot;涉黄&quot;,&quot;**&quot;); post.setContent(content); System.out.println(&quot;过滤涉黄内容...&quot;); //传递给下一个处理器 next(post); &#125;&#125; 1234567891011121314151617//创建责任对象PostHandler adHandler = new AdHandler();PostHandler yellowHandler = new YellowHandler();PostHandler swHandler = new SensitiveWordsHandler();//形成责任链yellowHandler.setSuccessor(swHandler);adHandler.setSuccessor(yellowHandler);Post post = new Post();post.setContent(&quot;我是正常内容，我是广告，我是涉黄，我是敏感词，我是正常内容&quot;);System.out.println(&quot;过滤前的内容为：&quot;+post.getContent());post = adHandler.handlerRequest(post);System.out.println(&quot;过滤后的内容为：&quot;+post.getContent());]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[http]]></title>
    <url>%2F2020%2F09%2F26%2Fhttp%2F</url>
    <content type="text"><![CDATA[简介HTTP 协议，即超文本传输协议(Hypertext transfer protocol)。是一种详细规定了浏览器和万维网(WWW = World Wide Web)服务器之间互相通信的规则，通过因特网传送万维网文档的数据传送协议，可以传输文本，图片，视频等。 简单快速：协议简单，通信速度快；灵活：HTTP 允许传输任意类型的数据对象。正在传输的类型由 Content-Type 加以标记；无状态：：HTTP 协议是无状态协议。无状态是指协议对于事务处理没有记忆能力。缺少状态意味着如果后续处理需要前面的信息，则它必须重传，这样可能导致每次连接传送的数据量增大。另一方面，在服务器不需要先前信息时它的应答就较快。 http工作原理以下是 HTTP 请求/响应的步骤：1、客户端连接到 Web 服务器一个 HTTP 客户端，通常是浏览器，与 Web 服务器的 HTTP 端口（默认为 80）建立一个 TCP套接字连接。例如，http://www.0voice.com。2、发送 HTTP 请求通过 TCP 套接字，客户端向 Web 服务器发送一个文本的请求报文，一个请求报文由请求行、请求头部、空行和请求数据 4 部分组成。3、服务器接受请求并返回 HTTP 响应Web 服务器解析请求，定位请求资源。服务器将资源复本写到 TCP 套接字，由客户端读取。一个响应由状态行、响应头部、空行和响应数据 4 部分组成。4、释放连接 TCP 连接若 connection 模式为 close，则服务器主动关闭 TCP 连接，客户端被动关闭连接，释放 TCP连接;若 connection 模式为 keepalive，则该连接会保持一段时间，在该时间内可以继续接收请求;5、客户端浏览器解析 HTML 内容客户端浏览器首先解析状态行，查看表明请求是否成功的状态代码。然后解析每一个响应头，响应头告知以下为若干字节的 HTML 文档和文档的字符集。客户端浏览器读取响应数据HTML，根据 HTML 的语法对其进行格式化，并在浏览器窗口中显示。 http请求方法根据 HTTP 标准，HTTP 请求可以使用多种请求方法。HTTP1.0 定义了三种请求方法: GET、POST 和 HEAD 方法。HTTP1.1 新增了六种请求方法: OPTIONS、PUT、PATCH、DELETE、TRACE 和 CONNECT 方法。 1 GET 请求指定的页面信息，并返回实体主体。2 HEAD 类似于 GET 请求，只不过返回的响应中没有具体的内容，用于获取报头3 POST 向指定资源提交数据进行处理请求（例如提交表单或者上传文件）。数据被包含在请求体中。POST 请求可能会导致新的资源的建立和/或已有资源的修改。4 PUT 从客户端向服务器传送的数据取代指定的文档的内容。5 DELETE 请求服务器删除指定的页面。6 CONNECT HTTP/1.1 协议中预留给能够将连接改为管道方式的代理服务器。7 OPTIONS 允许客户端查看服务器的性能。8 TRACE 回显服务器收到的请求，主要用于测试或诊断。9 PATCH 是对 PUT 方法的补充，用来对已知资源进行局部更新 。 GET和POST区别1、GET 提交的数据会放在 URL 之后，以?分割 URL 和传输数据，参数之间以&amp;相连，如http://localhost:8600/user?name=test1&amp;id=123456. POST 方法是把提交的数据放在 HTTP包的 Body 中。2、GET 提交的数据大小有限制（因为浏览器对 URL 的长度有限制），而 POST 方法提交的数据没有限制。3、GET 方式需要使用 Request.QueryString 来取得变量的值，而 POST 方式通过 Request.Form来获取变量的值。4、GET 方式提交数据，会带来安全问题，比如一个登录页面，通过 GET 方式提交数据时，用户名和密码将出现在 URL 上，如果页面可以被缓存或者其他人可以访问这台机器，就可以从历史记录获得该用户的账号和密码。 http响应头信息 http状态码状态代码有三位数字组成，第一个数字定义了响应的类别，共分五种类别:1xx：指示信息–表示请求已接收，继续处理2xx：成功–表示请求已被成功接收、理解、接受3xx：重定向–要完成请求必须进行更进一步的操作4xx：客户端错误–请求有语法错误或请求无法实现5xx：服务器端错误–服务器未能实现合法的请求]]></content>
      <categories>
        <category>http</category>
      </categories>
      <tags>
        <tag>http</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[nginx]]></title>
    <url>%2F2020%2F09%2F24%2Fnginx%2F</url>
    <content type="text"><![CDATA[负载均衡可以在多个层上去做，nginx只是在应用层上面的负载均衡。 初识从配置入手 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647worker_processes 4; ##进程数events &#123; worker_connections 1024; #连接数&#125;http &#123; upstream backend &#123; #负载均衡 server 192.168.142.128 weight=2; server 192.168.142.129 weight=1; &#125; server &#123; listen 8888; server_name localhost; client_max_body_size 100m; #客户端最大包体 location / &#123;# root /usr/local/nginx/html/;# proxy_pass http://192.168.142.128; proxy_pass http://backend; &#125; location /images/ &#123; root /usr/local/nginx/; #静态资源映射 &#125; location ~ \.(mp3|mp4) &#123; root /usr/local/nginx/media/; &#125; &#125; server &#123; listen 9000; location ~ \.cgi &#123; fastcgi_pass 127.0.0.1:9001; fastcgi_index index.cgi; fastcgi_param SCRIPT_FILENAME cgi$fastcgi_script_name; include ../conf/fastcgi_params; &#125; &#125; &#125; cgi应用于在线编程工具，通过nginx映射到cgi端口，实际上并没有进入Server服务器，只是在cgi进程做的处理。fastcgi用进程池去处理。]]></content>
      <categories>
        <category>nginx</category>
      </categories>
      <tags>
        <tag>nginx</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mysql]]></title>
    <url>%2F2020%2F09%2F22%2Fmysql%2F</url>
    <content type="text"><![CDATA[数值类型 事务特征事务四大特征：原子性（Atomicity，或称不可分割性）、一致性（Consistency）、隔离性（Isolation，又称独立性）、持久性（Durability）。一致性：数据库在操作前和操作后，完整性不被破坏。隔离性：多个事务可以同时执行，防止多个事务并发执行引起交叉执行数据不一致。持久性：事务结束后，对数据的修改是永久的。 隔离级别（1）读未提交：read uncommitted（2）读已提交：read committed（3）可重复读：repeatable read（4）串行化：serializable undolog每一个事务都有undolog，事务开启时一个临时表存事务的操作，这个临时表就是undolog，一旦有错误就X掉这次事务。 优化四条从效果上第一条影响最大，后面越来越小。① SQL语句及索引的优化 ② 数据库表结构的优化③ 系统配置的优化④ 硬件的优化 锁表级锁行级锁页级锁 引擎Myisam(表级锁) Innodb(行级锁)1.为什么Myisam快？因为Myisam B+树存的是引用，加载到内存快。 等Innodb加载完，Myisam都查完了2.为什么Innodb不支持全文索引？数据直接在叶子结点上，如果要全文索引，相当于复制了一份数据库，浪费空间 binlog binlog实际是除了select以外所有操作数据库动作的记录，方便恢复数据库。master主动推送到slave结点的relay log，从结点io线程去读relay log然后在sql线程去更新数据库。]]></content>
      <categories>
        <category>mysql</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[redis补充]]></title>
    <url>%2F2020%2F09%2F20%2Fredis%E8%A1%A5%E5%85%85%2F</url>
    <content type="text"><![CDATA[扩容与缩容扩容当used &gt; size 的时候扩容，当进行持久化aof,rdb,script(lua事务) block的时候，如果used &gt; 5size 翻倍扩容缩容当used &lt; size * 0.1的时候缩容扩容和缩容导致rehashscan遇到扩充时 io多线程 zset当数据量少的时候用压缩列表当数据量大于128用跳表实现 redis与mongo的区别 协议 C语言使用Redis编译hiredis进入 redis-6.0.3/deps/hiredis$ make$ sudo make installmkdir -p /usr/local/include/hiredis /usr/local/include/hiredis/adapters /usr/local/libcp -pPR hiredis.h async.h read.h sds.h /usr/local/include/hirediscp -pPR adapters/*.h /usr/local/include/hiredis/adapterscp -pPR libhiredis.so /usr/local/lib/libhiredis.so.0.14cd /usr/local/lib &amp;&amp; ln -sf libhiredis.so.0.14 libhiredis.socp -pPR libhiredis.a /usr/local/libmkdir -p /usr/local/lib/pkgconfigcp -pPR hiredis.pc /usr/local/lib/pkgconfig可以看到头文件、和库文件的安装目录 连接Redis服务 授权 Auth redisCommand 详解原型void redisCommand(redisContext c, const char *format, …); 参数说明这个函数是一个带有不定参数的。可以按着 format 格式给出对应的参数，这就和 printf 函数类似。c 是一个 reidsConnect 函数返回的一个对象。 返回值返回值是一个 void 类型的指针，实际为指向一个 redisReply 类型的指针。12345678910111213141516redisReply 的定义/* This is the reply object returned by redisCommand() */typedef struct redisReply &#123; /*命令执行结果的返回类型*/ int type; /* REDIS_REPLY_* */ /*存储执行结果返回为整数*/ long long integer; /* The integer when type is REDIS_REPLY_INTEGER */ /*字符串值的长度*/ size_t len; /* Length of string */ /*存储命令执行结果返回是字符串*/ char *str; /* Used for both REDIS_REPLY_ERROR and REDIS_REPLY_STRING */ /*返回结果是数组的大小*/ size_t elements; /* number of elements, for REDIS_REPLY_ARRAY */ /*存储执行结果返回是数组*/ struct redisReply **element; /* elements vector for REDIS_REPLY_ARRAY */&#125; redisReply; 返回结果的类型 reply-&gt;type,reply 为 redisReply* 类型。• REDIS_REPLY_STRING == 1:返回值是字符串,字符串储存在 redis-&gt;str 当中,字符串长度为 redis-&gt;len。• REDIS_REPLY_ARRAY == 2：返回值是数组，数组大小存在 redis-&gt;elements 里面，数组值存储在 redis-&gt;element[i]里面。数组里面存储的是指向 redisReply 的指针，数组里面的返回值可以通过 redis-&gt;element[i]-&gt;str 来访问，数组的结果里全是type==REDIS_REPLY_STRING 的 redisReply 对象指针。• REDIS_REPLY_INTEGER == 3：返回值为整数 long long。• REDIS_REPLY_NIL==4：返回值为空表示执行结果为空。• REDIS_REPLY_STATUS ==5：返回命令执行的状态，比如 set foo bar 返回的状态为 OK，存储在 str 当中 reply-&gt;str == “OK”。• REDIS_REPLY_ERROR ==6 ：命令执行错误,错误信息存放在 reply-&gt;str 当中。]]></content>
      <categories>
        <category>redis</category>
      </categories>
      <tags>
        <tag>redis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[redis]]></title>
    <url>%2F2020%2F09%2F20%2Fredis%2F</url>
    <content type="text"><![CDATA[Redis基础数据类型string基本操作: set key value; get key; del key; mset; mget; strlen; append;数值增减 incr decr数据时效性 setex psetex(user:id:3506728370:fans 12210947 json) hash基本操作: hset key field value; hget key field; hgetall key; hdel key field1 [field2]; hmset; hmget; hlen(获取key数量); hexists扩展操作: hkeys; hvals; hincrby; hincrbyfloat; hsetnx(京东购物车) list底层是双向链表基本操作: lpush; rpush; lrange key start stop(朋友圈点赞、最新消息展示) set基本操作: sadd; smembers; srem; scard; sismember; srandmember; spop扩展操作: 交并补 sinter sunion sdiff; 到指定集合 sinterstore destination key1 key2 sunionstore; sdiffstore smove(热点歌单推荐、实现黑白名单) sorted_set基本操作: zadd key score1 member1 [score2 member2]; zrange key start stop [withscores]; zrevrange ;zrem ;zrangebyscore key min max [withscores] [limit]; zrevrangebyscore; zremrangebyrank; zremrangebyscore; zcard; zcount; zinterstore; zunionstore;扩展操作: zrank key member; zrevrank key member; zscore key member; zincrby key increment member; 通用命令key基本操作: del key; exists key; type key;扩展操作: expire key seconds; pexpire key milliseconds; expireat(timestamp); pexpireat; ttl key(有效时间); pttl; persist key(切换key从时效性转换到永久性);其他操作: rename key newkey; renamenx key newkey(如果对应的新newkey不存在再执行); sort; db基本操作: select index; quit; ping; echo massage;其他操作: move key db; dbsize; flushdb flushall; Redis高级持久化1.将当先数据状态进行保存2.将数据的操作过程进行保存 RDB1.save。save指令的执行会阻塞当前Redis服务器，知道当前RDB过程完成为止2.bgsave。 AOFAOF重写随着命令不断写入AOF，文件会越来越大，为了解决这个问题，Redis引入了AOF重写机制压缩文件体积。AOF文件重写是将Redis进程内的数据转化为写命令同步到新AOF文件的过程。简单说就是将对同一个数据的若干条命令执行结果转化成最终结果数据对应的指令进行记录。 事务开启: multi执行: exec取消: discard锁: watch key (watch 监控的指令一旦有人修改了，那么事务不会在执行) 取消锁: unwatch分布式锁: setnx lock-key value 有值返回失败，无值返回设置成功 expire lock-key second(解决死锁) del lock-key 删除策略定时删除惰性删除定期删除逐出策略 高级数据类型bitmaps:setbit time bit value; bitcountHyperLogLog:pfadd; pfcount; pfmergeGEO:geoadd key longitude latitude member; geopos key member; geodist key member member; georadius; georadiusbymember; geohash; 集群主从复制 主从复制常见问题:频繁的全量复制网络:数据不一致: 哨兵 集群 Redis应用企业级解决方案缓存预热问题:1.请求数量较高2.主从之间数据吞吐量较大，数据同步操作频度较高总结:缓存预热就是系统启动前，提前将相关的缓存数据直接加载到缓存系统。避免在用户请求的时候，先查询数据库，然后再将数据缓存的问题。 缓存雪崩问题:在一个较短的时间内，缓存中较多的key集中过期。我们去大量的访问了对应数据。总结:缓存雪崩就算瞬间过期数据量太大，导致对数据库服务器造成压力。如能够有效避免过期时间集中，可以有效解决雪崩现象的出现，配合其他策略一起使用，并监控服务器的运行数据，根据运行记录做快速调整。 缓存击穿问题:1.Redis中某个key过期，该key访问量巨大2.多个数据请求从服务器直接压到Redis后，均未命中3.Redis在短时间内发起了大量对数据库中同一数据的访问总结:缓存击穿就是单个高热数据过期的瞬间，数据访问量较大，未命中redis后，发起了大量对同一数据的数据库访问，导致对数据库服务器造成压力。应对策略应该在业务数据分析与预防方面进行，配合运行监控测试与即使调整策略。 缓存穿透问题:1.Redis中大面积出现未命中2.获取的数据在数据库中也不存在，数据库查询未得到对应数据总结:缓存击穿访问了不存在的数据，跳过了合法数据的Redis数据缓存阶段，每次访问数据库，导致对数据库服务器造成压力。]]></content>
      <categories>
        <category>redis</category>
      </categories>
      <tags>
        <tag>redis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[select/poll/epoll]]></title>
    <url>%2F2020%2F09%2F13%2Fselect-poll-epoll%2F</url>
    <content type="text"><![CDATA[socket接口大部分都是阻塞型的。在调用send()的同时，线程将会阻塞，在此期间，线程将无法执行任何运算或响应任何网络请求。 第一个改进方案在服务器端使用多线程（或多进程）。多线程（或多进程）的目的是让每个连接都拥有独立的线程（或进程），这样任何一个连接的阻塞都不会影响其他的连接。 int accept(int s, struct sockaddr addr, socklen_t addrlen);输入参数 s 是从 socket()，bind()和 listen()中沿用下来的 socket 句柄值。 问题是还是阻塞的，总会有上限。 第二个改进方案看起来一定得非阻塞IO才行。 当用户进程发出 read 操作时，如果 kernel 中的数据还没有准备好，那么它并不会 block 用户进程，而是立刻返回一个 error。从用户进程角度讲 ，它发起一个read 操作后，并不需要等待，而是马上就得到了一个结果。用户进程判断结果是一个 error时，它就知道数据还没有准备好，于是它可以再次发送 read 操作。一旦 kernel 中的数据准备好了，并且又再次收到了用户进程的 system call，那么它马上就将数据拷贝到了用户内存，然后返回，所以，在非阻塞式 IO 中，用户进程其实是需要不断的主动询问 kernel数据准备好了没有。 使用如下的函数可以将某句柄 fd 设为非阻塞状态。fcntl( fd, F_SETFL, O_NONBLOCK ); 但是，循环调用 recv()将大幅度推高 CPU占用率，此外，在这个方案中 recv()更多的是起到检测“操作是否完成”的作用，实际操作系统提供了更为高效的检测“操作是否完成“作用的接口，例如 select()多路复用模式。 第三个改进方案select/epoll 的好处就在于单个 process 就可以同时处理多个网络连接的 IO。它的基本原理就是 select/epoll 这个 function会不断的轮询所负责的所有 socket，当某个 socket 有数据到达了，就通知用户进程。 select/epoll 的优势并不是对于单个连接能处理得更快，而是在于能处理更多的连接。 select 接口的原型：FD_ZERO(int fd, fd_set fds)FD_SET(int fd, fd_set fds)FD_ISSET(int fd, fd_set fds)FD_CLR(int fd, fd_set fds)int select(int nfds, fd_set readfds, fd_set writefds, fd_setexceptfds,struct timeval timeout)这里，fd_set 类型可以简单的理解为按 bit 位标记句柄的队列，例如要在某 fd_set中标记一个值为 16 的句柄，则该 fd_set 的第 16 个 bit 位被标记为 1。具体的置位、验证可使用 FD_SET、FD_ISSET 等宏实现。在 select()函数中，readfds、writefds 和exceptfds 同时作为输入参数和输出参数。如果输入的 readfds 标记了 16 号句柄，则select()将检测 16 号句柄是否可读。在 select()返回后，可以通过检查 readfds 有否标记 16 号句柄，来判断该“可读”事件是否发生。另外，用户可以设置 timeout 时间。 上述模型中，最关键的地方是如何动态维护 select()的三个参数 readfds、writefds和 exceptfds。作为输入参数，readfds 应该标记所有的需要探测的“可读事件”的句柄，其中永远包括那个探测 connect() 的那个“母”句柄；同时，writefds 和 exceptfds 应该标记所有需要探测的“可写事件”和“错误事件”的句柄 ( 使用 FD_SET() 标记 )。作为输出参数，readfds、writefds 和 exceptfds 中的保存了 select() 捕捉到的所有事件的句柄值。程序员需要检查的所有的标记位 ( 使用 FD_ISSET()检查 )，以确定到底哪些句柄发生了事件。 首先 select()接口并不是实现“事件驱动”的最好选择。因为当需要探测的句柄值较大时，select()接口本身需要消耗大量时间去轮询各个句柄。很多操作系统提供了更为高效的接口，如linux提供了epoll，BSD提供了kqueue，Solaris提供了/dev/poll。如果需要实现更高效的服务器程序，类似 epoll 这样的接口更被推荐。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#include &lt;netinet/tcp.h&gt;#include &lt;arpa/inet.h&gt;#include &lt;pthread.h&gt;#include &lt;errno.h&gt;#include &lt;fcntl.h&gt;#include &lt;sys/epoll.h&gt;#include &lt;sys/poll.h&gt;#define BUFFER_LENGTH 1024#define POLL_SIZE 1024#define EPOLL_SIZE 1024int client_route(void *arg) &#123; int clientfd = *(int*)arg; while (1) &#123; char buffer[BUFFER_LENGTH] = &#123;0&#125;; int ret = recv(clientfd, buffer, BUFFER_LENGTH, 0); if (ret &lt; 0) &#123; if (errno == EAGAIN || errno == EWOULDBLOCK) &#123; printf(&quot;read all data\n&quot;); &#125; //close(clientfd); return -1; &#125; else if (ret == 0) &#123; printf(&quot;disconnect \n&quot;); //close(clientfd); return 0; &#125; else &#123; printf(&quot;Recv:%s, %d Bytes\n&quot;, buffer, ret); return ret; &#125; &#125;&#125;void* client_callback(void *arg) &#123; int clientfd = *(int*)arg; while (1) &#123; char buffer[BUFFER_LENGTH] = &#123;0&#125;; int ret = recv(clientfd, buffer, BUFFER_LENGTH, 0); if (ret &lt; 0) &#123; if (errno == EAGAIN || errno == EWOULDBLOCK) &#123; printf(&quot;read all data\n&quot;); &#125; //close(clientfd); return NULL; &#125; else if (ret == 0) &#123; printf(&quot;disconnect \n&quot;); //close(clientfd); return NULL; &#125; else &#123; printf(&quot;Recv:%s, %d Bytes\n&quot;, buffer, ret); //return NULL; &#125; &#125;&#125;int main(int argc, char *argv[]) &#123; if (argc &lt; 2) &#123; printf(&quot;Paramter Error\n&quot;); return -1; &#125; int port = atoi(argv[1]); int sockfd = socket(AF_INET, SOCK_STREAM, 0); if (sockfd &lt; 0) &#123; perror(&quot;socket&quot;); return -1; &#125; struct sockaddr_in addr; memset(&amp;addr, 0, sizeof(struct sockaddr_in)); addr.sin_family = AF_INET; addr.sin_port = htons(port); addr.sin_addr.s_addr = INADDR_ANY; if (bind(sockfd, (struct sockaddr*)&amp;addr, sizeof(struct sockaddr_in)) &lt; 0) &#123; perror(&quot;bind&quot;); return 2; &#125; if (listen(sockfd, 5) &lt; 0) &#123; perror(&quot;listen&quot;); return 3; &#125;#if 0 while (1) &#123; //c10k struct sockaddr_in client_addr; memset(&amp;client_addr, 0, sizeof(struct sockaddr_in)); socklen_t client_len = sizeof(client_addr); int clientfd = accept(sockfd, (struct sockaddr*)&amp;client_addr, &amp;client_len); if (clientfd &lt;= 0) continue; pthread_t thread_id; int ret = pthread_create(&amp;thread_id, NULL, client_callback, &amp;clientfd); if (ret &lt; 0) &#123; perror(&quot;pthread_create&quot;); exit(1); &#125; &#125; #elif 1 fd_set rfds, rset; FD_ZERO(&amp;rfds); FD_SET(sockfd, &amp;rfds); int max_fd = sockfd; int i = 0; while (1) &#123; rset = rfds; int nready = select(max_fd+1, &amp;rset, NULL, NULL, NULL); if (nready &lt; 0) &#123; printf(&quot;select error : %d\n&quot;, errno); continue; &#125; if (FD_ISSET(sockfd, &amp;rset)) &#123; //accept struct sockaddr_in client_addr; memset(&amp;client_addr, 0, sizeof(struct sockaddr_in)); socklen_t client_len = sizeof(client_addr); int clientfd = accept(sockfd, (struct sockaddr*)&amp;client_addr, &amp;client_len); if (clientfd &lt;= 0) continue; char str[INET_ADDRSTRLEN] = &#123;0&#125;; printf(&quot;recvived from %s at port %d, sockfd:%d, clientfd:%d\n&quot;, inet_ntop(AF_INET, &amp;client_addr.sin_addr, str, sizeof(str)), ntohs(client_addr.sin_port), sockfd, clientfd); if (max_fd == FD_SETSIZE) &#123; printf(&quot;clientfd --&gt; out range\n&quot;); break; &#125; FD_SET(clientfd, &amp;rfds); if (clientfd &gt; max_fd) max_fd = clientfd; printf(&quot;sockfd:%d, max_fd:%d, clientfd:%d\n&quot;, sockfd, max_fd, clientfd); if (--nready == 0) continue; &#125; for (i = sockfd + 1;i &lt;= max_fd;i ++) &#123; if (FD_ISSET(i, &amp;rset)) &#123; char buffer[BUFFER_LENGTH] = &#123;0&#125;; int ret = recv(i, buffer, BUFFER_LENGTH, 0); if (ret &lt; 0) &#123; if (errno == EAGAIN || errno == EWOULDBLOCK) &#123; printf(&quot;read all data&quot;); &#125; FD_CLR(i, &amp;rfds); close(i); &#125; else if (ret == 0) &#123; printf(&quot; disconnect %d\n&quot;, i); FD_CLR(i, &amp;rfds); close(i); break; &#125; else &#123; printf(&quot;Recv: %s, %d Bytes\n&quot;, buffer, ret); &#125; if (--nready == 0) break; &#125; &#125; &#125;#elif 1 struct pollfd fds[POLL_SIZE] = &#123;0&#125;; fds[0].fd = sockfd; fds[0].events = POLLIN; int max_fd = 0, i = 0; for (i = 1;i &lt; POLL_SIZE;i ++) &#123; fds[i].fd = -1; &#125; while (1) &#123; int nready = poll(fds, max_fd+1, 5); if (nready &lt;= 0) continue; if ((fds[0].revents &amp; POLLIN) == POLLIN) &#123; struct sockaddr_in client_addr; memset(&amp;client_addr, 0, sizeof(struct sockaddr_in)); socklen_t client_len = sizeof(client_addr); int clientfd = accept(sockfd, (struct sockaddr*)&amp;client_addr, &amp;client_len); if (clientfd &lt;= 0) continue; char str[INET_ADDRSTRLEN] = &#123;0&#125;; printf(&quot;recvived from %s at port %d, sockfd:%d, clientfd:%d\n&quot;, inet_ntop(AF_INET, &amp;client_addr.sin_addr, str, sizeof(str)), ntohs(client_addr.sin_port), sockfd, clientfd); fds[clientfd].fd = clientfd; fds[clientfd].events = POLLIN; if (clientfd &gt; max_fd) max_fd = clientfd; if (--nready == 0) continue; &#125; for (i = sockfd + 1;i &lt;= max_fd;i ++) &#123; if (fds[i].revents &amp; (POLLIN|POLLERR)) &#123; char buffer[BUFFER_LENGTH] = &#123;0&#125;; int ret = recv(i, buffer, BUFFER_LENGTH, 0); if (ret &lt; 0) &#123; if (errno == EAGAIN || errno == EWOULDBLOCK) &#123; printf(&quot;read all data&quot;); &#125; //close(i); fds[i].fd = -1; &#125; else if (ret == 0) &#123; printf(&quot; disconnect %d\n&quot;, i); close(i); fds[i].fd = -1; break; &#125; else &#123; printf(&quot;Recv: %s, %d Bytes\n&quot;, buffer, ret); &#125; if (--nready == 0) break; &#125; &#125; &#125;#else int epoll_fd = epoll_create(EPOLL_SIZE); struct epoll_event ev, events[EPOLL_SIZE] = &#123;0&#125;; ev.events = EPOLLIN; ev.data.fd = sockfd; epoll_ctl(epoll_fd, EPOLL_CTL_ADD, sockfd, &amp;ev); while (1) &#123; int nready = epoll_wait(epoll_fd, events, EPOLL_SIZE, -1); if (nready == -1) &#123; printf(&quot;epoll_wait\n&quot;); break; &#125; int i = 0; for (i = 0;i &lt; nready;i ++) &#123; if (events[i].data.fd == sockfd) &#123; struct sockaddr_in client_addr; memset(&amp;client_addr, 0, sizeof(struct sockaddr_in)); socklen_t client_len = sizeof(client_addr); int clientfd = accept(sockfd, (struct sockaddr*)&amp;client_addr, &amp;client_len); if (clientfd &lt;= 0) continue; char str[INET_ADDRSTRLEN] = &#123;0&#125;; printf(&quot;recvived from %s at port %d, sockfd:%d, clientfd:%d\n&quot;, inet_ntop(AF_INET, &amp;client_addr.sin_addr, str, sizeof(str)), ntohs(client_addr.sin_port), sockfd, clientfd); ev.events = EPOLLIN | EPOLLET; ev.data.fd = clientfd; epoll_ctl(epoll_fd, EPOLL_CTL_ADD, clientfd, &amp;ev); &#125; else &#123; int clientfd = events[i].data.fd; char buffer[BUFFER_LENGTH] = &#123;0&#125;; int ret = recv(clientfd, buffer, BUFFER_LENGTH, 0); if (ret &lt; 0) &#123; if (errno == EAGAIN || errno == EWOULDBLOCK) &#123; printf(&quot;read all data&quot;); &#125; close(clientfd); ev.events = EPOLLIN | EPOLLET; ev.data.fd = clientfd; epoll_ctl(epoll_fd, EPOLL_CTL_DEL, clientfd, &amp;ev); &#125; else if (ret == 0) &#123; printf(&quot; disconnect %d\n&quot;, clientfd); close(clientfd); ev.events = EPOLLIN | EPOLLET; ev.data.fd = clientfd; epoll_ctl(epoll_fd, EPOLL_CTL_DEL, clientfd, &amp;ev); break; &#125; else &#123; printf(&quot;Recv: %s, %d Bytes\n&quot;, buffer, ret); &#125; &#125; &#125; &#125;#endif return 0;&#125; 传送门 异步IO用户进程发起 read 操作之后，立刻就可以开始去做其它的事。而另一方面，从 kernel的角度，当它受到一个 asynchronous read 之后，首先它会立刻返回，所以不会对用户进程产生任何 block。然后，kernel 会等待数据准备完成，然后将数据拷贝到用户内存，当这一切都完成之后，kernel 会给用户进程发送一个 signal，告诉它 read 操作完成了。 阻塞和非阻塞是否立刻返回或者挂起 同步和异步两者的关系，是否马上能做其他的事 信号驱动IO进程会收到一个 SIGIO 信号，可以在信号处理函数中调用 I/O 操作函数处理数据。当数据报准备好读取时，内核就为该进程产生一个 SIGIO 信号。我们随后既可以在信号处理函数中调用 read 读取数据报，并通知主循环数据已准备好待处理，也可以立即通知主循环，让它来读取数据报。无论如何处理 SIGIO 信号，这种模型的优势在于等待数据报到达(第一阶段)期间，进程可以继续执行，不被阻塞。免去了 select 的阻塞与轮询，当有活跃套接字时，由注册的 handler 处理。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889#include &lt;stdio.h&gt;#include &lt;sys/types.h&gt;#include &lt;sys/socket.h&gt;#include &lt;netinet/in.h&gt;#include &lt;string.h&gt;#include &lt;unistd.h&gt;#include &lt;signal.h&gt;#include &lt;fcntl.h&gt;int sockfd = 0;void do_sigio(int sig) &#123; struct sockaddr_in cli_addr; int clilen = sizeof(struct sockaddr_in); int clifd = 0;#if 0 clifd = accept(sockfd, (struct sockaddr*)&amp;cli_addr, &amp;clilen); char buffer[256] = &#123;0&#125;; int len = read(clifd, buffer, 256); printf(&quot;Listen Message : %s\r\n&quot;, buffer); int slen = write(clifd, buffer, len);#else char buffer[256] = &#123;0&#125;; int len = recvfrom(sockfd, buffer, 256, 0, (struct sockaddr*)&amp;cli_addr, (socklen_t*)&amp;clilen); printf(&quot;Listen Message : %s\r\n&quot;, buffer); int slen = sendto(sockfd, buffer, len, 0, (struct sockaddr*)&amp;cli_addr, clilen);#endif&#125;int main(int argc, char *argv[]) &#123; sockfd = socket(AF_INET, SOCK_DGRAM, 0); //socket编程 AF_INET IPV4 struct sigaction sigio_action; sigio_action.sa_flags = 0; sigio_action.sa_handler = do_sigio; sigaction(SIGIO, &amp;sigio_action, NULL); /* * sigaction函数的功能是检查或修改与指定信号相关联的处理动作 * int sigaction(int signum, const struct sigaction *act, struct sigaction *oldact); struct sigaction &#123; void (*sa_handler)(int); void (*sa_sigaction)(int, siginfo_t *, void *); sigset_t sa_mask; int sa_flags; void (*sa_restorer)(void); &#125; */ struct sockaddr_in serv_addr; memset(&amp;serv_addr, 0, sizeof(serv_addr)); serv_addr.sin_family = AF_INET; //地址族 serv_addr.sin_port = htons(9096); //16位TCP/UDP端口号 serv_addr.sin_addr.s_addr = INADDR_ANY; //32位IPV4地址 /* * sockaddr_in 用来处理网络通信的地址 * */ fcntl(sockfd, F_SETOWN, getpid()); //根据文件描述词来操作文件的特性 int flags = fcntl(sockfd, F_GETFL, 0); flags |= O_ASYNC | O_NONBLOCK; fcntl(sockfd, F_SETFL, flags); bind(sockfd, (struct sockaddr*)&amp;serv_addr, sizeof(serv_addr)); while(1) sleep(1); close(sockfd); return 0;&#125;]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[计网概括]]></title>
    <url>%2F2020%2F09%2F13%2F%E8%AE%A1%E7%BD%91%E6%A6%82%E6%8B%AC%2F</url>
    <content type="text"><![CDATA[传送门]]></content>
      <categories>
        <category>计网</category>
      </categories>
      <tags>
        <tag>计网</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[平衡二叉树与红黑树]]></title>
    <url>%2F2020%2F09%2F13%2F%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%8E%E7%BA%A2%E9%BB%91%E6%A0%91%2F</url>
    <content type="text"><![CDATA[简介本文转自这里 常见用途STL（标准模板库）中在set map是基于红黑树实现的。Java中在TreeMap使用的也是红黑树。epoll在内核中的实现，用红黑树管理事件块。linux进程调度Completely Fair Scheduler,用红黑树管理进程控制块。 红黑树 VS AVL树常见的平衡树有红黑树和AVL平衡树，为什么STL和linux都使用红黑树作为平衡树的实现？大概有以下几个原因： 从实现细节上来讲，如果插入一个结点引起了树的不平衡，AVL树和红黑树都最多需要2次旋转操作，即两者都是O(1)；但是在删除node引起树的不平衡时，最坏情况下，AVL需要维护从被删node到root这条路径上所有node的平衡性，因此需要旋转的量级O(logN)，而RB-Tree最多只需3次旋转，只需要O(1)的复杂度 从两种平衡树对平衡的要求来讲，AVL的结构相较RB-Tree来说更为平衡，在插入和删除node更容易引起Tree的unbalance，因此在大量数据需要插入或者删除时，AVL需要rebalance的频率会更高。因此，RB-Tree在需要大量插入和删除node的场景下，效率更高。自然，由于AVL高度平衡，因此AVL的search效率更高。 总体来说，RB-tree的统计性能是高于AVL的。 红黑树红黑树性质1.列表项结点是红色或黑色。2.根是黑色。3.所有叶子都是黑色（叶子是NIL结点）。4.每个红色结点必须有两个黑色的子结点。（从每个叶子到根的所有路径上不能有两个连续的红色结点。）5.从任一结点到其每个叶子的所有简单路径都包含相同数目的黑色结点。为了便于处理红黑树中的边界情况，使用一个哨兵来代表所有的NIL结点，也就是说所有指向NIL的指针都指向哨兵T.nil。 旋转 解释：x的右节点换成y的左节点x的右节点的父亲换成xy名正言顺成为x的父亲的儿子y的父亲发现自己儿子换了，看看是哪边的儿子换了现在跟x相关的结点都换好了，那么y名正言顺成为x的爹 12345678910111213141516171819202122232425262728293031323334353637383940414243444546/**@brief rbt_left_rotate*@param[in] T 树根*@param[in] x 要进行旋转的节点*/void rbt_left_rotate( rbt_root_t* T, rbt_t* x)&#123; rbt_t* y = x-&gt;right; x-&gt;right = y-&gt;left; if(x-&gt;right != T-&gt;nil)//更新某结点的父亲时，要确定此结点不是T.nil x-&gt;right-&gt;p = x; y-&gt;p = x-&gt;p; if(x-&gt;p == T-&gt;nil)&#123;//如果x以前是树根，那么现在树根易主了 T-&gt;root = y; &#125;else if(y-&gt;key &lt; y-&gt;p-&gt;key) y-&gt;p-&gt;left = y; else y-&gt;p-&gt;right = y; y-&gt;left = x; x-&gt;p = y;&#125;/**@brief rbt_right_rotate*@param[in] 树根*@param[in] 要进行旋转的节点*/void rbt_right_rotate( rbt_root_t* T, rbt_t* x)&#123; rbt_t * y = x-&gt;left; x-&gt;left = y-&gt;right; if(T-&gt;nil != x-&gt;left) x-&gt;left-&gt;p = x; y-&gt;p = x-&gt;p; if(y-&gt;p == T-&gt;nil) T-&gt;root = y; else if(y-&gt;key &lt; y-&gt;p-&gt;key) y-&gt;p-&gt;left= y; else y-&gt;p-&gt;right = y; y-&gt;right = x; x-&gt;p = y;&#125; 插入1.新插入的节点一定是红色的。（如果是黑色的，会破坏条件5）2.如果新插入的节点的父亲是黑色的，则没有破坏任何性质，那么插入完成。3.如果插入节点的父节点是红色, 破坏了性质4. 故插入算法就是通过重新着色或旋转, 来维持性质 此时要记住一件事事情，插入时总是要考虑它的叔叔，删除时总要考虑它的兄弟。而且插入时维护的主要是颜色（性质4），而删除时维护的主要是黑色结点数量（性质5） 情况1： N为红，P为红（GP一定为黑），U为红。 下面会说明我们可以通过一种特殊的处理把这种情况避免掉。 那为什么要避免这种情况呢？因为这种情况一般是通过颜色翻转来处理的，也就是把P U换成黑色，把GP抱成红色，但是GP的父亲如果是红色的话又会违反红黑树的性质。 情况2： N，P都为红（GP一定为黑)，U为黑 根据境像，情况2可细分为4种情况，如下： 但是这四种具体情况的处理手法是一样的，都是通过颜色翻转与旋转来处理的。下面我们通过情况2.1和2.2来说明一下处理方法：情况2.2通过调用left_rotate(T,p)变成情况2.1;情况2.1通过交换GP与P的颜色，然后调用right_rotate(T,GP)，此时不再违反任何性质。 情况2.3和2.4分别是2.1和2.2的境像。 如何避免情况1 令X = T.root,在向下遍历的过程中，我们如果遇到X.right.color == x.left.color == RED时我们将x与它孩子的颜色翻转，即把x涂成红色，把x.right和x.left涂成黑色。 如果x的父亲为黑色，没有违反性质；如果x的父亲为红色，那么可以把x当成新插入的红色结点N，那么只需要处理情况2即可。 至此，插入完成，具体实现可以看完整代码部分，代码也有必要的注释。 删除首先找到要删除的结点，我们定义它为 z 如果要删除 z 结点，那么就让 z 的后继来代替 z 的位置即可。 如果z是红色的，那么操作便完成了，删除一个红色结点没有违反任何性质。但如果z是黑色的，那么我们删除一个黑色结点，便违反了性质5，造成黑色结点数量的左右不平衡。只要分析出删除一个黑色结点会遇到哪些情况即可。 如果 z 的两个孩子都不是T.nil，那么我们在 z 的右子树中找出最小的结点 m，把 m 结点的值赋给 z （而不是把m移植到z的位置，也就不用考虑颜色问题，那么我们要删除的结点就成为 m 了。m 肯定没有左孩子。令 z 重新指向 m 找到要删除的结点 z 之后，我们用 z 的孩子(记作 x )来取代 z的位置（即使z.right == T.nil） 。rbt_transplant(T,z,z.right); 此时用到下面一段代码，实现用v代替u123456789void rbt_transplant(rbt_root_t* T, rbt_t* u, rbt_t* v)&#123; if(u-&gt;p == T-&gt;nil) T-&gt;root = v; else if(u == u-&gt;p-&gt;left) u-&gt;p-&gt;left =v; else u-&gt;p-&gt;right = v; v-&gt;p = u-&gt;p;//即使v是T.nil也可以执行这一行&#125; 到目前为止，如果要被删除的 z 结点是红色的，那么程序就结束了。但是如果 z 是黑色的，所以删除z之后z这边少了一个黑色结点，会违反性质5，此时分为4种情况（x 是左孩子 和 x 是右孩子分别有4种情况，现在只讨论x是左孩子的情况）： 情况1： x的兄弟w是红色的，那么它们的父亲、w的孩子都是黑色的。 这种情况下只能做一种无损的操作，通过交换颜色再旋转，对树的性质不会产生影响，所以从根到x结点的路径上少的一个黑色结点也不会补上。 交换p与w的颜色，再对p进行左旋操之后，x的新兄弟就为黑色，情况变成了2 3 4中的一种. 图中x为白色，表示我们不关心x的颜色。 情况2： x的兄弟w是黑色，而且w的两个孩子都是黑色。 此时可以细分为2种情况，但无论哪种情况，我们要进行的操作都是一样的，都是将w涂成红色，将p涂成黑色。 如果是情况2.1(有可能由情况1发展过来的)，由于上述操作为x那边补上了一个黑色（从根到x在路径上多了一个黑色结点），此时红黑树性质5得到满足，程序结束。 如果是情况2.2, 经过上述操作后，P的右子树也少了一个黑色结点，令P作为新的X继续循环。 情况3: W是黑色有，w在左孩子是红色的，W的右孩子是黑色的。 通过交换L与W的颜色，再对W进行右旋操作。这种操作也不会对红黑树性质产生影响，此时进入情况4，我们会看到通过情况4中的操作最终使红黑树性质得到满足，结束程序。 图中最后边的R结点没有画出来，因为我们不关心它了 情况4: w是黑色的，w的右孩子是红色的。 把w涂成p的颜色，把P涂成黑色，R涂成黑色，左旋P。此时从根到x在路径上多了一个黑色结点，程序结束。 完整代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434#include&lt;stdafx.h&gt;#include&lt;malloc.h&gt;#include &lt;assert.h&gt;//版权声明：原创不易，转载请注明转自[weewqrer 红黑树](http://blog.csdn.net/weewqrer/article/details/51866488)//红黑树typedef enum ColorType &#123;RED, BLACK&#125; ColorType;typedef struct rbt_t&#123; int key; rbt_t * left; rbt_t * right; rbt_t * p; ColorType color;&#125;rbt_t;typedef struct rbt_root_t&#123; rbt_t* root; rbt_t* nil;&#125;rbt_root_t;//函数声明rbt_root_t* rbt_init(void);static void rbt_handleReorient(rbt_root_t* T, rbt_t* x, int k);rbt_root_t* rbt_insert(rbt_root_t* &amp;T, int k);rbt_root_t* rbt_delete(rbt_root_t* &amp;T, int k);void rbt_transplant(rbt_root_t* T, rbt_t* u, rbt_t* v);static void rbt_left_rotate( rbt_root_t* T, rbt_t* x);static void rbt_right_rotate( rbt_root_t* T, rbt_t* x);void rbt_inPrint(const rbt_root_t* T, rbt_t* t);void rbt_prePrint(const rbt_t * T, rbt_t* t);void rbt_print(const rbt_root_t* T);static rbt_t* rbt_findMin(rbt_root_t * T, rbt_t* t);static rbt_t* rbt_findMax(rbt_root_t * T, rbt_t* t);static rbt_t* rbt_findMin(rbt_root_t * T, rbt_t* t)&#123; if(t == T-&gt;nil) return T-&gt;nil; while(t-&gt;left != T-&gt;nil) t = t-&gt;left; return t;&#125;static rbt_t* rbt_findMax(rbt_root_t * T, rbt_t* t)&#123; if(t == T-&gt;nil) return T-&gt;nil; while(t-&gt;right != T-&gt;nil) t = t-&gt;right; return t;&#125;/**@brief rbt_init 初始化*/rbt_root_t* rbt_init(void)&#123; rbt_root_t* T; T = (rbt_root_t*)malloc(sizeof(rbt_root_t)); assert( NULL != T); T-&gt;nil = (rbt_t*)malloc(sizeof(rbt_t)); assert(NULL != T-&gt;nil); T-&gt;nil-&gt;color = BLACK; T-&gt;nil-&gt;left = T-&gt;nil-&gt;right = NULL; T-&gt;nil-&gt;p = NULL; T-&gt;root = T-&gt;nil; return T;&#125;/**@brief rbt_handleReorient 内部函数 由rbt_insert调用* 在两种情况下调用这个函数：* 1 x有连个红色儿子* 2 x为新插入的结点**/ void rbt_handleReorient(rbt_root_t* T, rbt_t* x, int k)&#123; //在第一种情况下，进行颜色翻转； 在第二种情况下，相当于对新插入的x点初始化 x-&gt;color = RED; x-&gt;left-&gt;color = x-&gt;right-&gt;color = BLACK; //如果x.p为红色，那么x.p一定不是根，x.p.p一定不是T.nil，而且为黑色 if( RED == x-&gt;p-&gt;color)&#123; x-&gt;p-&gt;p-&gt;color = RED;//此时x, p, x.p.p都为红 if(x-&gt;p-&gt;key &lt; x-&gt;p-&gt;p-&gt;key)&#123; if(k &gt; x-&gt;p-&gt;key)&#123; x-&gt;color = BLACK;//小心地处理颜色 rbt_left_rotate(T,x-&gt;p); rbt_right_rotate(T,x-&gt;p); &#125;else&#123; x-&gt;p-&gt;color = BLACK;//小心地处理颜色 rbt_right_rotate(T,x-&gt;p-&gt;p); &#125; &#125;else&#123; if(k &lt; x-&gt;p-&gt;key)&#123; x-&gt;color = BLACK; rbt_right_rotate(T,x-&gt;p); rbt_left_rotate(T,x-&gt;p); &#125;else&#123; x-&gt;p-&gt;color = BLACK; rbt_left_rotate(T,x-&gt;p-&gt;p); &#125; &#125; &#125; T-&gt;root-&gt;color = BLACK;//无条件令根为黑色&#125;/**@brief brt_insert 插入*1 新插入的结点一定是红色的，如果是黑色的，会破坏条件4（每个结点到null叶结点的每条路径有同样数目的黑色结点）*2 如果新插入的结点的父亲是黑色的，那么插入完成。 如果父亲是红色的，那么做一个旋转即可。（前提是叔叔是黑色的）*3 我们这个插入要保证其叔叔是黑色的。也就是在x下沉过程中，不允许存在两个红色结点肩并肩。*/rbt_root_t* rbt_insert(rbt_root_t* &amp;T, int k)&#123; rbt_t * x, *p; x = T-&gt;root; p = x; //令x下沉到叶子上，而且保证一路上不会有同时为红色的兄弟 while( x != T-&gt;nil)&#123; // //保证没有一对兄弟同时为红色， 为什么要这么做？ if(x != T-&gt;nil) if(x-&gt;left-&gt;color == RED &amp;&amp; x-&gt;right-&gt;color == RED) rbt_handleReorient(T,x,k); p = x; if(k&lt;x-&gt;key) x = x-&gt;left; else if(k&gt;x-&gt;key) x = x-&gt;right; else&#123; printf(&quot;\n%d已存在\n&quot;,k); return T; &#125; &#125; //为x分配空间，并对其进行初始化 x = (rbt_t *)malloc(sizeof(rbt_t)); assert(NULL != x); x-&gt;key = k; x-&gt;color = RED; x-&gt;left = x-&gt;right = T-&gt;nil; x-&gt;p = p; //让x的父亲指向x if(T-&gt;root == T-&gt;nil) T-&gt;root = x; else if(k &lt; p-&gt;key) p-&gt;left = x; else p-&gt;right = x; //因为一路下来，如果x的父亲是红色，那么x的叔叔肯定不是红色了，这个时候只需要做一下翻转即可。 rbt_handleReorient(T,x,k); return T;&#125;void rbt_transplant(rbt_root_t* T, rbt_t* u, rbt_t* v)&#123; if(u-&gt;p == T-&gt;nil) T-&gt;root = v; else if(u == u-&gt;p-&gt;left) u-&gt;p-&gt;left =v; else u-&gt;p-&gt;right = v; v-&gt;p = u-&gt;p;&#125;/**@brief rbt_delete 从树中删除 k***/rbt_root_t* rbt_delete(rbt_root_t* &amp;T, int k)&#123; assert(T != NULL); if(NULL == T-&gt;root) return T; //找到要被删除的叶子结点 rbt_t * toDelete = T-&gt;root; rbt_t * x; //找到值为k的结点 while(toDelete != T-&gt;nil &amp;&amp; toDelete-&gt;key != k)&#123; if(k&lt;toDelete-&gt;key) toDelete = toDelete-&gt;left; else if(k&gt;toDelete-&gt;key) toDelete = toDelete-&gt;right; &#125; if(toDelete == T-&gt;nil)&#123; printf(&quot;\n%d 不存在\n&quot;,k); return T; &#125; //如果两个孩子，就找到右子树中最小的代替, alternative最多有一个右孩子 if(toDelete-&gt;left != T-&gt;nil &amp;&amp; toDelete-&gt;right != T-&gt;nil)&#123; rbt_t* alternative = rbt_findMin(T, toDelete-&gt;right); k = toDelete-&gt;key = alternative-&gt;key; toDelete = alternative; &#125; if(toDelete-&gt;left == T-&gt;nil)&#123; x = toDelete-&gt;right; rbt_transplant(T,toDelete,toDelete-&gt;right); &#125;else if(toDelete-&gt;right == T-&gt;nil)&#123; x = toDelete-&gt;left; rbt_transplant(T,toDelete,toDelete-&gt;left); &#125; if(toDelete-&gt;color == BLACK)&#123; //x不是todelete，而是用于代替x的那个 //如果x颜色为红色的，把x涂成黑色即可， 否则 从根到x处少了一个黑色结点，导致不平衡 while(x != T-&gt;root &amp;&amp; x-&gt;color == BLACK)&#123; if(x == x-&gt;p-&gt;left)&#123; rbt_t* w = x-&gt;p-&gt;right; //情况1 x的兄弟是红色的，通过 if(RED == w-&gt;color)&#123; w-&gt;color = BLACK; w-&gt;p-&gt;color = RED; rbt_left_rotate(T,x-&gt;p); w = x-&gt;p-&gt;right; &#125;//处理完情况1之后，w.color== BLACK ， 情况就变成2 3 4 了 //情况2 x的兄弟是黑色的，并且其儿子都是黑色的。 if(w-&gt;left-&gt;color == BLACK &amp;&amp; w-&gt;right-&gt;color == BLACK)&#123; if(x-&gt;p-&gt;color == RED)&#123; x-&gt;p-&gt;color = BLACK; w-&gt;color = RED; break; &#125;else&#123; w-&gt;color = RED; x = x-&gt;p;//x.p左右是平衡的，但是x.p处少了一个黑结点，所以把x.p作为新的x继续循环 continue; &#125; &#125; //情况3 w为黑色的，左孩子为红色。（走到这一步，说明w左右不同时为黑色。） if(w-&gt;right-&gt;color == BLACK)&#123; w-&gt;left-&gt;color = BLACK; w-&gt;color = RED; rbt_right_rotate(T,w); w = x-&gt;p-&gt;right; &#125;//处理完之后，变成情况4 //情况4 走到这一步说明w为黑色， w的左孩子为黑色， 右孩子为红色。 w-&gt;color=x-&gt;p-&gt;color; x-&gt;p-&gt;color=BLACK; w-&gt;right-&gt;color=BLACK; rbt_left_rotate(T,x-&gt;p); x = T-&gt;root; &#125;else&#123; rbt_t* w = x-&gt;p-&gt;left; //1 if(w-&gt;color == RED)&#123; w-&gt;color = BLACK; x-&gt;p-&gt;color = RED; rbt_right_rotate(T,x-&gt;p); w = x-&gt;p-&gt;left; &#125; //2 if(w-&gt;left-&gt;color==BLACK &amp;&amp; w-&gt;right-&gt;color == BLACK)&#123; if(x-&gt;p-&gt;color == RED)&#123; x-&gt;p-&gt;color = BLACK; w-&gt;color = RED; break; &#125;else&#123; x-&gt;p-&gt;color = BLACK; w-&gt;color = RED; x = x-&gt;p; continue; &#125; &#125; //3 if(w-&gt;left-&gt;color == BLACK)&#123; w-&gt;color = RED; w-&gt;right-&gt;color = BLACK; w = x-&gt;p-&gt;left; &#125; //4 w-&gt;color=w-&gt;p-&gt;color; x-&gt;p-&gt;color = BLACK; w-&gt;left-&gt;color = BLACK; rbt_right_rotate(T,x-&gt;p); x = T-&gt;root; &#125; &#125; x-&gt;color = BLACK; &#125; //放心删除todelete 吧 free(toDelete); return T;&#125;/**@brief rbt_left_rotate*@param[in] T 树根*@param[in] x 要进行旋转的结点*/void rbt_left_rotate( rbt_root_t* T, rbt_t* x)&#123; rbt_t* y = x-&gt;right; x-&gt;right = y-&gt;left; if(x-&gt;right != T-&gt;nil) x-&gt;right-&gt;p = x; y-&gt;p = x-&gt;p; if(y-&gt;p == T-&gt;nil)&#123; T-&gt;root = y; &#125;else if(y-&gt;key &lt; y-&gt;p-&gt;key) y-&gt;p-&gt;left = y; else y-&gt;p-&gt;right = y; y-&gt;left = x; x-&gt;p = y;&#125;/**@brief rbt_right_rotate*@param[in] 树根*@param[in] 要进行旋转的结点*/void rbt_right_rotate( rbt_root_t* T, rbt_t* x)&#123; rbt_t * y = x-&gt;left; x-&gt;left = y-&gt;right; if(T-&gt;nil != x-&gt;left) x-&gt;left-&gt;p = x; y-&gt;p = x-&gt;p; if(y-&gt;p == T-&gt;nil) T-&gt;root = y; else if(y-&gt;key &lt; y-&gt;p-&gt;key) y-&gt;p-&gt;left= y; else y-&gt;p-&gt;right = y; y-&gt;right = x; x-&gt;p = y;&#125;void rbt_prePrint(const rbt_root_t* T, rbt_t* t)&#123; if(T-&gt;nil == t)return ; if(t-&gt;color == RED) printf(&quot;%3dR&quot;,t-&gt;key); else printf(&quot;%3dB&quot;,t-&gt;key); rbt_prePrint(T,t-&gt;left); rbt_prePrint(T,t-&gt;right);&#125;void rbt_inPrint(const rbt_root_t* T, rbt_t* t)&#123; if(T-&gt;nil == t)return ; rbt_inPrint(T,t-&gt;left); if(t-&gt;color == RED) printf(&quot;%3dR&quot;,t-&gt;key); else printf(&quot;%3dB&quot;,t-&gt;key); rbt_inPrint(T,t-&gt;right);&#125;//打印程序包括前序遍历和中序遍历两个，因为它俩可以唯一确定一棵二叉树void rbt_print(const rbt_root_t* T)&#123; assert(T!=NULL); printf(&quot;\n前序遍历 ：&quot;); rbt_prePrint(T,T-&gt;root); printf(&quot;\n中序遍历 ：&quot;); rbt_inPrint(T,T-&gt;root); printf(&quot;\n&quot;);&#125;void rbt_test()&#123; rbt_root_t* T = rbt_init(); /************************************************************************/ /* 1 测试插入 /* /* /*输出 前序遍历 ： 7B 2R 1B 5B 4R 11R 8B 14B 15R /* 中序遍历 ： 1B 2R 4R 5B 7B 8B 11R 14B 15R /************************************************************************/ T = rbt_insert(T,11); T = rbt_insert(T,7); T = rbt_insert(T,1); T = rbt_insert(T,2); T = rbt_insert(T,8); T = rbt_insert(T,14); T = rbt_insert(T,15); T = rbt_insert(T,5); T = rbt_insert(T,4); T = rbt_insert(T,4); //重复插入测试 rbt_print(T); /************************************************************************/ /* 2 测试删除 /* /*操作 连续删除4个元素 rbt_delete(T,8);rbt_delete(T,14);rbt_delete(T,7);rbt_delete(T,11); /*输出 前序遍历 ： 2B 1B 5R 4B 15B /* 中序遍历 ： 1B 2B 4B 5R 15B /************************************************************************/ rbt_delete(T,8); rbt_delete(T,14);rbt_delete(T,7);rbt_delete(T,11); rbt_delete(T,8);//删除不存在的元素 rbt_print(T);&#125;]]></content>
      <categories>
        <category>基础</category>
      </categories>
      <tags>
        <tag>红黑树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[布隆过滤器]]></title>
    <url>%2F2020%2F09%2F13%2F%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8%2F</url>
    <content type="text"><![CDATA[布隆过滤器一个空的布隆过滤器是一串被置为0的bit数组（假设由m位）。同时，应该声明k个不同的散列函数生成一个统一随机分布，每一个散列函数都将元素映射到m个bit中的一个（k是一个小于m的常数，与加入过滤器中的元素个数成比例）。k与相应的m的选择由误判率决定。 向过滤器中添加元素时，通过k个散列函数得到该元素对应的k个位置，并将这些位置置为1. 查询某个元素/测试是否与已有元素重复时，依旧通过k个散列函数得到对应的k个位置，判断这些位置是否为1（若全为1则在集合内/重复） 可以看如下图所示的一个例子，其中，{x,y,z}为集合，w为进行比对的元素，m=18，k=3，不同颜色的箭头表示散列映射关系。可以看出，w并不在{x,y,z}这个集合中。 Bitmap是用一个数组中的每个数据的每个二进制位表示一个数是否存在。1表示存在，0表示不存在。 相当于把数组分成很多块的空间，每一块是32个比特位。 原来32个比特位放一个数据，相当于现在一个位就可以放一个数据。]]></content>
      <categories>
        <category>基础</category>
      </categories>
      <tags>
        <tag>布隆过滤器</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[B树与B+树]]></title>
    <url>%2F2020%2F09%2F13%2FB%E6%A0%91%E4%B8%8EB-%E6%A0%91%2F</url>
    <content type="text"><![CDATA[B树性质一颗M阶B树T，满足以下条件 每个结点至多拥有M课子树 根结点至少拥有两颗子树 除了根结点以外，其余每个分支结点至少拥有M/2课子树 所有的叶结点都在同一层上 有k课子树的分支结点则存在k-1个关键字，关键字按照递增顺序进行排序 关键字数量满足ceil(M/2)-1 &lt;= n &lt;= M-1 插入通过对B树进行遍历，找出要插入的结点以及结点位置，如果找到的key值在B树当中已经存在，则说明插入失败，否则，就可以进行插入操作。这里可以先不管是否超出M阶树的上限要求，因为我们在定义的时候会故意留下一个位置，可以存放多余的一个元素，插入之后，通过判断是否达到M阶树上限要求，再进行递归的分裂操作。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849/**** @name Status insertBTree(BTree &amp;T, Record e)* @description 插入实现元素的插入* @return 成功返回OK,如果存在则返回FALSE，否则返回ERROR* @notice***/Status insertBTree(BTree &amp;T, Record e)&#123; BTree p; int index, temp; Status find_flag; if (NULL == T)//考虑B树为空树的情况 &#123; T = (BTree)malloc(BTLEN); if (NULL == T) return OVERFLOW; T-&gt;keynum = 1; T-&gt;parent = NULL; for (index = 0;index &lt;= m; ++index) &#123; T-&gt;ptr[index] = NULL; T-&gt;key[index] = 0; &#125; T-&gt;key[1] = e.key; return OK; &#125; find_flag = findBTree(T, p, temp, e.key);//寻找插入节点 if (find_flag == TRUE) &#123; return FALSE; &#125; if (find_flag == FALSE) &#123; //不管怎样先直接插入 p-&gt;keynum++; for (index = p-&gt;keynum;index &gt; temp;--index) &#123; p-&gt;key[index] = p-&gt;key[index - 1]; p-&gt;ptr[index] = p-&gt;ptr[index - 1]; &#125; p-&gt;ptr[temp] = NULL; p-&gt;key[temp] = e.key; if (p-&gt;keynum == m) //这种情况得分裂 &#123; splitBTree(p); &#125; renewParent(T); return OK; &#125; return ERROR;&#125; 分裂分裂操作是插入操作过程中一个最重要的操作，因为这是处理“冲突”（即结点中的数据元素大于B树规则中要求的最大个数）的一个通用的处理方式，这种方式必须要对所有的情况都适用，而分裂是解决这一问题一个方法。当然这种方法只是考虑到效率，没有对兄弟可否借数据进行判断，但是另外一种方式比较麻烦，这里先不做讨论。 分裂的思路是让父亲结点先腾出一个位置（包括key和ptr）出来，然后在需要分裂的结点里面取中间的元素并且移动中间的元素key到父亲结点已经腾出来的key位置那里，然后把分裂出来的右部分接到腾出来的ptr那里。注意整个过程对左部分和右部分的都要改变元素的个数以及清空一些没用的空间。在往上分裂之后可能会造成一种情况，就是父亲结点也可能达到分裂的最大个数，所以，检查父亲结点是否需要分裂，需要的话，递归之。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950/**** @name status splitBTree(BTree T)* @description 递归实现分裂节点操作* @return 成功返回OK,否则返回ERROR* @notice***/Status splitBTree(BTree T) //此时分裂的节点一定会是超出最大值的。&#123; BTree t1, t2; int index, index_1; if (T-&gt;parent == NULL) &#123; t1 = (BTree)malloc(BTLEN); if (NULL == t1) return OVERFLOW; t2 = (BTree)malloc(BTLEN); if (NULL == t2) return OVERFLOW; t1-&gt;keynum = m / 2; t2-&gt;keynum = m - (m / 2) - 1; t1-&gt;parent = T; t2-&gt;parent = T; for (index = 0;index &lt;= m; ++index) //先全部初始化 &#123; t1-&gt;ptr[index] = NULL; t1-&gt;key[index] = 0; t2-&gt;ptr[index] = NULL; t2-&gt;key[index] = 0; &#125; for (index = 0;index &lt;= m / 2; ++index) //初始化t1 &#123; t1-&gt;ptr[index] = T-&gt;ptr[index]; t1-&gt;key[index] = T-&gt;key[index]; &#125; t2-&gt;ptr[0] = T-&gt;ptr[(m / 2) + 1]; for (index = (m / 2) + 2;index &lt;= m; ++index) //初始化t2 &#123; t2-&gt;ptr[index - ((m / 2) + 1)] = T-&gt;ptr[index]; t2-&gt;key[index - ((m / 2) + 1)] = T-&gt;key[index]; &#125; T-&gt;keynum = 1; T-&gt;ptr[0] = t1; T-&gt;ptr[1] = t2; T-&gt;key[1] = T-&gt;key[m / 2 + 1]; for (index = 2;index &lt;= m; ++index) //初始化T &#123; T-&gt;ptr[index] = NULL; T-&gt;key[index] = 0; &#125; return OK; &#125; 删除B树元素的删除操作与插入操作类似，但是却要麻烦，因为得分两种情况处理。（1）寻找到存在这个元素，而且这个元素所在是叶子节点（即它的孩子为空），直接对其进行删除，之后再判断是否小于B树规则中要求的最小的子树个数。如果小于，那就调用合并函数。（2）如果寻找到的这个元素是非叶子节点的元素，通过寻找比该元素小的最大元素（该元素肯定为叶子节点），把该元素直接赋值给要删除的元素，再在叶子节点处进行（1）中的操作。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556/**** @name Status deleteBTreeRecord(BTree &amp;T, Record e)* @description 实现B树元素的删除* @return 成功返回OK,否则返回ERROR* @notice***/Status deleteBTreeRecord(BTree &amp;T, Record e)&#123; BTree p, q; int num, temp, index; Status find_flag; if (T == NULL) return ERROR; find_flag = findBTree(T, p, temp, e.key); if (find_flag == FALSE) &#123; return FALSE; &#125; if (find_flag == TRUE) &#123; //deleteBTreeBNode(p,temp); if (p-&gt;ptr[temp] == NULL) //如果是叶子节点的话 &#123; for (index = temp;index &lt;= p-&gt;keynum;++index) &#123; p-&gt;key[index] = p-&gt;key[index + 1]; p-&gt;ptr[index] = p-&gt;ptr[index + 1]; &#125; p-&gt;keynum--; if (p-&gt;keynum == (m + 1) / 2 - 2) &#123; //调用借兄弟的函数 if (borrowBNode(p) == EMPTY) T = NULL; else renewParent(T); &#125; return OK; &#125; else //不是叶子结点的话 &#123; //遍历 findMax(p-&gt;ptr[temp - 1], q, num);//返回的q一定会是叶子节点 p-&gt;key[temp] = q-&gt;key[num]; q-&gt;key[num] = 0; q-&gt;keynum--; if (q-&gt;keynum == (m + 1) / 2 - 2) &#123; //调用借兄弟的函数 if (borrowBNode(q) == EMPTY) T = NULL; else renewParent(T); &#125; return OK; &#125; return OK; &#125; return ERROR;&#125; 合并首先先向兄弟结点借元素，如果兄弟能够借给你元素的话（即借了你之后并不会小于最少的分支），那么直接从兄弟那里取元素，否则，和兄弟合并。合并其实是分裂反过来的情况，从父亲结点那里取出一个key值介于要合并的两个结点之间的元素，插入左部分最末尾处，同时右部分插到左部分后面，然后父亲结点元素依次往前挪。从而实现合并操作。之后，也必须对父亲结点进行判断是否小于最小的分支数，如果也小于，对父亲节点进行递归操作。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123/**** @name Status borrowBNode(BTree &amp;T)* @description 递归实现，向兄弟借元素，否则和兄弟合并* @return 成功返回OK,否则返回ERROR* @notice 这种情况应该是T为单元素结点***/Status borrowBNode(BTree T)&#123; int mynum, bronum, index; BTree b = NULL, f = NULL; if (T == NULL) return ERROR; f = T-&gt;parent; if (f == NULL)//考虑父亲结点不存在的情况 &#123; if (T-&gt;keynum == 0) &#123; f = T-&gt;ptr[0]; if (f == NULL) &#123; free(T); return EMPTY; &#125; for (index = 0;index &lt;= f-&gt;keynum;index++) &#123; T-&gt;key[index] = f-&gt;key[index]; T-&gt;ptr[index] = f-&gt;ptr[index]; &#125; T-&gt;keynum = f-&gt;keynum; free(f); renewParent(T); &#125; return OK; &#125; mynum = whichSon(T); if (mynum == 0) bronum = 1; else bronum = mynum - 1; b = f-&gt;ptr[bronum]; if (b-&gt;keynum == (m + 1) / 2 - 1) //如果兄弟帮不了你了 &#123; //那么就和这个兄弟合体 if (bronum &lt; mynum) //如果我不是第一个 &#123; b-&gt;keynum++; b-&gt;key[b-&gt;keynum] = f-&gt;key[mynum]; b-&gt;ptr[b-&gt;keynum] = T-&gt;ptr[0]; for (index = 1;index &lt;= T-&gt;keynum;index++) &#123; b-&gt;key[index + b-&gt;keynum] = T-&gt;key[index]; b-&gt;ptr[index + b-&gt;keynum] = T-&gt;ptr[index]; b-&gt;keynum++; &#125; free(T); for (index = mynum;index &lt;= f-&gt;keynum;index++) &#123; f-&gt;key[index] = f-&gt;key[index + 1]; f-&gt;ptr[index] = f-&gt;ptr[index + 1]; &#125; f-&gt;keynum--; &#125; else &#123; T-&gt;keynum++; T-&gt;key[T-&gt;keynum] = f-&gt;key[bronum]; T-&gt;ptr[T-&gt;keynum] = b-&gt;ptr[0]; for (index = 1;index &lt;= b-&gt;keynum;index++) &#123; T-&gt;key[index + T-&gt;keynum] = b-&gt;key[index]; T-&gt;ptr[index + T-&gt;keynum] = b-&gt;ptr[index]; T-&gt;keynum++; &#125; free(b); for (index = bronum;index &lt;= f-&gt;keynum;index++) &#123; f-&gt;key[index] = f-&gt;key[index + 1]; f-&gt;ptr[index] = f-&gt;ptr[index + 1]; &#125; f-&gt;keynum--; &#125; renewParent(f); if (f-&gt;keynum == (m + 1) / 2 - 2) &#123; //调用借兄弟的函数 return borrowBNode(f); &#125; &#125; else//如果兄弟能够帮你 &#123; if (bronum &lt; mynum) //如果我不是第一个 &#123; for (index = 1;index &lt;= T-&gt;keynum;index++) &#123; T-&gt;key[index + 1] = T-&gt;key[index]; T-&gt;ptr[index + 1] = T-&gt;ptr[index]; &#125; T-&gt;ptr[1] = T-&gt;ptr[0]; T-&gt;key[1] = f-&gt;key[mynum]; T-&gt;ptr[0] = b-&gt;ptr[b-&gt;keynum]; T-&gt;keynum++; f-&gt;key[mynum] = b-&gt;key[b-&gt;keynum]; b-&gt;key[b-&gt;keynum] = 0; b-&gt;ptr[b-&gt;keynum] = NULL; b-&gt;keynum--; &#125; else //如果我是第一个 &#123; T-&gt;keynum++; T-&gt;key[T-&gt;keynum] = f-&gt;key[1]; T-&gt;ptr[T-&gt;keynum] = b-&gt;ptr[0]; f-&gt;key[1] = b-&gt;key[1]; b-&gt;ptr[0] = b-&gt;ptr[1]; for (index = 1;index &lt;= b-&gt;keynum;index++) &#123; b-&gt;key[index] = b-&gt;key[index + 1]; b-&gt;ptr[index] = b-&gt;ptr[index + 1]; &#125; b-&gt;keynum--; &#125; &#125; return OK;&#125; 完整代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798991001011021031041051061071081091101111121131141151161171181191201211221231241251261271281291301311321331341351361371381391401411421431441451461471481491501511521531541551561571581591601611621631641651661671681691701711721731741751761771781791801811821831841851861871881891901911921931941951961971981992002012022032042052062072082092102112122132142152162172182192202212222232242252262272282292302312322332342352362372382392402412422432442452462472482492502512522532542552562572582592602612622632642652662672682692702712722732742752762772782792802812822832842852862872882892902912922932942952962972982993003013023033043053063073083093103113123133143153163173183193203213223233243253263273283293303313323333343353363373383393403413423433443453463473483493503513523533543553563573583593603613623633643653663673683693703713723733743753763773783793803813823833843853863873883893903913923933943953963973983994004014024034044054064074084094104114124134144154164174184194204214224234244254264274284294304314324334344354364374384394404414424434444454464474484494504514524534544554564574584594604614624634644654664674684694704714724734744754764774784794804814824834844854864874884894904914924934944954964974984995005015025035045055065075085095105115125135145155165175185195205215225235245255265275285295305315325335345355365375385395405415425435445455465475485495505515525535545555565575585595605615625635645655665675685695705715725735745755765775785795805815825835845855865875885895905915925935945955965975985996006016026036046056066076086096106116126136146156166176186196206216226236246256266276286296306316326336346356366376386396406416426436446456466476486496506516526536546556566576586596606616626636646656666676686696706716726736746756766776786796806816826836846856866876886896906916926936946956961 #define _CRT_SECURE_NO_WARNINGS2 #include&lt;stdio.h&gt; 3 #include&lt;stdlib.h&gt;4 #include&lt;time.h&gt; 5 #define BTREELENGTH 506 #define BTLEN (sizeof(BTNode))7 #define MAXINT 100 8 typedef enum status9 &#123; 10 TRUE, 11 FALSE, 12 OK, 13 ERROR, 14 OVERFLOW, 15 EMPTY 16 &#125;Status; 17 typedef int KeyType; 18 19 //**********************************B树**************************************** 20 #define m 3 // B树的阶，此设为4 21 typedef struct 22 &#123; 23 KeyType key; 24 char data; 25 &#125; Record; 26 typedef struct BTNode 27 &#123; 28 int keynum; // 结点中关键字个数，即结点的大小 29 struct BTNode *parent; // 指向双亲结点 30 KeyType key[m + 1]; // 关键字向量，0号单元未用 31 struct BTNode *ptr[m + 1]; // 子树指针向量 32 // Record *recptr[m + 1]; // 记录指针向量，0号单元未用 33 //在此添加其他自定义数据 34 &#125; BTNode, *BTree; // B树结点和B树的类型 35 typedef struct 36 &#123; 37 BTNode *pt; // 指向找到的结点 38 int i; // 1..m，在结点中的关键字序号 39 int tag; // 1:查找成功，0:查找失败 40 &#125; Result; // 在B树的查找结果类型 41 //**********************************B树**************************************** 42 43 //**********************************队列*************************************** 44 typedef struct LNode &#123; 45 BTree data; // 数据域 46 struct LNode *next; // 指针域 47 &#125; LNode, *LinkList; 48 //**********************************队列*************************************** 49 50 /*** 51 * @name Status InitQueue_L(LinkList &amp;L) 52 * @description 初始化队列 53 * @return 成功返回OK，开辟空间失败返回OVERFLOW 54 * @notice 55 ***/ 56 Status InitQueue_L(LinkList &amp;L) 57 &#123; // 初始化一个只含头结点的空单链表L 58 if (NULL == (L = (LNode*)malloc(sizeof(LNode)))) // 生成新结点 59 return OVERFLOW; 60 L-&gt;next = NULL; 61 return OK; 62 &#125; 63 /*** 64 * @name LNode* MakeNode_L(BTree e) 65 * @description 构造队列结点 66 * @return 返回结点地址 67 * @notice 68 ***/ 69 LNode* MakeNode_L(BTree e) 70 &#123; // 构造数据域为e的单链表结点 71 LNode *p; 72 p = (LNode*)malloc(sizeof(LNode)); // 分配结点空间 73 if (p != NULL) 74 &#123; 75 p-&gt;data = e; 76 p-&gt;next = NULL; 77 &#125; 78 return p; 79 &#125; 80 /*** 81 * @name Status Enqueue_L(LNode *p, BTree e) 82 * @description 队列的入队 83 * @return 成功返回OK，否则返回ERROR 84 * @notice 85 ***/ 86 Status Enqueue_L(LNode *p, BTree e) 87 &#123; //在p结点之后插入q结点 88 if (NULL == p) return ERROR; // 参数不合理 89 while (p-&gt;next != NULL) 90 p = p-&gt;next; 91 p-&gt;next = MakeNode_L(e); // 对应图4.11（b）的②，修改p结点的指针域 92 return OK; 93 &#125; 94 95 /*** 96 * @name Status Dequeue_L(LNode *p, BTree &amp;e) 97 * @description 队列的出队 98 * @return 成功返回OK，否则返回ERROR 99 * @notice100 ***/101 Status Dequeue_L(LNode *p, BTree &amp;e)102 &#123;103 // 删除p结点的直接后继结点并用参数e返回被删结点的值104 LNode *q;105 if (NULL == p || NULL == p-&gt;next) return ERROR; // 删除位置不合理 106 q = p-&gt;next;107 p-&gt;next = q-&gt;next; // 修改被删结点q的指针域108 e = q-&gt;data;109 free(q); // 释放结点q110 return OK;111 &#125;112 113 /***114 * @name void DestroyQueue(LinkList L)115 * @description 队列的销毁116 * @return 无返回117 * @notice118 ***/119 void DestroyQueue(LinkList L)120 &#123;121 // 销毁整个链表122 LinkList p;123 if (L != NULL)124 &#123;125 p = L;126 L = L-&gt;next;127 free(p);128 DestroyQueue(L);129 &#125;130 &#125;131 /***132 * @name Status IfEmpty(LinkList L)133 * @description 判断队列是否为空134 * @return 空返回TRUE，不空返回FALSE，否则返回ERROR135 * @notice 136 ***/137 Status IfEmpty(LinkList L)138 &#123;139 if (L == NULL) return ERROR;140 if (L-&gt;next == NULL) return TRUE;141 return FALSE;142 &#125;143 /***144 * @name Status ergodic(BTree T, LinkList L, int newline, int sum)145 * @description print需要用到的递归遍历程序146 * @return 成功返回OK147 * @notice 此处用到队列148 ***/149 Status ergodic(BTree T, LinkList L, int newline, int sum)150 &#123;151 int index;152 BTree p;153 if (T != NULL)154 &#123;155 printf(&quot;[ &quot;);156 Enqueue_L(L, T-&gt;ptr[0]);157 for (index = 1;index &lt;= T-&gt;keynum; index++)158 &#123;159 printf(&quot;%d &quot;, T-&gt;key[index]);160 Enqueue_L(L, T-&gt;ptr[index]);161 &#125;162 sum += T-&gt;keynum + 1;163 printf(&quot;]&quot;);164 if (newline == 0)165 &#123;166 printf(&quot;\n&quot;);167 newline = sum - 1;168 sum = 0;169 &#125;170 else171 &#123;172 --newline;173 &#125;174 &#125;175 if (IfEmpty(L) == FALSE)176 &#123;177 Dequeue_L(L, p);178 ergodic(p, L, newline, sum);179 &#125;180 return OK;181 &#125;182 /***183 * @name Status print(BTree T)184 * @description 层次遍历并分层输出B树185 * @return 成功返回OK186 * @notice187 ***/188 Status print(BTree T)189 &#123;190 LinkList L;191 if (T == NULL)192 &#123;193 printf(&quot;[ ]\n&quot;);194 return OK;195 &#125;196 InitQueue_L(L);197 ergodic(T, L, 0, 0);198 DestroyQueue(L);199 return OK;200 &#125;201 202 /***203 * @name Status findMax(BTree T, BTree &amp;p,int ans)204 * @description 寻找最大关键字的结点,T为要寻找的树，p为返回的节点,ans为第几个205 * @return 成功返回OK,否则返回ERROR206 * @notice207 ***/208 Status findMax(BTree T, BTree &amp;p, int &amp;ans)209 &#123;210 if (T == NULL)211 return ERROR;212 p = T;213 while (p-&gt;ptr[p-&gt;keynum] != NULL)214 &#123;215 p = p-&gt;ptr[p-&gt;keynum];216 &#125;217 ans = p-&gt;keynum;218 return OK;219 &#125;220 /***221 * @name Status findMin(BTree T, BTree &amp;p,int ans)222 * @description 寻找最小关键字的结点,T为要寻找的树，p为返回的节点,ans为第几个223 * @return 成功返回OK,否则返回ERROR224 * @notice225 ***/226 /***227 * @name Status findBTree(BTree T, BTree &amp;p, int &amp;ans, KeyType k)228 * @description 寻找 ,T为要寻找的树，p为返回的节点，ans为第几个元素，k为要找的值229 * @return 成功返回OK,否则返回ERROR230 * @notice231 ***/232 Status findBTree(BTree T, BTree &amp;p, int &amp;ans, KeyType k)233 &#123;234 BTree q;235 int index = 1;236 KeyType keynow;237 if (T == NULL)238 return ERROR;239 q = T;240 keynow = T-&gt;key[1];241 while (q != NULL) //深度的遍历242 &#123;243 index = 1;244 keynow = q-&gt;key[index];245 while (index &lt;= q-&gt;keynum) //节点内对各真值进行遍历246 &#123;247 if (k == keynow) //找到元素248 &#123;249 p = q;250 ans = index;251 return TRUE;252 &#125;253 if (k &gt; keynow)254 &#123;255 if (index == q-&gt;keynum)256 &#123;257 if (q-&gt;ptr[index] == NULL)258 &#123;259 p = q;260 ans = q-&gt;keynum + 1;261 return FALSE;262 &#125;263 q = q-&gt;ptr[index];264 break;265 &#125;266 ++index;267 keynow = q-&gt;key[index];268 continue;269 &#125;270 if (k &lt; keynow)271 &#123;272 if (q-&gt;ptr[index - 1] == NULL)273 &#123;274 p = q;275 ans = index;276 return FALSE;277 &#125;278 q = q-&gt;ptr[index - 1];279 break;280 &#125;281 &#125;282 &#125;283 284 return ERROR;285 &#125;286 /***287 * @name Status renewParent(BTree p)288 * @description 告诉孩子们亲身爸爸是谁289 * @return 成功返回OK,否则返回ERROR290 * @notice291 ***/292 Status renewParent(BTree p)293 &#123;294 int index;295 if (p == NULL) return ERROR;296 for (index = 0;index &lt;= p-&gt;keynum;++index)297 &#123;298 if (p-&gt;ptr[index] != NULL)299 &#123;300 p-&gt;ptr[index]-&gt;parent = p;301 renewParent(p-&gt;ptr[index]);302 &#125;303 &#125;304 return OK;305 &#125;306 /***307 * @name int whichSon(BTree T)308 * @description 找出是父亲的第几个孩子309 * @return 成功返回第几个孩子,否则返回-1310 * @notice311 ***/312 int whichSon(BTree T)313 &#123;314 int index = -1;315 if (T == NULL) return -1;316 for (index = 0;index &lt;= T-&gt;parent-&gt;keynum;++index) //找出是父亲的第几个孩子317 &#123;318 if (T-&gt;parent-&gt;ptr[index] == T) return index;319 &#125;320 return -1;321 &#125;322 /***323 * @name status splitBTree(BTree T)324 * @description 递归实现分裂节点操作325 * @return 成功返回OK,否则返回ERROR326 * @notice327 ***/328 Status splitBTree(BTree T) //此时分裂的节点一定会是超出最大值的。329 &#123;330 BTree t1, t2;331 int index, index_1;332 if (T-&gt;parent == NULL)333 &#123;334 t1 = (BTree)malloc(BTLEN);335 if (NULL == t1) return OVERFLOW;336 t2 = (BTree)malloc(BTLEN);337 if (NULL == t2) return OVERFLOW;338 339 t1-&gt;keynum = m / 2;340 t2-&gt;keynum = m - (m / 2) - 1;341 t1-&gt;parent = T;342 t2-&gt;parent = T;343 for (index = 0;index &lt;= m; ++index) //先全部初始化344 &#123;345 t1-&gt;ptr[index] = NULL;346 t1-&gt;key[index] = 0;347 t2-&gt;ptr[index] = NULL;348 t2-&gt;key[index] = 0;349 &#125;350 for (index = 0;index &lt;= m / 2; ++index) //初始化t1351 &#123;352 t1-&gt;ptr[index] = T-&gt;ptr[index];353 t1-&gt;key[index] = T-&gt;key[index];354 &#125;355 t2-&gt;ptr[0] = T-&gt;ptr[(m / 2) + 1];356 for (index = (m / 2) + 2;index &lt;= m; ++index) //初始化t2357 &#123;358 t2-&gt;ptr[index - ((m / 2) + 1)] = T-&gt;ptr[index];359 t2-&gt;key[index - ((m / 2) + 1)] = T-&gt;key[index];360 &#125;361 T-&gt;keynum = 1;362 T-&gt;ptr[0] = t1;363 T-&gt;ptr[1] = t2;364 T-&gt;key[1] = T-&gt;key[m / 2 + 1];365 for (index = 2;index &lt;= m; ++index) //初始化T366 &#123;367 T-&gt;ptr[index] = NULL;368 T-&gt;key[index] = 0;369 &#125;370 return OK;371 &#125;372 373 index = whichSon(T);374 for (index_1 = T-&gt;parent-&gt;keynum;index_1 &gt; index;--index_1) //腾出父亲的位置375 &#123;376 T-&gt;parent-&gt;ptr[index_1 + 1] = T-&gt;parent-&gt;ptr[index_1];377 T-&gt;parent-&gt;key[index_1 + 1] = T-&gt;parent-&gt;key[index_1];378 &#125;379 T-&gt;parent-&gt;keynum++;380 T-&gt;parent-&gt;key[index + 1] = T-&gt;key[m / 2 + 1];381 t2 = T-&gt;parent-&gt;ptr[index + 1] = (BTree)malloc(BTLEN);382 if (NULL == t2) return OVERFLOW;383 for (index = 0;index &lt;= m; ++index) //先全部初始化384 &#123;385 t2-&gt;ptr[index] = NULL;386 t2-&gt;key[index] = 0;387 &#125;388 t2-&gt;keynum = m - (m / 2) - 1;389 t2-&gt;parent = T-&gt;parent;390 t2-&gt;ptr[0] = T-&gt;ptr[(m / 2) + 1];391 for (index = (m / 2) + 2;index &lt;= m; ++index) //初始化t2392 &#123;393 t2-&gt;ptr[index - ((m / 2) + 1)] = T-&gt;ptr[index];394 t2-&gt;key[index - ((m / 2) + 1)] = T-&gt;key[index];395 &#125;396 T-&gt;keynum = m / 2;397 for (index = (m / 2) + 1;index &lt;= m; ++index) //初始化t2398 &#123;399 T-&gt;ptr[index] = NULL;400 T-&gt;key[index] = 0;401 &#125;402 if (T-&gt;parent-&gt;keynum == m)403 &#123;404 splitBTree(T-&gt;parent);405 &#125;406 return OK;407 &#125;408 /***409 * @name Status insertBTree(BTree &amp;T, Record e)410 * @description 插入实现元素的插入411 * @return 成功返回OK,如果存在则返回FALSE，否则返回ERROR412 * @notice413 ***/414 Status insertBTree(BTree &amp;T, Record e)415 &#123;416 BTree p;417 int index, temp;418 Status find_flag;419 if (NULL == T)420 &#123;421 T = (BTree)malloc(BTLEN);422 if (NULL == T) return OVERFLOW;423 T-&gt;keynum = 1;424 T-&gt;parent = NULL;425 for (index = 0;index &lt;= m; ++index)426 &#123;427 T-&gt;ptr[index] = NULL;428 T-&gt;key[index] = 0;429 &#125;430 T-&gt;key[1] = e.key;431 return OK;432 &#125;433 find_flag = findBTree(T, p, temp, e.key);434 if (find_flag == TRUE)435 &#123;436 return FALSE;437 &#125;438 if (find_flag == FALSE)439 &#123; //不管怎样先直接插入440 p-&gt;keynum++;441 for (index = p-&gt;keynum;index &gt; temp;--index) //挪位置442 &#123;443 p-&gt;key[index] = p-&gt;key[index - 1];444 p-&gt;ptr[index] = p-&gt;ptr[index - 1];445 &#125;446 p-&gt;ptr[temp] = NULL;447 p-&gt;key[temp] = e.key;448 if (p-&gt;keynum == m) //这种情况得分裂449 &#123;450 splitBTree(p);451 &#125;452 renewParent(T);453 return OK;454 &#125;455 return ERROR;456 &#125;457 /***458 * @name Status borrowBNode(BTree &amp;T)459 * @description 递归实现，向兄弟借元素，否则和兄弟合并460 * @return 成功返回OK,否则返回ERROR461 * @notice 这种情况应该是T为单元素结点462 ***/463 Status borrowBNode(BTree T)464 &#123;465 int mynum, bronum, index;466 BTree b = NULL, f = NULL;467 if (T == NULL) return ERROR;468 f = T-&gt;parent;469 if (f == NULL)//考虑父亲结点不存在的情况470 &#123;471 if (T-&gt;keynum == 0)472 &#123;473 f = T-&gt;ptr[0];474 if (f == NULL)475 &#123;476 free(T);477 return EMPTY;478 &#125;479 for (index = 0;index &lt;= f-&gt;keynum;index++)480 &#123;481 T-&gt;key[index] = f-&gt;key[index];482 T-&gt;ptr[index] = f-&gt;ptr[index];483 &#125;484 T-&gt;keynum = f-&gt;keynum;485 free(f);486 renewParent(T);487 &#125;488 return OK;489 &#125;490 mynum = whichSon(T);491 if (mynum == 0)492 bronum = 1;493 else494 bronum = mynum - 1;495 b = f-&gt;ptr[bronum];496 if (b-&gt;keynum == (m + 1) / 2 - 1) //如果兄弟帮不了你了497 &#123;498 //那么就和这个兄弟合体499 if (bronum &lt; mynum) //如果我不是第一个500 &#123;501 b-&gt;keynum++;502 b-&gt;key[b-&gt;keynum] = f-&gt;key[mynum];503 b-&gt;ptr[b-&gt;keynum] = T-&gt;ptr[0];504 for (index = 1;index &lt;= T-&gt;keynum;index++)505 &#123;506 b-&gt;key[index + b-&gt;keynum] = T-&gt;key[index];507 b-&gt;ptr[index + b-&gt;keynum] = T-&gt;ptr[index];508 b-&gt;keynum++;509 &#125;510 free(T);511 for (index = mynum;index &lt;= f-&gt;keynum;index++)512 &#123;513 f-&gt;key[index] = f-&gt;key[index + 1];514 f-&gt;ptr[index] = f-&gt;ptr[index + 1];515 &#125;516 f-&gt;keynum--;517 &#125;518 else519 &#123;520 T-&gt;keynum++;521 T-&gt;key[T-&gt;keynum] = f-&gt;key[bronum];522 T-&gt;ptr[T-&gt;keynum] = b-&gt;ptr[0];523 for (index = 1;index &lt;= b-&gt;keynum;index++)524 &#123;525 T-&gt;key[index + T-&gt;keynum] = b-&gt;key[index];526 T-&gt;ptr[index + T-&gt;keynum] = b-&gt;ptr[index];527 T-&gt;keynum++;528 &#125;529 free(b);530 for (index = bronum;index &lt;= f-&gt;keynum;index++)531 &#123;532 f-&gt;key[index] = f-&gt;key[index + 1];533 f-&gt;ptr[index] = f-&gt;ptr[index + 1];534 &#125;535 f-&gt;keynum--;536 &#125;537 renewParent(f);538 if (f-&gt;keynum == (m + 1) / 2 - 2)539 &#123;540 //调用借兄弟的函数541 return borrowBNode(f);542 &#125;543 &#125;544 else//如果兄弟能够帮你545 &#123;546 if (bronum &lt; mynum) //如果我不是第一个547 &#123;548 for (index = 1;index &lt;= T-&gt;keynum;index++)549 &#123;550 T-&gt;key[index + 1] = T-&gt;key[index];551 T-&gt;ptr[index + 1] = T-&gt;ptr[index];552 &#125;553 T-&gt;ptr[1] = T-&gt;ptr[0];554 T-&gt;key[1] = f-&gt;key[mynum];555 T-&gt;ptr[0] = b-&gt;ptr[b-&gt;keynum];556 T-&gt;keynum++;557 f-&gt;key[mynum] = b-&gt;key[b-&gt;keynum];558 b-&gt;key[b-&gt;keynum] = 0;559 b-&gt;ptr[b-&gt;keynum] = NULL;560 b-&gt;keynum--;561 562 &#125;563 else //如果我是第一个564 &#123;565 T-&gt;keynum++;566 T-&gt;key[T-&gt;keynum] = f-&gt;key[1];567 T-&gt;ptr[T-&gt;keynum] = b-&gt;ptr[0];568 f-&gt;key[1] = b-&gt;key[1];569 b-&gt;ptr[0] = b-&gt;ptr[1];570 for (index = 1;index &lt;= b-&gt;keynum;index++)571 &#123;572 b-&gt;key[index] = b-&gt;key[index + 1];573 b-&gt;ptr[index] = b-&gt;ptr[index + 1];574 &#125;575 b-&gt;keynum--;576 &#125;577 &#125;578 return OK;579 &#125;580 581 /***582 * @name Status deleteBTreeRecord(BTree &amp;T, Record e)583 * @description 实现B树元素的删除584 * @return 成功返回OK,否则返回ERROR585 * @notice586 ***/587 Status deleteBTreeRecord(BTree &amp;T, Record e)588 &#123;589 BTree p, q;590 int num, temp, index;591 Status find_flag;592 if (T == NULL)593 return ERROR;594 find_flag = findBTree(T, p, temp, e.key);595 if (find_flag == FALSE)596 &#123;597 return FALSE;598 &#125;599 if (find_flag == TRUE)600 &#123;601 //deleteBTreeBNode(p,temp);602 if (p-&gt;ptr[temp] == NULL) //如果是叶子节点的话603 &#123;604 for (index = temp;index &lt;= p-&gt;keynum;++index)605 &#123;606 p-&gt;key[index] = p-&gt;key[index + 1];607 p-&gt;ptr[index] = p-&gt;ptr[index + 1];608 &#125;609 p-&gt;keynum--;610 if (p-&gt;keynum == (m + 1) / 2 - 2)611 &#123;612 //调用借兄弟的函数613 if (borrowBNode(p) == EMPTY) T = NULL;614 else renewParent(T);615 &#125;616 return OK;617 &#125;618 else //不是叶子结点的话619 &#123;620 //遍历621 findMax(p-&gt;ptr[temp - 1], q, num);//返回的q一定会是叶子节点622 p-&gt;key[temp] = q-&gt;key[num];623 q-&gt;key[num] = 0;624 q-&gt;keynum--;625 if (q-&gt;keynum == (m + 1) / 2 - 2)626 &#123;627 //调用借兄弟的函数628 if (borrowBNode(q) == EMPTY) T = NULL;629 else renewParent(T);630 &#125;631 return OK;632 &#125;633 return OK;634 &#125;635 return ERROR;636 &#125;637 /***638 * @name Status initBTree(BTree &amp;t)639 * @description 初始化一个空B树640 * @return 成功返回OK641 * @notice642 ***/643 Status initBTree(BTree &amp;t)644 &#123;645 t = NULL;646 return OK;647 &#125;648 /***649 * @name Status test()650 * @description 针对数据结构实验做的测试函数651 * @return 成功返回OK652 * @notice653 ***/654 Status test()655 &#123;656 // 测试代码657 int n, i;658 int arr[BTREELENGTH];659 BTree a;660 Record d;661 srand((unsigned)time(NULL));662 n = rand() % BTREELENGTH;663 //scanf(&quot;%d&quot;, &amp;n); //可以改为自己输入数据664 printf(&quot;B树的阶为:%d,插入次数为:%d\n&quot;, m, n);665 initBTree(a);666 for (i = 0;i &lt; n;i++)667 &#123;668 d.key = rand() % MAXINT;669 //scanf(&quot;%d&quot;, &amp;d.key); //可以改为自己输入数据670 arr[i] = d.key;671 if (insertBTree(a, d) == OK)672 printf(&quot;第%d次插入%d:\n&quot;, i + 1, d.key);673 else674 printf(&quot;第%d次插入%d不成功:\n&quot;, i + 1, d.key);675 print(a);676 &#125;677 for (i = 0;i &lt; n;i++)678 &#123;679 d.key = arr[i];680 if (deleteBTreeRecord(a, d) == OK)681 printf(&quot;第%d次删除%d:\n&quot;, i + 1, d.key);682 else683 printf(&quot;第%d次删除%d不成功:\n&quot;, i + 1, d.key);684 print(a);685 &#125;686 return OK;687 688 &#125;689 /***690 主函数691 ***/692 int main()693 &#123;694 test();695 return 0;696 &#125; B+树]]></content>
      <categories>
        <category>基础</category>
      </categories>
      <tags>
        <tag>B树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[查找与排序-KMP算法栈队列]]></title>
    <url>%2F2020%2F09%2F12%2F%E6%9F%A5%E6%89%BE%E4%B8%8E%E6%8E%92%E5%BA%8F-KMP%E7%AE%97%E6%B3%95%E6%A0%88%E9%98%9F%E5%88%97%2F</url>
    <content type="text"><![CDATA[冒泡排序选择排序首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置，然后，再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。以此类推，直到所有元素均排序完毕。 稳定性：不稳定 插入排序通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。插入排序因而在从后向前扫描过程中，需要反复把已排序元素逐步向后挪位，为最新元素提供插入空间。 例子：拿扑克牌排序 Input: {4, 3, 8, 5, 2, 6, 1, 7}。 首先拿起第一张牌, 手上有 {4}。 拿起第二张牌 3, 把 3insert 到手上的牌 {4}, 得到 {3 ，4}。 拿起第三张牌 8, 把 8 insert 到手上的牌 {3，4 }, 得到 {3 ，4，8}。 以此类推。 稳定性：稳定 希尔排序分治做法，先分组，把自己组内的先排好序，再合并 1234567891011121314void shell_sort(int *data, int length) &#123; int gap = 0; int i = 0, j = 0; for (gap = length / 2; gap &gt;= 1; gap /= 2) &#123; // 第一层是分组 for (i = gap; i &lt; length; i++) &#123; // 第二层是先保证前面有序，再遍历后面 int temp = data[i]; for (j = i - gap; j &gt;= 0 &amp;&amp; temp &lt; data[j]; j -= gap) &#123; //把大的挪到后面 data[j + gap] = data[j]; &#125; data[j + gap] = temp; &#125; &#125;&#125; 平均O(1.3n) 归并排序分治，把一个集合分成两部分，第一部分再分成两部分，第二部分再分成两部分，直到分到最后一层是两块。 12345678910111213141516171819202122232425262728void sort(int *data, int *temp, int start, int mid, int end) &#123; int i = start, j = mid + 1, k = start; while (i &lt;= mid &amp;&amp; j &lt;= end) &#123; if (data[i] &lt; data[j]) &#123; temp[k++] = data[i++]; &#125; else &#123; temp[k++] = data[j++]; &#125; &#125; while (i &lt;= mid) &#123; temp[k++] = data[i++]; &#125; while (j &lt;= end) &#123; temp[k++] = data[j++]; &#125; for (i = start; i &lt;= end; i++) &#123; data[i] = temp[i]; &#125;&#125;void merge_sort(int *data, int *temp, int start, int end) &#123; if (start &lt; end) &#123; int mid = start + (end - start) / 2; merge_sort(data, temp, start, mid); merge_sort(data, temp, mid + 1, end); sort(data, temp, start, mid, end); &#125;&#125; 最差和最好都是 O(nlogn) 稳定 快速排序第一个值作为哨兵位，从最左端到最右端，如果满足条件，右端–，左端++，直到左端等于右端，那么就确定了哨兵位的位置，赋值即可。 123456789101112131415161718192021222324252627282930313233void sort(int *data, int left, int right) &#123; if (left &gt;= right) return ; int i = left; int j = right; int key = data[left]; while (i &lt; j) &#123; while (i &lt; j &amp;&amp; key &lt;= data[j]) &#123; j --; &#125; data[i] = data[j]; while (i &lt; j &amp;&amp; key &gt;= data[i]) &#123; i ++; &#125; data[j] = data[i]; &#125; data[i] = key; sort(data, left, i - 1); sort(data, i + 1, right);&#125;int quick_sort(int *data, int length) &#123; sort(data, 0, length-1);&#125; KMPtext = “abababababacsdkfasdf”ptn = “abab” 回溯多少。取决于共同前缀与后缀，有多少。abc -&gt; a/ab(前缀) c/bc（后缀）0aba -&gt; a/ab a/ba 1abcabc -&gt; a/ab/abc/abca/abcab c/bc/abc/cabc/bcabc 3 void make_next(const char *pattern, int *next) { int q, k; int m = strlen(pattern); next[0] = 0; for (q = 1,k = 0;q &lt; m; q ++) { while (k &gt; 0 &amp;&amp; pattern[q] != pattern[k]) k = next[k-1]; if (pattern[q] == pattern[k]) { k ++; } next[q] = k; } // next[0] = 0; // q=1, k=0, pattern[q]:pattern[k] = b:a, next[1] = 0; // q=2, k=0, pattern[q]:pattern[k] = c:a, next[2] = 0; // q=3, k=0, pattern[q]:pattern[k] = a:a, k++, next[3] = 1; // q=4, k=1, pattern[q]:pattern[k] = b:b, k++, next[4] = 2; // q=5, k=2, pattern[q]:pattern[k] = c:c, k++, next[5] = 3; // q=6, k=3, pattern[q]:pattern[k] = d:a, k=next[k-1] -&gt; k=0; next[6] = 0; } int kmp(const char *text, const char *pattern, int *next) { int n = strlen(text); int m = strlen(pattern); make_next(pattern, next); int i, q; for (i = 0, q = 0;i &lt; n;i ++) { while (q &gt; 0 &amp;&amp; pattern[q] != text[i]) { q = next[q-1]; } if (pattern[q] == text[i]) { q ++; } if (q == m) { //printf(&quot;Pattern occurs with shift: %d\n&quot;, (i-m+1)); break; } } return i-q+1; }]]></content>
      <categories>
        <category>基础</category>
      </categories>
      <tags>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[idea-maven工程配置]]></title>
    <url>%2F2018%2F08%2F04%2Fidea-maven%E5%B7%A5%E7%A8%8B%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[解决idea创建maven工程后无java,resouces文件问题 Project Structure Modules-Sources New Folder 解决创建properties文件问题 解决idea application context not configured for this file问题spring配置文件中时常会出现这个提示，翻译过来大概意思就是没有配置该文件到项目中 于是进入到file-Project Structure中查看 可以很明显的看到下面有个感叹号，大概意思是下面的文件没有匹配 知道原因就很好解决问题了，只需要加到项目中去就可以了 解决idea无法创建jsp文件问题File-&gt;Project Struction -&gt;modules 按加号 新增web,双击web resource directory 修改路径 web resource directory path 为 当前项目目录/src/webapp -&gt;WEB-INF-&gt;JSP]]></content>
      <categories>
        <category>idea</category>
      </categories>
      <tags>
        <tag>idea</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python 关于excel]]></title>
    <url>%2F2018%2F06%2F12%2FPython-%E5%85%B3%E4%BA%8Eexcel%2F</url>
    <content type="text"><![CDATA[read_excel()加载函数为read_excel(),其具体参数如下。 read_excel(io, sheetname=0, header=0, skiprows=None, skip_footer=0, index_col=None,names=None, parse_cols=None, parse_dates=False,date_parser=None,na_values=None,thousands=None, convert_float=True, has_index_names=None, converters=None,dtype=None, true_values=None, false_values=None, engine=None, squeeze=False, **kwds) 常用参数解析： io : string, path object ; excel 路径。 sheetname : string, int, mixed list of strings/ints, or None, default 0 返回多表使用sheetname=[0,1],若sheetname=None是返回全表 注意：int/string 返回的是dataframe，而none和list返回的是dict of dataframe header : int, list of ints, default 0 指定列名行，默认0，即取第一行，数据为列名行以下的数据 若数据不含列名，则设定 header = None skiprows : list-like,Rows to skip at the beginning，省略指定行数的数据 skip_footer : int,default 0, 省略从尾部数的int行数据 index_col : int, list of ints, default None指定列为索引列，也可以使用u”strings” names : array-like, default None, 指定列的名字。 举例sheet1: ID NUM-1 NUM-2 NUM-3 36901 142 168 661 36902 78 521 602 36903 144 600 521 36904 95 457 468 36905 69 596 695 sheet2： ID NUM-1 NUM-2 NUM-3 36906 190 527 691 36907 101 403 470 1.iobasestation =&quot;F://pythonBook_PyPDAM/data/test.xls&quot; data = pd.read_excel(basestation) print data 此时输出： ID NUM-1 NUM-2 NUM-3 0 36901 142 168 661 1 36902 78 521 602 2 36903 144 600 521 3 36904 95 457 468 4 36905 69 596 695 2.sheetname返回多表使用sheetname=[0,1],若sheetname=None是返回全表 注意：int/string 返回的是dataframe，而none和list返回的是dict of dataframe data_1 = pd.read_excel(basestation,sheetname=[0,1]) print data_1 print type(data_1) 此时输出： OrderedDict([(0, ID NUM-1 NUM-2 NUM-3 0 36901 142 168 661 1 36902 78 521 602 2 36903 144 600 521 3 36904 95 457 468 4 36905 69 596 695), (1, ID NUM-1 NUM-2 NUM-3 0 36906 190 527 691 1 36907 101 403 470)]) 3.header指定列名行，默认0，即取第一行，数据为列名行以下的数据 若数据不含列名，则设定 header = None ，注意这里还有列名的一行。 data = pd.read_excel(basestation,header=None) print data 输出： 0 1 2 3 0 ID NUM-1 NUM-2 NUM-3 1 36901 142 168 661 2 36902 78 521 602 3 36903 144 600 521 4 36904 95 457 468 5 36905 69 596 695 data = pd.read_excel(basestation,header=[3]) print data 输出： 36903 144 600 521 0 36904 95 457 468 1 36905 69 596 695 4.skiprows省略指定行数的数据 data = pd.read_excel(basestation,skiprows = [1]) print data 输出: ID NUM-1 NUM-2 NUM-3 0 36902 78 521 602 1 36903 144 600 521 2 36904 95 457 468 3 36905 69 596 695 5.skip_footer省略从尾部数的int行的数据 data = pd.read_excel(basestation, skip_footer=3) print data 输出： ID NUM-1 NUM-2 NUM-3 0 36901 142 168 661 1 36902 78 521 602 6.index_col指定列为索引列，也可以使用u”strings” data = pd.read_excel(basestation, index_col=&quot;NUM-3&quot;) print data 输出： ID NUM-1 NUM-2 NUM-3 661 36901 142 168 602 36902 78 521 521 36903 144 600 468 36904 95 457 695 36905 69 596 7.names指定列的名字 data = pd.read_excel(basestation,names=[&quot;a&quot;,&quot;b&quot;,&quot;c&quot;,&quot;e&quot;]) print data a b c e 0 36901 142 168 661 1 36902 78 521 602 2 36903 144 600 521 3 36904 95 457 468 4 36905 69 596 695 to_excel()存储函数为pd.DataFrame.to_excel() to_excel(self, excel_writer, sheet_name=’Sheet1’, na_rep=’’, float_format=None,columns=None, header=True, index=True, index_label=None,startrow=0, startcol=0, engine=None, merge_cells=True, encoding=None,inf_rep=’inf’, verbose=True, freeze_panes=None) excel_writer : 目标路径 sheet_name : 填充excel的第几页 na_rep : excel中缺失值的填充 float_format : string, default None Format string for floating point numbers columns : sequence, optional，Columns to write 选择输出的的列。 header : boolean or list of string, default True Write out column names. If a list of string is given it is assumed to be aliases for the column names index : boolean, default True，Write row names (index) index_label : string or sequence, default None， Column label for index column(s) if desired. If None is given, andheader and index are True, then the index names are used. A sequence should be given if the DataFrame uses MultiIndex. startrow :upper left cell row to dump data frame startcol :upper left cell column to dump data frame engine : string, default None ，write engine to use - you can also set this via the options，io.excel.xlsx.writer, io.excel.xls.writer, andio.excel.xlsm.writer. merge_cells : boolean, default True Write MultiIndex and Hierarchical Rows as merged cells. encoding: string, default None encoding of the resulting excel file. Only necessary for xlwt,other writers support unicode natively. inf_rep : string, default ‘inf’ Representation for infinity (there is no native representation for infinity in Excel) freeze_panes : tuple of integer (length 2), default None Specifies the one-based bottommost row and rightmost column that is to be frozen 数据源： ID NUM-1 NUM-2 NUM-3 0 36901 142 168 661 1 36902 78 521 602 2 36903 144 600 521 3 36904 95 457 468 4 36905 69 596 695 5 36906 165 453 加载数据： basestation =&quot;F://python/data/test.xls&quot; basestation_end =&quot;F://python/data/test_end.xls&quot; data = pd.read_excel(basestation) 1.excel_writer输出路径 data.to_excel(basestation_end) 输出： ID NUM-1 NUM-2 NUM-3 0 36901 142 168 661 1 36902 78 521 602 2 36903 144 600 521 3 36904 95 457 468 4 36905 69 596 695 5 36906 165 453 2.sheet_name将数据存储在excel的那个sheet页面 data.to_excel(basestation_end,sheet_name=&quot;sheet2&quot;) 3.na_rep缺失值填充 data.to_excel(basestation_end,na_rep=&quot;NULL&quot;) 输出： ID NUM-1 NUM-2 NUM-3 0 36901 142 168 661 1 36902 78 521 602 2 36903 144 600 521 3 36904 95 457 468 4 36905 69 596 695 5 36906 165 453 NULL 4.colums选择输出的的列 data.to_excel(basestation_end,columns=[&quot;ID&quot;]) 输出 ID 0 36901 1 36902 2 36903 3 36904 4 36905 5 36906 5.header默认为True,可以用list命名列的名字。header = False 则不输出题头 data.to_excel(basestation_end,header=[&quot;a&quot;,&quot;b&quot;,&quot;c&quot;,&quot;d&quot;]) 输出： a b c d 0 36901 142 168 661 1 36902 78 521 602 2 36903 144 600 521 3 36904 95 457 468 4 36905 69 596 695 5 36906 165 453 data.to_excel(basestation_end,header=False,columns=[&quot;ID&quot;]) header = False 则不输出题头 输出： 0 36901 1 36902 2 36903 3 36904 4 36905 5 36906 6.index默认为True，显示index，当index=False 则不显示行索引（名字） index_label : string or sequence, default None设置索引列的列名 data.to_excel(basestation_end,index=False) 输出： ID NUM-1 NUM-2 NUM-3 36901 142 168 661 36902 78 521 602 36903 144 600 521 36904 95 457 468 36905 69 596 695 36906 165 453 data.to_excel(basestation_end,index_label=[&quot;f&quot;]) 输出： f ID NUM-1 NUM-2 NUM-3 0 36901 142 168 661 1 36902 78 521 602 2 36903 144 600 521 3 36904 95 457 468 4 36905 69 596 695 5 36906 165 453 以上为read_excel,to_excel用法，若是想对已经读出的excel文件有所操作，请转移：https://blog.csdn.net/liufang0001/article/details/77856255]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python-tkinter-简单使用介绍]]></title>
    <url>%2F2018%2F05%2F30%2Fpython-tkinter-%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8%E4%BB%8B%E7%BB%8D%2F</url>
    <content type="text"><![CDATA[本文主要介绍几个简单的tkinter组件。 说明每个控件最后要加上pack().否则控件是无法显示的. Label说明 标签 举例 from Tkinter import * root = Tk() root.title(&quot;hello world&quot;) root.geometry(&apos;300x200&apos;) l = Label(root, text=&quot;show&quot;, bg=&quot;green&quot;, font=(&quot;Arial&quot;, 12), width=5, height=2) l.pack(side=LEFT) #这里的side可以赋值为LEFT RTGHT TOP BOTTOM root.mainloop() 效果 Frame说明 在屏幕上创建一块矩形区域,多作为容器来布局窗体 举例 from Tkinter import * root = Tk() root.title(&quot;hello world&quot;) root.geometry(&apos;300x200&apos;) Label(root, text=&apos;校训&apos;, font=(&apos;Arial&apos;, 20)).pack() frm = Frame(root) # left frm_L = Frame(frm) Label(frm_L, text=&apos;厚德&apos;, font=(&apos;Arial&apos;, 15)).pack(side=TOP) Label(frm_L, text=&apos;博学&apos;, font=(&apos;Arial&apos;, 15)).pack(side=TOP) frm_L.pack(side=LEFT) # right frm_R = Frame(frm) Label(frm_R, text=&apos;敬业&apos;, font=(&apos;Arial&apos;, 15)).pack(side=TOP) Label(frm_R, text=&apos;乐群&apos;, font=(&apos;Arial&apos;, 15)).pack(side=TOP) frm_R.pack(side=RIGHT) frm.pack() root.mainloop() 效果 Entry说明 创建单行文本框 用法 创建:lb =Entry(根对象, [属性列表]) 绑定变量 var=StringVar() lb=Entry(根对象, textvariable = var) 获取文本框中的值 var.get() 设置文本框中的值 var.set(item1) 举例 from Tkinter import * root = Tk() root.title(&quot;hello world&quot;) root.geometry() var = StringVar() e = Entry(root, textvariable = var) var.set(&quot;hello&quot;) e.pack() root.mainloop() 效果 Text说明 向该空间内输入文本 用法 t = Text(根对象) 插入:t.insert(mark, 内容) 删除:t.delete(mark1, mark2) 其中,mark可以是行号,或者特殊标识,例如 INSERT:光标的插入点CURRENT:鼠标的当前位置所对应的字符位置 END:这个Textbuffer的最后一个字符 SEL_FIRST:选中文本域的第一个字符，如果没有选中区域则会引发异常 SEL_LAST：选中文本域的最后一个字符，如果没有选中区域则会引发 异常 举例 from Tkinter import * root = Tk() root.title(&quot;hello world&quot;) root.geometry(&apos;300x200&apos;) t = Text(root) t.insert(1.0, &apos;hello\n&apos;) t.insert(END, &apos;hello000000\n&apos;) t.insert(END, &apos;nono&apos;) t.pack() root.mainloop() 效果 Button说明 创建按钮 用法 Button(根对象, [属性列表]) 举例 from Tkinter import * root = Tk() root.title(&quot;hello world&quot;) root.geometry() def printhello(): t.insert(&apos;1.0&apos;, &quot;hello\n&quot;) t = Text() t.pack() Button(root, text=&quot;press&quot;, command = printhello).pack() root.mainloop() 效果 Listbox说明 列表控件,可以含有一个或多个文本想,可单选也可多选 用法 创建:lb = ListBox(根对象, [属性列表]) 绑定变量 var=StringVar() lb=ListBox(根对象, listvariable = var) 得到列表中的所有值 var.get() 设置列表中的所有值 var.set((item1, item2, …..)) 添加:lb.insert(item) 删除:lb.delete(item,…) 绑定事件 lb.bind(‘‘, 函数) 获得所选中的选项 lbl.get(lb.curselection()) 属性 selectmode可以为BROWSE MULTIPL SINGLE 举例 from Tkinter import * root = Tk() root.title(&quot;hello world&quot;) root.geometry() def print_item(event): print(lb.get(lb.curselection())) var = StringVar() lb = Listbox(root, listvariable = var) list_item = [1, 2, 3, 4] #控件的内容为1 2 3 4 for item in list_item: lb.insert(END, item) lb.delete(2, 4) #此时控件的内容为1 3 var.set((&apos;a&apos;, &apos;ab&apos;, &apos;c&apos;, &apos;d&apos;)) #重新设置了，这时控件的内容就编程var的内容了 print var.get() lb.bind(&apos;&lt;ButtonRelease-1&gt;&apos;, print_item) lb.pack() root.mainloop() 效果 Scrollbar说明 在屏幕上创建一块矩形区域,多作为容器来布局窗体 用法 Frame(根对象, [属性列表]), 最长用的用法是和别的控件一起使用. 举例 from Tkinter import * root = Tk() root.title(&quot;hello world&quot;) root.geometry() def print_item(event): print lb.get(lb.curselection()) var = StringVar() lb = Listbox(root, height=5, selectmode=BROWSE, listvariable = var) lb.bind(&apos;&lt;ButtonRelease-1&gt;&apos;, print_item) list_item = [1, 2, 3, 4, 5, 6, 7, 8, 9, 0] for item in list_item: lb.insert(END, item) scrl = Scrollbar(root) scrl.pack(side=RIGHT, fill=Y) lb.configure(yscrollcommand = scrl.set) lb.pack(side=LEFT, fill=BOTH) scrl[&apos;command&apos;] = lb.yview root.mainloop() 效果]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python tkinter pack布局]]></title>
    <url>%2F2018%2F05%2F24%2Fpython-tkinter-pack%E5%B8%83%E5%B1%80%2F</url>
    <content type="text"><![CDATA[一、pack参数： &emsp;&emsp;side:按扭停靠在窗口的哪个位置 left: 左 top: 上 right: 右 botton: 下 fill:填充 x:水平方向填充 y:竖直方向填充 both:水平和竖直方向填充 none:不填充 expand: yes:扩展整个空白区 no:不扩展 anchor: N:北 下 E:东 右 S:南 下 W:西 左 CENTER:中间 padx:x方向的外边距 pady:y方向的外边距 ipadx:x方向的内边距 ipady：y方向的内边距 二、代码示例：12345678910from Tkinter import *root = Tk()Button(root,text=&apos;A&apos;).pack(side=LEFT,expand=YES,fill=Y)Button(root,text=&apos;B&apos;).pack(side=TOP,expand=YES,fill=BOTH)Button(root,text=&apos;C&apos;).pack(side=RIGHT,expand=YES,fill=NONE)Button(root,text=&apos;D&apos;).pack(side=LEFT,expand=NO,fill=Y)Button(root,text=&apos;E&apos;).pack(side=TOP,expand=YES,fill=BOTH)Button(root,text=&apos;F&apos;).pack(side=BOTTOM,expand=YES)Button(root,text=&apos;G&apos;).pack(anchor=SE)root.mainloop()]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[12306查票订票]]></title>
    <url>%2F2018%2F04%2F16%2F12306%E6%9F%A5%E7%A5%A8%E8%AE%A2%E7%A5%A8%2F</url>
    <content type="text"><![CDATA[参考链接：https://blog.csdn.net/lzqwebsoft/article/details/18674635https://www.lanindex.com/12306%E8%B4%AD%E7%A5%A8%E6%B5%81%E7%A8%8B%E5%85%A8%E8%A7%A3%E6%9E%90/ 模拟查票订票操作如下：1.首先12306是一个需要登录操作的网站，然而12306的登录验证大家都知道需要验证码。另外12306的验证码很坑~，需要人工选择对应的物品，这个用代码识别网上我也没找到好的教程，于是… 于是只能人工识别啦。。2.登录之后我们需要输入起始地，目的地，时间等信息，然后查询3.此时我们可以查询到车次信息了，根据自己的时间然后订合适时间和合适座位的票4.选择乘坐人5.建立好订单6.付款，订票成功 显然我们做到第5步已经达到我们用爬虫的目的。1.登录操作请参考：http://www.cnblogs.com/fangtaoa/p/8321449.html2.查票操作请参考：http://www.cnblogs.com/fangtaoa/p/8360460.html3.下面补充订票操作:按照置顶的参考链接里的步骤获取url和data数据，具体可以看代码类buy确实没什么地方需要多说的，有前驱者已经铺好路了，只需按照步骤一步一步理解就可以了下面补充操作方式： 每一步都有相应的步骤名称，如果哪一步出错了只需在代码中寻找具体是哪个函数没对即可。下面给出代码：1.login.py123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172import requestsimport chardetimport userimport settingsfrom coordinate import coorfrom lxml import etreeclass Login: def __init__(self): self.headers = settings.headers self.session = settings.session self.id = user.id self.psw = user.psw def down_captcha(self): # &apos;&apos;&apos; # 下载验证码 # &apos;&apos;&apos; response = self.session.get(&apos;https://kyfw.12306.cn/passport/captcha/captcha-image?login_site=E&amp;module=login&amp;rand=sjrand&amp;0.7067378301290344&apos;) codeImg = response.content fp = open(&apos;code.png&apos;, &apos;wb&apos;) fp.write(codeImg) fp.close() def get_pos(self): # &apos;&apos;&apos; # 输入验证码坐标 # &apos;&apos;&apos; coordinate = coor() return coordinate def captcha_check(self): # &apos;&apos;&apos; # 验证码初验证 # &apos;&apos;&apos; check_flag = False data = &#123; &apos;answer&apos;: self.get_pos(), &apos;login_site&apos;:&apos;E&apos;, &apos;rand&apos;: &apos;sjrand&apos; &#125; url = &apos;https://kyfw.12306.cn/passport/captcha/captcha-check&apos; response = self.session.post(url, data=data, headers=self.headers) result = response.json() if result[&apos;result_code&apos;] == &apos;4&apos;: print(&apos;验证码通过!&apos;) check_flag = True else: print(&apos;验证码验证失败!&apos;) return check_flag def login(self, check_flag): # &apos;&apos;&apos; # 进行第一步登录 # &apos;&apos;&apos; if not check_flag: print(&apos;login() error: check_flag为False.&apos;) return False login_flag=False login_data = &#123; &apos;username&apos;: self.id, &apos;password&apos;: self.psw, &apos;appid&apos;: &apos;otn&apos; &#125; login_url = &apos;https://kyfw.12306.cn/passport/web/login&apos; login_response = self.session.post(login_url, data=login_data, headers=self.headers) #设置网页编码 if chardet.detect(login_response.content).get(&apos;encoding&apos;) != &apos;UTF-8&apos;: login_response.encoding = &apos;UTF-8&apos; if login_response.status_code == 200 and &apos;error&apos; not in login_response.url: print(&apos;登录成功！&apos;) login_flag = True else: print(&apos;登录失败！&apos;) return login_flag def auth_uamtk(self,login_flag): # &apos;&apos;&apos; # 进行登录的验证 # &apos;&apos;&apos; data = &#123; &apos;appid&apos;: &apos;otn&apos;, &#125; url = &apos;https://kyfw.12306.cn/passport/web/auth/uamtk&apos; resp = self.session.post(url, data=data, headers=self.headers) if resp.status_code == 200: result = dict(resp.json()) print(&apos;auth_uamtk():&apos;, result[&apos;result_message&apos;]) if result.get(&apos;result_code&apos;) == 0:## return result.get(&apos;newapptk&apos;) else: return None else: print(&apos;登录验证失败！&apos;) return None def uamatuth_client(self, newapptk): # &apos;&apos;&apos; # 确认是否真正的登录成功 # :param newapptk: # :return: # &apos;&apos;&apos; if newapptk is None: print(&apos;并没有真正的登录成功！&apos;) return None data = &#123; &apos;tk&apos;: newapptk, &#125; url = &apos;https://kyfw.12306.cn/otn/uamauthclient&apos; resp = self.session.post(url, data=data, headers=self.headers) if resp.status_code == 200: result = dict(resp.json()) print(&apos;uamatuth_client()&apos;, result.get(&apos;result_message&apos;)) if result.get(&apos;result_code&apos;) == 0: username = result.get(&apos;username&apos;) print(&apos;&#123;&#125;初始化登录成功!&apos;.format(username)) return username else: print(&apos;uamatuth_client() error! status_code:&#123;&#125;, url:&#123;&#125;&apos; .format(resp.status_code, resp.url)) def init_my_12306(self, username): if username is None: print(&apos;init_my_12306() error: username 为None!&apos;) return url = &apos;https://kyfw.12306.cn/otn/index/initMy12306&apos; resp = self.session.get(url, headers=self.headers) if resp.status_code == 200: content = etree.HTML(resp.content) #先用etree转化 name = content.xpath(&apos;//*[@id=&quot;login_user&quot;]/span/text()&apos;) print(&apos;init_my_12306(): name&apos;, name) if name == username: print(&apos;init_my_12306():你已经登录成功了!&apos;) else: print(&apos;init_my_12306() error! status_code:&#123;&#125;, url:&#123;&#125;&apos;. format(resp.status_code, resp.url))def main(): login = Login() login.down_captcha() check_flag = login.captcha_check() login_flag = login.login(check_flag) if login_flag: newapptk = login.auth_uamtk(login_flag) username = login.uamatuth_client(newapptk) login.init_my_12306(username) else: print(&apos;main():login_flag为Flase&apos;)if __name__ == &apos;__main__&apos;: main() 2.user.py此处根据自己账户和名称写出id 和 psw 即可 id = ‘1111111’#账户名psw = ‘222222’#密码 3.settings.py 123456789101112131415import randomimport requests#随机选择一个有效的UA来请求头信息User_Agent = [ &apos;Mozilla/5.0 (Macintosh; U; Intel Mac OS X 10_6_8; en-us) AppleWebKit/534.50 (KHTML, like Gecko) Version/5.1 Safari/534.50&apos;, &apos;Mozilla/5.0 (Windows; U; Windows NT 6.1; en-us) AppleWebKit/534.50 (KHTML, like Gecko) Version/5.1 Safari/534.50&apos;, &apos;Mozilla/5.0 (compatible; MSIE 9.0; Windows NT 6.1; Trident/5.0&apos;, &apos;Mozilla/5.0 (Macintosh; Intel Mac OS X 10.6; rv:2.0.1) Gecko/20100101 Firefox/4.0.1&apos;, &apos;Opera/9.80 (Macintosh; Intel Mac OS X 10.6.8; U; en) Presto/2.8.131 Version/11.11&apos;, &apos;Opera/9.80 (Windows NT 6.1; U; en) Presto/2.8.131 Version/11.11&apos;, &apos;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_7_0) AppleWebKit/535.11 (KHTML, like Gecko) Chrome/17.0.963.56 Safari/535.11&apos;,]session = requests.Session()headers = &#123;&apos;user-agent&apos;: random.choice(User_Agent)&#125; 4.stations.py 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287from login import Loginimport osimport jsonimport timefrom collections import deque, OrderedDictclass Station: &quot;&quot;&quot; 查询车票信息 &quot;&quot;&quot; def __init__(self): # 使用登录时候的session,这样好一些! self.headers = Login().headers self.session = Login().session self.station_info = deque() def station_name_code(self): &quot;&quot;&quot; 功能:获取每个站点的名字和对应的代码,并保存到本地 :return: 无 &quot;&quot;&quot; filename = &apos;station_name.txt&apos; url = &apos;https://kyfw.12306.cn/otn/resources/js/framework/station_name.js&apos; resp = self.session.get(url, headers=self.headers) if resp.status_code == 200: print(&apos;station_name_code():获取站点信息成功!&apos;) with open(filename, &apos;w&apos;) as f: for each in resp.text.split(&apos;=&apos;)[1].split(&apos;@&apos;): if each != &quot;&apos;&quot;: f.write(each) f.write(&apos;\n&apos;) else: print(&apos;station_name_code() error! status_code:&#123;&#125;, url: &#123;&#125;&apos; .format(resp.status_code, resp.url)) def save_station_code(self, filename): &quot;&quot;&quot; 功能:从站点文件中提取站点与其对应的代码,并保存到文件中 :return: &quot;&quot;&quot; if not os.path.exists(filename): print(&apos;save_station_code():&apos;, filename, &apos;不存在,正在下载!&apos;) self.station_name_code() file = &apos;name_code.json&apos; name_code_dict = &#123;&#125; with open(filename, &apos;r&apos;) as f: for line in f: # 对读取的行都进行split操作,然后提取站点名和其代码 name = line.split(&apos;|&apos;)[1] # 站点名字 code = line.split(&apos;|&apos;)[2] # 每个站点对应的代码 # 每个站点肯定都是唯一的 name_code_dict[name] = code # 把name,code保存到本地文件中,方便以后使用 with open(file, &apos;w&apos;) as f: # 不以ascii码编码的方式保存 json.dump(name_code_dict, f, ensure_ascii=False) def query_ticket(self): &quot;&quot;&quot; 功能:查票操作 :return: 返回查询到的所有车次信息 &quot;&quot;&quot; data = self._query_prompt() if not data: print(&apos;query_ticket() error: &#123;&#125;&apos;.format(data)) _, from_station, to_station = data.keys() train_date = data.get(&apos;train_date&apos;) from_station_code = data.get(from_station) to_station_code = data.get(to_station) query_param = &apos;leftTicketDTO.train_date=&#123;&#125;&amp;&apos; \ &apos;leftTicketDTO.from_station=&#123;&#125;&amp;&apos; \ &apos;leftTicketDTO.to_station=&#123;&#125;&amp;&apos; \ &apos;purpose_codes=ADULT&apos;\ .format(train_date, from_station_code, to_station_code) url = &apos;https://kyfw.12306.cn/otn/leftTicket/query?&apos; full_url = url + query_param resp = self.session.get(full_url, headers=self.headers) if resp.status_code == 200 and resp.url == full_url: print(&apos;query_ticket() 成功!然后进行车票清理工作!&apos;) self._get_train_info(resp.json(), from_station, to_station) else: print(&apos;query_ticket() error! status_code:&#123;&#125;, url:&#123;&#125;\norigin_url:&#123;&#125;&apos; .format(resp.status_code, resp.url, full_url)) return self.station_info, train_date, from_station_code, to_station_code def _get_train_info(self, text, from_station, to_station): &quot;&quot;&quot; 功能:提取出查询到的列车信息 :param text: 包含所有从起点站到终点站的车次信息 :return: 返回所有车次信息 &quot;&quot;&quot; if not text: print(&apos;_query_train_info() error: text为:&apos;, text) # 把json文件转变成字典形式 result = dict(text) # 判断有无车次的标志 if result.get(&apos;data&apos;).get(&apos;map&apos;): train_info = result.get(&apos;data&apos;).get(&apos;result&apos;) train_list = deque() for item in train_info: split_item = item.split(&apos;|&apos;) item_dict = &#123;&#125; # for index, item in enumerate(split_item,0): # print(&apos;&#123;&#125;:\t&#123;&#125;&apos;.format(index, item)) if split_item[11] == &apos;Y&apos;: # 已经开始卖票了 item_dict[&apos;train_id&apos;] = split_item[0] item_dict[&apos;train_name&apos;] = split_item[3] # 车次名 item_dict[&apos;depart_time&apos;] = split_item[8] # 出发时间 item_dict[&apos;arrive_time&apos;] = split_item[9] # 到站时间 item_dict[&apos;spend_time&apos;] = split_item[10] # 经历时长 item_dict[&apos;wz&apos;] = split_item[29] # 无座 item_dict[&apos;yz&apos;] = split_item[28] # 硬座 item_dict[&apos;yw&apos;] = split_item[26] # 硬卧 item_dict[&apos;rw&apos;] = split_item[23] # 软卧 item_dict[&apos;td&apos;] = split_item[32] # 特等座 item_dict[&apos;yd&apos;] = split_item[31] # 一等座 item_dict[&apos;ed&apos;] = split_item[30] # 二等座 item_dict[&apos;dw&apos;] = split_item[33] # 动卧 train_list.append(item_dict) self.station_info.append(item_dict) # 无法买票的车次,有可能是已卖光,也有可能是还不开卖 elif split_item[0] == &apos;&apos;: print(&apos;_query_train_info():车次&#123;&#125;的票暂时不能购买!&apos; .format(split_item[3])) else: print(&apos;_query_train_info():车次&#123;&#125;还未开始卖票,起售时间为:&#123;&#125;&apos; .format(split_item[3], split_item[1])) # 调用方法来打印列车结果 self._print_train(train_list, from_station, to_station) else: print(&apos;_get_train_info() error: 从&#123;&#125;站到&#123;&#125;站有没列车!&apos; .format(from_station, to_station)) def _print_train(self, train_info, from_station, to_station): &quot;&quot;&quot; 功能:打印查询到的车次信息 :param train_info: 提取出来的车次信息 :return: &quot;&quot;&quot; if not train_info: print(&apos;_print_train() error: train_info是None!&apos;) return print(&apos;从&#123;&#125;到&#123;&#125;还有余票的列车有:&apos;.format(from_station, to_station)) for item in train_info: if &apos;G&apos; in item[&apos;train_name&apos;]: # 高铁 self._print_high_train_info(item) elif &apos;D&apos; in item[&apos;train_name&apos;]: # 动车 self._print_dong_train_info(item) else: self._print_train_info(item) def _print_high_train_info(self, item): &quot;&quot;&quot; 功能:打印高铁车次信息 :param item: 所有高铁车次 :return: &quot;&quot;&quot; print(&apos;车次:&#123;:4s&#125;\t起始时间:&#123;:4s&#125;\t到站时间:&#123;:4s&#125;\t&apos; &apos;经历时长:&#123;:4s&#125;\t特等座:&#123;:4s&#125;\t一等座:&#123;:4s&#125;\t二等座:&#123;:4s&#125;&apos; .format(item[&apos;train_name&apos;], item[&apos;depart_time&apos;],item[&apos;arrive_time&apos;], item[&apos;spend_time&apos;],item[&apos;td&apos;], item[&apos;yd&apos;], item[&apos;ed&apos;])) def _print_dong_train_info(self, item): &quot;&quot;&quot; 功能:打印动车的车票信息 :param item: 所有动车车次 :return: &quot;&quot;&quot; print(&apos;车次:&#123;:4s&#125;\t起始时间:&#123;:4s&#125;\t到站时间:&#123;:4s&#125;\t&apos; &apos;经历时长:&#123;:4s&#125;\t一等座:&#123;:4s&#125;\t二等座:&#123;:4s&#125;\t软卧:&#123;:4s&#125;\t动卧:&#123;:4s&#125;&apos; .format(item[&apos;train_name&apos;], item[&apos;depart_time&apos;], item[&apos;arrive_time&apos;], item[&apos;spend_time&apos;],item[&apos;yd&apos;],item[&apos;ed&apos;], item[&apos;rw&apos;], item[&apos;dw&apos;])) def _print_train_info(self,item): &quot;&quot;&quot; 功能:打印普通列出的车次信息 :param item: 所有普通车次 :return: &quot;&quot;&quot; print(&apos;车次:&#123;:4s&#125;\t起始时间:&#123;:4s&#125;\t到站时间:&#123;:4s&#125;\t经历时长:&#123;:4s&#125;\t&apos; &apos;软卧:&#123;:4s&#125;\t硬卧:&#123;:4s&#125;\t硬座:&#123;:4s&#125;\t无座:&#123;:4s&#125;&apos; .format(item[&apos;train_name&apos;], item[&apos;depart_time&apos;], item[&apos;arrive_time&apos;], item[&apos;spend_time&apos;],item[&apos;rw&apos;], item[&apos;yw&apos;], item[&apos;yz&apos;], item[&apos;wz&apos;])) def _query_prompt(self): &quot;&quot;&quot; 功能: 与用户交互,让用户输入:出发日期,起始站和终点站并判断其正确性 :return: 返回正确的日期,起始站和终点站 &quot;&quot;&quot; time_flag, train_date = self._check_date() if not time_flag: print(&apos;_query_prompt() error:&apos;, &apos;乘车日期不合理,请检查!!&apos;) return # 创建有序字典,方便取值 query_data = OrderedDict() from_station = input(&apos;请输入起始站:&apos;) to_station = input(&apos;请输入终点站:&apos;) station_flag = True filename = &apos;name_code.json&apos; with open(filename, &apos;r&apos;) as f: data = dict(json.load(f)) stations = data.keys() if from_station not in stations or to_station not in stations: station_flag = False print(&apos;query_prompt() error: &#123;&#125;或&#123;&#125;不在站点列表中!!&apos; .format(from_station, to_station)) # 获取起始站和终点站的代码 from_station_code = data.get(from_station) to_station_code = data.get(to_station) query_data[&apos;train_date&apos;] = train_date query_data[from_station] = from_station_code query_data[to_station] = to_station_code if time_flag and station_flag: return query_data else: print(&apos;query_prompt() error! time_flag:&#123;&#125;, station_flag:&#123;&#125;&apos; .format(time_flag, station_flag)) def _check_date(self): &quot;&quot;&quot; 功能:检测乘车日期的正确性 :return: 返回时间是否为标准的形式的标志 &quot;&quot;&quot; # 获取当前时间的时间戳 local_time = time.localtime() local_date = &apos;&#123;&#125;-&#123;&#125;-&#123;&#125;&apos;.\ format(local_time.tm_year, local_time.tm_mon, local_time.tm_mday) curr_time_array = time.strptime(local_date, &apos;%Y-%m-%d&apos;) curr_time_stamp = time.mktime(curr_time_array) # 获取当前时间 curr_time = time.strftime(&apos;%Y-%m-%d&apos;, time.localtime(curr_time_stamp)) # 计算出预售时长的时间戳 delta_time_stamp = &apos;2505600&apos; # 算出预售票的截止日期时间戳 dead_time_stamp = int(curr_time_stamp) + int(delta_time_stamp) dead_time = time.strftime(&apos;%Y-%m-%d&apos;, time.localtime(dead_time_stamp)) print(&apos;合理的乘车日期范围是:(&#123;&#125;)~(&#123;&#125;)&apos;.format(curr_time, dead_time)) train_date = input(&apos;请输入乘坐日期(year-month-day):&apos;) # 把乘车日期转换成时间戳来比较 # 先生成一个时间数组 time_array = time.strptime(train_date, &apos;%Y-%m-%d&apos;) # 把时间数组转化成时间戳 train_date_stamp = time.mktime(time_array) # 获取标准的乘车日期 train_date_time = time.strftime(&apos;%Y-%m-%d&apos;, time.localtime(train_date_stamp)) # 做上面几步主要是把用户输入的时间格式转变成标准的格式 # 如用户输入:2018-2-22,那么形成的查票URL就不是正确的 # 只有是: 2018-02-22,组合的URL才是正确的! # 通过时间戳来比较时间的正确性 if int(train_date_stamp) &gt;= int(curr_time_stamp) and \ int(train_date_stamp) &lt;= dead_time_stamp: return True, train_date_time else: print(&apos;_check_date() error: 乘车日期:&#123;&#125;, 当前系统时间:&#123;&#125;, 预售时长为:&#123;&#125;&apos; .format(train_date_time, curr_time, dead_time)) return False, Nonedef main(): filename = &apos;station_name.txt&apos; station = Station() station.station_name_code() station.save_station_code(filename) station.query_ticket()if __name__ == &apos;__main__&apos;: main() 5.coordinate.py(验证码坐标 1234567891011121314def coor(): arr = [[],[&apos;45&apos;,&apos;45&apos;],[&apos;110&apos;,&apos;45&apos;],[&apos;175&apos;,&apos;45&apos;],[&apos;240&apos;,&apos;45&apos;], [&apos;45&apos;,&apos;110&apos;],[&apos;110&apos;,&apos;110&apos;],[&apos;175&apos;,&apos;110&apos;],[&apos;240&apos;,&apos;110&apos;]] cnt = input(&apos;请输入验证码坐标，以,隔开\n&apos;) Str = [] for i in cnt: if i == &apos;,&apos;: continue else: Str = Str + arr[int(i)] return &apos;,&apos;.join(Str) 6.buy.py 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238import requestsimport chardetimport urllib.parseimport settingsfrom login import Loginfrom stations import Stationimport reimport timeimport datetimeimport stationsclass Buy: def __init__(self): # 使用登录时候的session,这样好一些! self.headers = settings.headers self.session = settings.session def checkUser(self): &quot;&quot;&quot; 功能:验证登录 :return: 无 &quot;&quot;&quot; url = &apos;https://kyfw.12306.cn/otn/login/checkUser&apos; data = &#123; &apos;_json_att&apos;: &apos;&apos;, &#125; resp = self.session.post(url, data=data, headers=self.headers) result = resp.json() checkUser_flag = result[&apos;status&apos;] if checkUser_flag == True: print(&apos;验证登录成功！&apos;) def get_secretStr(self, station_info): &quot;&quot;&quot; 功能:返回高铁车次信息 :param item: 单车次信息 :return: &quot;&quot;&quot; val = str(input(&apos;请输入订票的车次:&apos;)) for item in station_info: if item[&apos;train_name&apos;] == val: return item[&apos;train_id&apos;] def submitOrderRequest(self, station_info): url = &apos;https://kyfw.12306.cn/otn/leftTicket/submitOrderRequest&apos; cnt = self.get_secretStr(station_info) Str = urllib.parse.unquote(cnt) # 获取当前时间的时间戳 local_time = time.localtime() local_date = &apos;&#123;&#125;-&#123;&#125;-&#123;&#125;&apos;.\ format(local_time.tm_year, local_time.tm_mon, local_time.tm_mday) curr_time_array = time.strptime(local_date, &apos;%Y-%m-%d&apos;) curr_time_stamp = time.mktime(curr_time_array) # 获取当前时间 curr_time = time.strftime(&apos;%Y-%m-%d&apos;, time.localtime(curr_time_stamp)) train_date = input(&apos;请再次确认乘坐日期(year-month-day):&apos;) query_from_station_name = input(&apos;请再次输入起始站:&apos;) query_to_station_name = input(&apos;请再次输入终点站:&apos;) data = &#123; &apos;secretStr&apos;: Str, &apos;train_date&apos;: train_date, &apos;back_train_date&apos;: curr_time, &apos;tour_flag&apos;: &apos;dc&apos;, &apos;purpose_codes&apos;: &apos;ADULT&apos;, &apos;query_from_station_name&apos;: query_from_station_name, &apos;query_to_station_name&apos;: query_to_station_name, &apos;undefined&apos;: &apos;&apos;, &#125; resp = self.session.post(url, data=data, headers=self.headers) if resp.status_code == 200: print(&apos;submitOrderRequest成功！&apos;) else: print(&apos;submitOrderRequest() error! status_code:&#123;&#125;, url:&#123;&#125;&apos;. format(resp.status_code, resp.url)) def initDc(self): &quot;&quot;&quot; 功能:请求提交购票人信息和选择购票坐票或者卧铺类型页面 :return: 无 &quot;&quot;&quot; url = &apos;https://kyfw.12306.cn/otn/confirmPassenger/initDc&apos; data = &#123; &apos;_json_att&apos;: &apos;&apos;, &#125; resp = self.session.post(url, data=data, headers=self.headers) #设置网页编码 if chardet.detect(resp.content).get(&apos;encoding&apos;) != &apos;UTF-8&apos;: resp.encoding = &apos;UTF-8&apos; match = re.search(&quot;var globalRepeatSubmitToken = &apos;(.*?)&apos;;&quot;, resp.text) ticketToken = match.group(1) people_url = &apos;https://kyfw.12306.cn/otn/confirmPassenger/getPassengerDTOs&apos; people_resp = self.session.post(people_url, data=&#123;&quot;REPEAT_SUBMIT_TOKEN&quot;:ticketToken,&quot;_json_att&quot;:&quot;&quot;&#125;, headers=self.headers) people_json = people_resp.json() result = dict(people_json) info = result[&apos;data&apos;][&apos;normal_passengers&apos;][1] train_no = re.search(&quot;&apos;train_no&apos;:&apos;(.*?)&apos;&quot;, resp.text).group(1) leftTicket = re.search(&quot;&apos;ypInfoDetail&apos;:&apos;(.*?)&apos;&quot;, resp.text).group(1) purpose_codes = re.search(&quot;&apos;purpose_codes&apos;:&apos;(.*?)&apos;&quot;, resp.text).group(1) station_train_code = re.search(&quot;&apos;station_train_code&apos;:&apos;(.*?)&apos;&quot;, resp.text).group(1) to_station_telecode = re.search(&quot;&apos;to_station_telecode&apos;:&apos;(.*?)&apos;&quot;, resp.text).group(1) train_location = re.search(&quot;&apos;train_location&apos;:&apos;(.*?)&apos;&quot;, resp.text).group(1) key_check_isChange = re.search(&quot;&apos;key_check_isChange&apos;:&apos;(.*?)&apos;&quot;, resp.text).group(1) return info, ticketToken, train_no, leftTicket, purpose_codes, station_train_code, to_station_telecode, train_location, key_check_isChange def checkOrderInfo(self, info, ticketToken): url = &apos;https://kyfw.12306.cn/otn/confirmPassenger/checkOrderInfo&apos; passengerTicketStr = &apos;O,0,1,&apos; + info[&apos;passenger_name&apos;] + &apos;,1,&apos; + info[&apos;passenger_id_no&apos;] + &apos;,&apos; + info[&apos;mobile_no&apos;] + &apos;,N&apos; oldPassengerStr = info[&apos;passenger_name&apos;] + &apos;,1,&apos; + info[&apos;passenger_id_no&apos;] + &apos;,1_&apos; data = &#123; &apos;cancel_flag&apos;: &apos;2&apos;, &apos;bed_level_order_num&apos;: &apos;000000000000000000000000000000&apos;, &apos;passengerTicketStr&apos;: passengerTicketStr, &apos;oldPassengerStr&apos;: oldPassengerStr,# &apos;tour_flag&apos;: &apos;dc&apos;, &apos;randCode&apos;: &apos;&apos;, &apos;whatsSelect&apos;: &apos;1&apos;, &apos;_json_att&apos;: &apos;&apos;, &apos;REPEAT_SUBMIT_TOKEN&apos;: ticketToken,# &#125; resp = self.session.post(url, data=data, headers=self.headers) result = dict(resp.json()) if result[&apos;data&apos;][&apos;submitStatus&apos;] == True: print(&apos;checkOrderInfo成功！&apos;) else: print(&apos;checkOrderInfo失败！&apos;) return passengerTicketStr, oldPassengerStr def getQueueCount(self, trainDate, train_no, leftTicket, ticketToken, station_train_code, fromStationTelecode, to_station_telecode, purpose_codes, train_location, passengerTicketStr, oldPassengerStr, key_check_isChange): url = &apos;https://kyfw.12306.cn/otn/confirmPassenger/getQueueCount&apos; data = &#123; &apos;train_date&apos;: datetime.datetime.fromtimestamp(time.mktime(time.strptime(trainDate, &apos;%Y-%m-%d&apos;))).strftime(&apos;%a %b %d %Y %H:%M:%S GMT+0800&apos;), &apos;train_no&apos;: train_no, &apos;stationTrainCode&apos;: station_train_code, &apos;seatType&apos;: &apos;O&apos;, &apos;fromStationTelecode&apos;: fromStationTelecode, &apos;toStationTelecode&apos;: to_station_telecode, &apos;leftTicket&apos;: leftTicket, &apos;purpose_codes&apos;: purpose_codes, &apos;train_location&apos;: train_location, &apos;_json_att&apos;: &apos;&apos;, &apos;REPEAT_SUBMIT_TOKEN&apos;: ticketToken, &#125; resp = self.session.post(url, data=data, headers=self.headers) queueCountJson = resp.json() if queueCountJson.get(&quot;status&quot;) == False or queueCountJson.get(&quot;httpstatus&quot;) != 200: raise Exception(&quot;获取队列错误&quot;) url = &apos;https://kyfw.12306.cn/otn/confirmPassenger/confirmSingleForQueue&apos; data = &#123; &apos;passengerTicketStr&apos;: passengerTicketStr, &apos;oldPassengerStr&apos;: oldPassengerStr, &apos;randCode&apos;: &apos;&apos;, &apos;purpose_codes&apos;: purpose_codes, &apos;key_check_isChange&apos;: key_check_isChange, &apos;leftTicketStr&apos;: leftTicket, &apos;train_location&apos;: train_location, &apos;choose_seats&apos;: &apos;&apos;, &apos;seatDetailType&apos;: &apos;000&apos;, &apos;whatsSelect&apos;: &apos;1&apos;, &apos;roomType&apos;: &apos;00&apos;, &apos;dwAll&apos;: &apos;N&apos;, &apos;_json_att&apos;: &apos;&apos;, &apos;REPEAT_SUBMIT_TOKEN&apos;: ticketToken, &#125; singleForQueueReq = self.session.post(url, data=data, headers=self.headers) singleForQueueJson = singleForQueueReq.json() print(singleForQueueJson) def queryOrderWaitTime(self, ticketToken): url = &apos;https://kyfw.12306.cn/otn/confirmPassenger/queryOrderWaitTime&apos; data = &#123; &apos;random&apos;: time.time(), &apos;tourFlag&apos;: &apos;dc&apos;, &apos;_json_att&apos;: &apos;&apos;, &apos;REPEAT_SUBMIT_TOKEN&apos;: ticketToken, &#125; resp = self.session.post(url, data=data, headers=self.headers) orderWaitJson = resp.json() orderId = orderWaitJson.get(&quot;data&quot;).get(&quot;orderId&quot;)#此处有问题 print(orderWaitJson) print(orderId) url = &apos;https://kyfw.12306.cn/otn/confirmPassenger/resultOrderForDcQueue&apos; data = &#123; &apos;orderSequence_no&apos;: orderId, &apos;_json_att&apos;: &apos;&apos;, &apos;REPEAT_SUBMIT_TOKEN&apos;: ticketToken, &#125; dcQueueReq = self.session.post(url, data=data, headers=self.headers) dcQueueJson = dcQueueReq.json() if dcQueueJson.get(&quot;status&quot;) and dcQueueJson.get(&quot;httpstatus&quot;) == 200 and dcQueueJson.get( &quot;data&quot;) is not None and dcQueueJson.get(&quot;data&quot;).get(&quot;submitStatus&quot;): print(&quot;订票成功&quot;) else: print(dcQueueJson) print(&quot;订票失败&quot;)def start(): login = Login() login.down_captcha() check_flag = login.captcha_check() login_flag = login.login(check_flag) if login_flag: newapptk = login.auth_uamtk(login_flag) username = login.uamatuth_client(newapptk) login.init_my_12306(username) else: print(&apos;main():login_flag为Flase&apos;)def query(): filename = &apos;station_name.txt&apos; station = Station() station.station_name_code() station.save_station_code(filename) station_info, train_date, from_station_code, to_station_code = station.query_ticket() return station_info, train_date, from_station_code, to_station_codedef shop(station_info, trainDate, fromStationTelecode, to_station_telecode): buy = Buy() buy.checkUser() buy.submitOrderRequest(station_info) info, ticketToken, train_no, leftTicket, purpose_codes, station_train_code, to_station_telecode, train_location, key_check_isChange = buy.initDc() passengerTicketStr, oldPassengerStr = buy.checkOrderInfo(info, ticketToken) buy.getQueueCount(trainDate, train_no, leftTicket, ticketToken, station_train_code, fromStationTelecode, to_station_telecode, purpose_codes, train_location, passengerTicketStr, oldPassengerStr, key_check_isChange) buy.queryOrderWaitTime(ticketToken)def main(): start() station_info, train_date, from_station_code, to_station_code = query() shop(station_info, train_date, from_station_code, to_station_code)if __name__ == &apos;__main__&apos;: main()]]></content>
      <categories>
        <category>爬虫</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>爬虫</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[初学爬虫]]></title>
    <url>%2F2018%2F04%2F16%2F%E5%88%9D%E5%AD%A6%E7%88%AC%E8%99%AB%2F</url>
    <content type="text"><![CDATA[今天作为例子的网站：http://www.xiaohua100.cn/daxue/啊哈，这个也是无意间找的网站，不是故意找的（大雾）（作为例子来说还是挺好的例子…个人理解的爬虫分为以下几步：1.获取网站url2.搞清楚是get请求还是post请求3.request或者session访问后，注意编码格式4.正则表达式或者用匹配出信息5.是否要从访问之后的返回信息得出data以及下个网站url 那么今天的例子：1.首先我们很清楚url = ‘http://www.xiaohua100.cn/daxue/&#39;2.这个网站由get请求访问3.我们今天的目的是寻找这些图片并进行下载，那么我们要做的是找到图片的url4.然后通过正则表达式储存这些url到一个列表里面5.通过requests.content 二进制下载这些图片即可 代码如下：123456789101112131415161718192021import requestsimport reurl = &apos;http://www.xiaohua100.cn/daxue/&apos;response = requests.get(url)response.encoding = &apos;utf-8&apos;html = response.textmain_url = &apos;http://www.xiaohua100.cn&apos;img_urls = re.findall(r&apos;/uploads/allimg/\d+/\d-\w+-\w+.jpg&apos;, html)for i in range(len(img_urls)): img_urls[i] = main_url + img_urls[i]index = 0for img_url in img_urls: img_data = requests.get(img_url).content filename = str(index) + &apos;.jpg&apos; with open(filename, &apos;wb&apos;) as f: f.write(img_data) print(img_url) index += 1]]></content>
      <categories>
        <category>爬虫</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>爬虫</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[爬UbuntuPaste代码]]></title>
    <url>%2F2018%2F04%2F16%2F%E7%88%ACUbuntuPaste%E4%BB%A3%E7%A0%81%2F</url>
    <content type="text"><![CDATA[直接贴代码啦。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061# -*- coding:utf-8 -*-import urllib.requestimport reimport osclass UbtSpider: def __init__(self) : self.pageIndex = 25317600 self.user_agent = &apos;Mozilla/4.0 (compatible; MSIE 5.5; Windows NT)&apos; def getPage(self,pageIndex): url = &apos;http://paste.ubuntu.com/&apos; + str(pageIndex) headers = &#123;&apos;User-Agent&apos;: self.user_agent, &apos;Referer&apos;: url&#125; request = urllib.request.Request(url, headers=headers) with urllib.request.urlopen(request) as response: html = response.read() content = html.decode(&apos;utf-8&apos;) patten = re.compile(&apos;&lt;div class=&quot;paste&quot;&gt;&lt;pre&gt;(.*?)&lt;/pre&gt;&lt;/div&gt;&apos;, re.S) # re.S (.*?）表示分组 items = patten.findall(content) for item in items: #替换 item = item.replace(&apos;&amp;nbsp;&apos;, &apos; &apos;) item = item.replace(&apos;&amp;gt;&apos;, &apos;&gt;&apos;) item = item.replace(&apos;&amp;lt;&apos;, &apos;&lt;&apos;) item = item.replace(&apos;&amp;quot;&apos;, &apos;&quot;&apos;) item = item.replace(&apos;&amp;amp;&apos;, &apos;&amp;&apos;) item = item.replace(&apos;&amp;#39;&apos;, &apos;\&apos;&apos;) item = re.sub(&apos;&lt;span.*?&gt;&apos;,&apos;&apos;,item) item = re.sub(&apos;&lt;/span&gt;&apos;, &apos;&apos;, item) # print(item) patten2 = re.compile(&quot;.*include&quot;, re.S) if (patten2.match(item)): fileName = str(pageIndex) + &apos;.txt&apos; print( u&quot;正在写入: &gt;&gt;&gt; &quot; + str(pageIndex)) isSuccess = True with open(fileName,&apos;w&apos;) as f: try: f.write(item) except UnicodeError as e: if hasattr(e,&quot;reason&quot;): print (str(pageIndex)+u&quot; 写入失败,原因: &quot; + e.reason) isSuccess = False f.close() try:os.remove(fileName) except Exception as ose: print(str(pageIndex)+u&quot; 删除失败&quot; ) if isSuccess: print(str(pageIndex) + u&quot; 写入成功!&quot; ) f.close() def start(self): start = 25545700 end = 25545692 start = input(&quot;请输入起始页码: &quot;) end = input(&quot;请输入结束页码: &quot;) print(u&quot;开始爬取 UbuntuPaste 代码 ........&quot;) for pageIndex in range(int(start),int(end)): # 起始范围 self.getPage(pageIndex)spider = UbtSpider()spider.start()]]></content>
      <categories>
        <category>爬虫</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>爬虫</tag>
      </tags>
  </entry>
</search>
