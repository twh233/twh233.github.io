<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Twh233&#39;s Blog</title>
  
  <subtitle>Love Coding,Enjoy Life</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://twh233.github.io/"/>
  <updated>2021-05-08T06:24:38.682Z</updated>
  <id>http://twh233.github.io/</id>
  
  <author>
    <name>Twh233</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Reactor和Proactor模式</title>
    <link href="http://twh233.github.io/2021/05/08/Reactor%E5%92%8CProactor%E6%A8%A1%E5%BC%8F/"/>
    <id>http://twh233.github.io/2021/05/08/Reactor和Proactor模式/</id>
    <published>2021-05-08T06:17:12.000Z</published>
    <updated>2021-05-08T06:24:38.682Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Reactor模式（同步I-O模型通常用于实现Reactor模式）"><a href="#Reactor模式（同步I-O模型通常用于实现Reactor模式）" class="headerlink" title="Reactor模式（同步I/O模型通常用于实现Reactor模式）"></a>Reactor模式（同步I/O模型通常用于实现Reactor模式）</h2><p>它要求主线程（I/O处理单元，下同）只负责监听文件描述符上是否有事件发生，有的话就立刻将该事件通知工作线程。除此之外，主线程不做任何其他实质性的工作。读写数据，接受新的连接，以及处理客户请求均在工作线程中完成。</p><p>使用同步I/O模型（以epoll_wait为例）实现的Reactor模式的工作流程</p><p>（1）主线程往epoll内核事件表中注册socket上的读就绪事件</p><p>（2）主线程调用epoll_wait等待socket上有数据可读</p><p>（3）当socket上有数据可读时，epoll_wait通知主线程。主线程则将socket可读事件放入请求队列</p><p>（4）睡眠在请求队列上的某个工作线程被唤醒，它从socket上读取数据，并处理客户请求，然后往epoll内核事件表中注册该socket上的写就绪事件</p><p>（5）主线程调用epoll_wait等待socket可写</p><p>（6）当socket可写时，epoll_wait通知主线程，主线程将socket可写事件放入请求队列中</p><p>（7）睡眠在请求队列上的某个工作线程被唤醒，它往socket上写入服务器处理客户请求的结果</p><img src="/2021/05/08/Reactor和Proactor模式/1.png"><h2 id="Proactor模式"><a href="#Proactor模式" class="headerlink" title="Proactor模式"></a>Proactor模式</h2><p>与Reactor模式不同，将所有I/O操作都交给主线程和内核来处理，工作线程仅仅负责业务逻辑</p><p>  使用异步I/O模型实现的Proactor模式的工作流程</p><p>（1）主线程调用aio_read函数向内核注册socket上的读完成事件，并告诉内核用户读缓冲区的位置，以及读操作完成时如何通知应用程序（这里以信号为例）</p><p>（2）主线程继续处理其他逻辑</p><p>（3）当socket上的数据被读入用户缓冲区后，内核将向应用程序发送一个信号，以通知应用程序数据已经可用</p><p>（4）应用程序预先定义好的信号处理函数选择一个工作线程来处理客户请求。工作线程处理完客户请求之后，调用aio_write函数向内核注册socket上的写完成事件，并告诉写缓冲区的位置，以及写操作完成时如何通知应用程序</p><p>（5）主线程继续处理其他逻辑</p><p>（6）当用户缓冲区的数据被写入socket之后，内核将向应用程序发送一个信号，以通知应用程序数据已发送完毕</p><p>（7）应用程序预先定义好的信号处理函数选择一个工作线程来做善后处理，比如决定是否关闭socket</p><img src="/2021/05/08/Reactor和Proactor模式/2.png">]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Reactor模式（同步I-O模型通常用于实现Reactor模式）&quot;&gt;&lt;a href=&quot;#Reactor模式（同步I-O模型通常用于实现Reactor模式）&quot; class=&quot;headerlink&quot; title=&quot;Reactor模式（同步I/O模型通常用于实现Rea
      
    
    </summary>
    
      <category term="reactor" scheme="http://twh233.github.io/categories/reactor/"/>
    
    
      <category term="reactor" scheme="http://twh233.github.io/tags/reactor/"/>
    
  </entry>
  
  <entry>
    <title>restful API</title>
    <link href="http://twh233.github.io/2021/05/07/restful-API/"/>
    <id>http://twh233.github.io/2021/05/07/restful-API/</id>
    <published>2021-05-07T06:55:25.000Z</published>
    <updated>2021-05-07T07:37:58.646Z</updated>
    
    <content type="html"><![CDATA[<p>restful是一种规范，程序员都以此为标准可以前后端分离开发，提高效率。</p><p>所有东西都是资源，所有操作都通过对资源的增删改查实现，对资源的增删改查对应对URL的操作（POST，DELETE，PUT，GET），资源都是无状态的。</p><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><img src="/2021/05/07/restful-API/1.png"><p>再以登录作为举例，POST /authorization 登录，发送请求，DELETE /authorization 退出。</p><p>动作都是由固定的URL操作来做，干什么都是以URL来代替。</p><img src="/2021/05/07/restful-API/2.png"><h2 id="前后端分离的缺点"><a href="#前后端分离的缺点" class="headerlink" title="前后端分离的缺点"></a>前后端分离的缺点</h2><p>首先，最初我们学习到的肯定是有服务端渲染网页，前后端一个人搞定，直接生成好网页，直接传递html给客户端了。后续出现前后端分离，那么两端交流的数据（JSON），所以客户端得等服务端把数据发回来之后才能渲染网页，如果数据量很大，肯定就会卡顿。</p><p>SEO问题：SEO（Search Engine Optimizaton），前后端分离的方式，通常的载体是SPA（Single Page Application），所以拿到的是没有数据的空壳子，很多搜索引擎，不支持SPA方式的SEO。而服务器端渲染的方式，因为生成的是网页，所以对SEO支持的很好。</p><p>– 引入知乎的回答：<br>nodejs出现之前有两种解决方式，一是做一动一静两套页面，服务器判断请求来自蜘蛛就呈现静态页，否则呈现动态页；二是服务器架设虚拟浏览器软件，请求过来了先让虚拟浏览器跑一遍，再将得到的静态页面返回给客户端，两种方式都不咋地。有了nodejs后主流做法是前后端同构方案，即一套代码在浏览器端和node端都可以运行，从而可以先在node端请求数据渲染模板，然后将渲染结果返回给浏览器最终呈现，是目前最完美的前后端分离+SEO解决方案，目测没有之一。</p><h2 id="API接口文档"><a href="#API接口文档" class="headerlink" title="API接口文档"></a>API接口文档</h2><p>要么由架构师主导，要么由前端来定。前端先开发界面原型。在确定界面风格、布局、跳转、交互的过程中，自然会形成需要获取数据的接口。</p><h2 id="Swagger"><a href="#Swagger" class="headerlink" title="Swagger"></a>Swagger</h2><p>Swagger是一个规范和完整的框架，用于生成、描述、调用和可视化restful风格的Web服务。</p><p>作用：  </p><pre><code>1. 接口文档在线生成。2. 功能测试。</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;restful是一种规范，程序员都以此为标准可以前后端分离开发，提高效率。&lt;/p&gt;
&lt;p&gt;所有东西都是资源，所有操作都通过对资源的增删改查实现，对资源的增删改查对应对URL的操作（POST，DELETE，PUT，GET），资源都是无状态的。&lt;/p&gt;
&lt;h2 id=&quot;示例&quot;&gt;
      
    
    </summary>
    
      <category term="restful" scheme="http://twh233.github.io/categories/restful/"/>
    
    
      <category term="restful" scheme="http://twh233.github.io/tags/restful/"/>
    
  </entry>
  
  <entry>
    <title>P2P框架的实现</title>
    <link href="http://twh233.github.io/2021/05/06/P2P%E6%A1%86%E6%9E%B6%E7%9A%84%E5%AE%9E%E7%8E%B0/"/>
    <id>http://twh233.github.io/2021/05/06/P2P框架的实现/</id>
    <published>2021-05-06T06:28:59.000Z</published>
    <updated>2021-05-06T08:19:45.051Z</updated>
    
    <content type="html"><![CDATA[<h2 id="中心化网络"><a href="#中心化网络" class="headerlink" title="中心化网络"></a>中心化网络</h2><p>每个客户端都是平等的，没有客户端与服务器之分，客户端之间互相提供服务，不存在“特殊”身份。客户端可与客户端直接交流。</p><img src="/2021/05/06/P2P框架的实现/1.png"><h2 id="NAT"><a href="#NAT" class="headerlink" title="NAT"></a>NAT</h2><p>NAT （Network Address Translation，网络地址映射）是将公网地址映射为私网地址。而能够进行映射的网络装置被称为 NAT 路由器。  </p><p>由于IPV4地址紧缺，所以通过公网IP地址和端口映射到私网机器的IP地址与端口，有助于减缓IP4地址的耗尽。</p><h3 id="NAT的实现"><a href="#NAT的实现" class="headerlink" title="NAT的实现"></a>NAT的实现</h3><p>静态转换（Static NAT）：私网 IP 地址转换为公网 IP 地址，公网 IP 与私网 IP 地址通<br>过一对一的配置，配置后是不能更改的。</p><p>动态转换（Dynamic NAT）：为私网分配多个公网 IP 地址，组成一个公网 IP 地址池。私网内部地址需要转换时，NAT 路由器从公网 IP 地址池中取出一个 IP 地址，分配给私网机器用于网络通信。</p><p>端口地址映射（Port Address Translation, PAT）：改变私网内机器发送到公网数据<br>包的源端口并进行端口转换，私网内部的所有主机均可共享一个公网 IP 地址，<br>实现对公网的访问，从而能够最大限度的节省 IP 地址资源。</p><h3 id="NAT的应用"><a href="#NAT的应用" class="headerlink" title="NAT的应用"></a>NAT的应用</h3><img src="/2021/05/06/P2P框架的实现/2.png"><p>私网内有两台机器（如图 5-8）192.168.1.23 和 192.168.1.24 与公网通信，机器上的<br>网络进程分别是 QQ/微信与头条/抖音。在数据传输的过程中，NAT 路由器会为每一个网络进<br>程分配相应端口与公网通信。</p><h3 id="NAT种类"><a href="#NAT种类" class="headerlink" title="NAT种类"></a>NAT种类</h3><p><strong>完全锥型 NAT</strong></p><p>完全锥型 NAT（Full Cone NAT），私网机器的网络进程（iAddr:iPort）被 NAT 路由器<br>映射为公网地址（pAddr:pPort），后续该网络进程的所有数据报文都被转换为公网地址<br>（pAddr:pPort），公网任何一台机器发送报文到（pAddr:pPort），会被转发到私网机器的网<br>络进程（iAddr:iPort）。</p><img src="/2021/05/06/P2P框架的实现/3.png"><p><strong>对称NAT</strong></p><p>对称 NAT（Symmetric NAT），NAT 路由器会为私网机器的每一个网络进程都会分配一个<br>地址与端口，从而把私网网络进程（iAddr1:iPort1）与公网地址（pAddr1:pPort1）。后续<br>NAT 路由器会把私网机器地址端口（iAddr1:iPort1）与公网地址端口（pAddr1:pPort1）完<br>全相同的报文看作一个连接。</p><img src="/2021/05/06/P2P框架的实现/4.png"><p>私网机器的网络进程每与一台公网机器通信，NAT 路由器都会重新分配一个地址端<br>口。这样使得每一个通信链路都是经过 NAT 路由器不同的端口。公网机器往私网发送报文<br>也是经过不一样的端口。</p><p><strong>IP限制锥形NAT</strong></p><p>私网机器网络进程(192.168.1.3:2341)发送报文到公网地址(180.93.45.46:8080)的服<br>务器，在 NAT 路由器上产生了映射公网地址(112.93.114.33:34523)。</p><img src="/2021/05/06/P2P框架的实现/5.png"><p>一、私网机器网络进程没有发送报文给其他公网机器，NAT 路由器只允许公网 IP地址为 180.93.45.46 的机器数据进入，其他地址机器的数据报文则会被 NAT 路由器阻挡，不允许进入内网。</p><p>二、私网机器网络进程同时发送报文给另一台公网机器，此时 NAT 路由器生成了NAT 映射记录，则另一台公网机器发送报文与公网地址(112.93.114.33:34523)，NAT 路由器是允许报文进入私网。<br>先由私网机器发送报文到公网机器，限制锥形 NAT 路由器方能允许公网机器报文进入私网。</p><p><strong>端口限制锥形 NAT</strong></p><p>端口限制锥形 NAT（Port Restricted Cone NAT），在 IP 限制锥型 NAT 的基础上，又添<br>加了一层端口限制。</p><img src="/2021/05/06/P2P框架的实现/6.png"><p>一、私网机器网络进程没有发送报文给公网机器(180.93.45.46)其他端口，则 NAT<br>路由器只允许公网地址（180.93.45.46:8080）的数据报文进入私网。</p><p>二、私网机器网络进程发送数据给公网机器(180.93.45.46)的其他端口，NAT 路由<br>器生成一条 NAT 记录，则允许该端口的数据报文到达网络进程。 </p><h2 id="鉴别NAT方案"><a href="#鉴别NAT方案" class="headerlink" title="鉴别NAT方案"></a>鉴别NAT方案</h2><img src="/2021/05/06/P2P框架的实现/7.png"><h3 id="对称NAT与锥形NAT"><a href="#对称NAT与锥形NAT" class="headerlink" title="对称NAT与锥形NAT"></a>对称NAT与锥形NAT</h3><p>对称 NAT 与锥型 NAT 的区别，在于私网机器与不同的公网机器通信在 NAT 路由器上产<br>生映射表记录的条数。对称 NAT 与 N 台公网机器通信则生成 N 条记录；而锥形 NAT 与 N 台<br>公网机器通信则生成 1 条记录。</p><img src="/2021/05/06/P2P框架的实现/8.png"><p>判断流程如下，如图 5-14 所示：<br>步骤 1：私网机器（192.168.1.3:2341）发送报文到服务器 1（180.93.45.46:8888）的 NAT<br>路由器产生了对外公网 IP（112.93.114.33:23454），此时服务器 1 获取客户端 IP 地址即为<br>对外公网 IP（112.93.114.33:23454）<br>步骤 2：私网机器（192.168.1.3:2341）发送报文到服务器 2（118.56.189.34:8888）。服务<br>器 2 获取客户端 IP 地址（iAddr:iPort）<br>步骤 3：服务器 1 获取客户端的 IP 地址，发送给服务器 2。服务器 2 对比服务器 1 发过来的<br>地址与服务器 2 获取的客户端 IP 地址。若两个客户端 IP 地址一致，则为锥型 NAT；若不一<br>致则为对称 NAT。  </p><h3 id="完全锥形-NAT-与限制锥形-NAT"><a href="#完全锥形-NAT-与限制锥形-NAT" class="headerlink" title="完全锥形 NAT 与限制锥形 NAT"></a>完全锥形 NAT 与限制锥形 NAT</h3><p>完全锥型 NAT 与限制锥形 NAT 的区别，在于其他公网机器发送报文到 NAT 路由器对外<br>公网 IP 地址能否到达私网机器，NAT 路由器的 NAT 类型是完全锥型 NAT 的话，私网机器能<br>够收到报文数据，限制锥形 NAT 则不能收到报文数据。</p><img src="/2021/05/06/P2P框架的实现/9.png"><p>判断流程如下，如图 5-15 所示：<br>步骤 1：私网机器网络进程(192.168.1.3:2341)发送报文给服务器 1(180.93.45.46：8888)。<br>服务器 1 获取到客户端 IP 地址（即 NAT 路由器对外公网 IP 地址）。<br>步骤 2：服务器 1 将获取的客户端 IP 地址发送给服务器 2。<br>步骤 3：服务器 2 收到客户端 IP 地址以后，发送报文给客户端 IP 地址。探测客户端 IP 地<br>址能否收到报文数据。若是完全锥型 NAT，则私网机器能够收到报文；若是限制锥形 NAT，<br>则私网不能收到报文数据。<br>步骤 4：私网机器网络进程收到报文数据，继续发送报文给服务器 1。服务器 1 收到了报文<br>数据。判断结束。服务器 1 收到报文数据，则为完全锥型 NAT；否则为限制锥型 NAT。  </p><h3 id="IP-限制锥形-NAT-与端口限制锥形-NAT"><a href="#IP-限制锥形-NAT-与端口限制锥形-NAT" class="headerlink" title="IP 限制锥形 NAT 与端口限制锥形 NAT"></a>IP 限制锥形 NAT 与端口限制锥形 NAT</h3><p>IP 限制锥型 NAT 与端口限制锥型 NAT 的区别，在于公网机器的其他端口发送报文数据<br>给私网机器网络进程能否收到。网络进程能收到同一台公网机器的其他端口发送的报文数据<br>则为 IP 限制锥型 NAT，否则为端口限制锥型 NAT。</p><img src="/2021/05/06/P2P框架的实现/10.png"><p>判断流程如下，如图 5-16 所示：<br>步骤 1： 私网机器网络进程(192.168.1.3:2341)发送报文给服务器(180.93.45.46：8888)。<br>服务器获取到客户端 IP 地址。<br>步骤 2：服务器从另一个端口(180.93.45.46:8888)，发送报文数据给客户端 IP 地址。若私<br>网机器能够收到报文则为 IP 限制锥型 NAT，若不能则为端口限制锥型 NAT。<br>步骤 3：私网机器网络进程回发报文给服务器 8888 的端口，收到报文数据，判断结束。若<br>收到数据则为 IP 限制锥形 NAT，否则为端口限制锥型 NAT。   </p><h2 id="网络穿透"><a href="#网络穿透" class="headerlink" title="网络穿透"></a>网络穿透</h2><h3 id="穿透完全锥形-NAT"><a href="#穿透完全锥形-NAT" class="headerlink" title="穿透完全锥形 NAT"></a>穿透完全锥形 NAT</h3><p>穿透过程中，两端私网机器都是在 NAT 路由器之下的。两端 NAT 只要有一方为完全锥型<br>NAT 的时候，是可以穿透的。NAT1 为完全锥形 NAT，NAT2 为<br>任意 NAT。</p><img src="/2021/05/06/P2P框架的实现/11.png"><p>步骤 1：私网机器 1（192.168.1.3:2341）发送报文给服务器（180.93.45.46:8888）。服务<br>器获取到私网机器 1 的公网 IP 地址与端口（112.93.14.56:43891）。<br>步骤 2：服务器收到信息后，通知私网机器 2（192.168.2.6:6583），通知信息内含私网机器<br>1 的公网 IP 地址与端口（112.93.14.56:43891）。<br>步骤 3：私网机器 2（192.168.2.6:6583）发送数据给私网机器 1 的公网 IP 地址与端口<br>（112.93.14.56:43891），此时私网机器 1 就能收到私网机器 2 发送的报文数据，并且能过<br>获取私网机器 2 的公网 IP 地址与端口（iAddr:iPort）。<br>步骤 4：私网机器 1 回发报文信息给私网机器 2 的公网 IP 地址与端口（iAddr:iPort），此<br>时私网机器 2 能够收到报文数据。穿透流程结束。  </p><h3 id="穿透限制锥形-NAT"><a href="#穿透限制锥形-NAT" class="headerlink" title="穿透限制锥形 NAT"></a>穿透限制锥形 NAT</h3><p>限制锥型 NAT 的特点是限制了其他公网机器报文数据传输。如果在采用完全锥型 NAT 的穿透步骤，就会在步骤 3 不能到达私网机器。针对于两端 NAT 都是限制锥形 NAT 的情况，穿透流程如图 5-19 所示。</p><img src="/2021/05/06/P2P框架的实现/12.png"><p>步骤 1：私网机器 1（192.168.1.3:2341）发送报文给服务器（180.93.45.46:8888），服务<br>器获取私网机器的公网 IP 地址（112.93.14.56:43891）。<br>步骤 2：服务器发送通知报文给私网机器 2（192.168.2.6:6583），通知报文中内含私网机器<br>1 的公网 IP 地址（112.93.14.56:43891）。<br>步骤 3：私网机器 2 发送报文数据到私网机器 1 的公网 IP 地址（112.93.14.56:43891）。由<br>于 NAT1 是限制锥型 NAT，此时私网机器 1 是不能收到报文数据的。<br>步骤 4：私网机器 2 进行完步骤 3 以后，立即发送报文给服务器（180.93.45.46:8888），要<br>求私网机器 1 发送数据给私网机器 2 的公网 IP 地址。<br>步骤 5：服务器通知私网机器 1，通知信息内含公网 IP 地址（180.20.198.42.9681）。<br>步骤 6：私网机器 1 发送报文数据给私网机器 2 的公网 IP 地址。由于步骤 3 发送报文给私<br>网机器 2 的公网 IP 地址，此份报文会被 NAT2 的路由器认为是步骤 3 的回复。所以此步骤会<br>被允许通过。此时已经穿透了 NAT2。<br>步骤 7：私网机器 2 回发报文给私网机器 1，此时穿透了 NAT1。穿透流程结束。  </p><h3 id="穿透对称NAT"><a href="#穿透对称NAT" class="headerlink" title="穿透对称NAT"></a>穿透对称NAT</h3><p>对称 NAT 的特点是每一个不同公网机器的通信，都会被分配不同的映射端口通信。若<br>参照限制锥型 NAT 的穿透流程，则在不能准确地知道步骤 3 所产生的公网 IP 地址与端口。<br>穿透流程如图 5-20 所示。NAT1 为限制锥型 NAT，NAT2 为对称 NAT。</p><img src="/2021/05/06/P2P框架的实现/13.png"><p>步骤 1：私网机器 1（192.168.1.3:2341）发送报文数据给服务器（180.93.45.46:8888），<br>请求与私网机器 2 进行透传。<br>步骤 2：服务器（180.93.45.46:8888）发送通知信息给私网机器 2。通知信息内含私网机器<br>1 的公网 IP 地址（112.93.14.56:43891）。<br>步骤 3：私网机器 2 收到通知信息，发送报文数据给私网机器 1 的公网 IP 地址。此时由于<br>NAT1 为限制锥形 NAT，数据是不被允许进入私网的。同时由于 NAT2 为对称 NAT，所以会在<br>此次报文发送过程中，会被产生新的映射记录，分配公网地址与端口（iAddr:iPort）。<br>步骤 4：私网机器 2 进行完步骤 3 以后，发送报文信息给服务器的另一个端口 8889，此步骤<br>也会在路由器上产生一条新的映射记录，分配公网地址与端口（mAddr:mPort）。服务器同时<br>也获取到新的公网地址与端口（mAddr:mPort）。<br>步骤 5：服务器（180.93.45.46:8889）发送通知信息给私网机器 1。通知信息内含步骤 4 产<br>生的新记录公网地址与端口（mAddr:mPort）。此时根据 iPort 与 mPort 产生的相隔时间很<br>短，可以来判断 iPort 的值,即需要穿透的端口。为了判断的根据准确，可以在产生 mPort<br>之前也加上一次新记录，即再步骤 3 以前让 NAT 路由器产生一条记录，这样准确度会大大穿<br>透的概率。<br>步骤 6：根据 mPort 的值，来猜测 iPort 的值，发送报文信息给私网机器 2 的公网地址与端<br>口（mAddr:mPort）。准确的 mPort 值，则能够穿透 NAT2。<br>步骤 7：收到穿透报文信息后，回复报文信息。流程完毕。  </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;中心化网络&quot;&gt;&lt;a href=&quot;#中心化网络&quot; class=&quot;headerlink&quot; title=&quot;中心化网络&quot;&gt;&lt;/a&gt;中心化网络&lt;/h2&gt;&lt;p&gt;每个客户端都是平等的，没有客户端与服务器之分，客户端之间互相提供服务，不存在“特殊”身份。客户端可与客户端直接交流。
      
    
    </summary>
    
      <category term="基础" scheme="http://twh233.github.io/categories/%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="TCP/IP" scheme="http://twh233.github.io/tags/TCP-IP/"/>
    
  </entry>
  
  <entry>
    <title>用户态协议栈的实现</title>
    <link href="http://twh233.github.io/2021/05/02/%E7%94%A8%E6%88%B7%E6%80%81%E5%8D%8F%E8%AE%AE%E6%A0%88%E7%9A%84%E5%AE%9E%E7%8E%B0/"/>
    <id>http://twh233.github.io/2021/05/02/用户态协议栈的实现/</id>
    <published>2021-05-02T02:47:18.000Z</published>
    <updated>2021-05-02T06:51:27.417Z</updated>
    
    <content type="html"><![CDATA[<h2 id="C10M问题"><a href="#C10M问题" class="headerlink" title="C10M问题"></a>C10M问题</h2><h3 id="C10K"><a href="#C10K" class="headerlink" title="C10K"></a>C10K</h3><p>在讲解C10M问题之前，我们先回顾C10K的问题。</p><p>10年前，开发人员处理C10K可扩展性问题时，尽量避免服务处理器超过1万个的并发连接。通过改进操作系统内核以及用事件驱动服务器（典型技术实现如nginx和Node）代替线程服务器（典型代表：Apache），使得这个问题已经被解决。</p><p>以传统的网络编程模型作为代表的Apache为例，C10K问题上的局限表现在：服务器的性能会随着连接数的增多而变差。</p><p><strong>OS 内核中的两个基本问题：</strong></p><ol><li><p>连接数=线程数/进程数：当一个数据包进来，内核会遍历其所有进程以决定由哪个进程来处理这个数据包。</p></li><li><p>连接数=选择数/轮询次数（单线程）：同样的可扩展性问题，每个包都要走一遭列表上所有的 socket。</p></li></ol><p>当时没有epoll，只有poll/select 有拷贝速度和数量的限制，如果使用多线程/多进程，又有内存不够的限制。后引入epoll，解决了上述问题</p><h3 id="C10M"><a href="#C10M" class="headerlink" title="C10M"></a>C10M</h3><p>实现C10M（1千万）并发连接意味着什么？</p><ol><li>1千万的并发连接数。</li><li>100万个连接/秒：每个连接以这个速度保持约10秒；</li><li>10GB/秒的连接：快速连接到互联网；</li><li>1千万个数据包/秒：据估计目前的服务器每秒处理 50K 数据包，以后会更多；</li><li>10 微秒的延迟： 可扩展服务器也许可以处理这个规模（但延迟可能会飙升）；</li><li>10 微秒的抖动： 限制最大延迟；</li><li>并发 10 核技术： 软件应支持更多核的服务器（通常情况下，软件能轻松扩展到四核，服务器可以扩展到更多核，因此需要重写软件，以支持更多核的服务器）。</li></ol><p>解决C10M问题的一些思路：<br>将功能逻辑做好恰当的划分：数据面专门负责数据的处理，属于资源消耗的主要因素；控制面只负责一些偶尔才有非业务逻辑，比如与外部用户的交互、信息统计等。<br>另外，归纳一些高性能的网络数据处理框架（ Intel 的 DPDK、6wind、windriver），我们发现有如下共同点可以参考：</p><p>数据包直接传递到业务逻辑，不经过linux内核协议栈。<br>多线程的核间绑定：每个线程绑定到一个处理核心，好处是最大化核心CACHE利用、实现无锁设计、避免进程切换消耗等。<br>内存是另外一个核心要素：常见的内存池设计必须得以切实应用。<br>同时，我们不能单纯从软件上去思考解决方案，而是需要结合操作系统，比如：内存、CPU、磁盘、网卡、应用程序、操作系统。</p><h2 id="用户态协议栈"><a href="#用户态协议栈" class="headerlink" title="用户态协议栈"></a>用户态协议栈</h2><p>一般的客户端请求到应用程序的具体数据流程：</p><img src="/2021/05/02/用户态协议栈的实现/1.png"><p>步骤：<br>1）客户端请求数据，先经过网卡，服务器需要从网卡copy数据到内核协议栈（tcp/bsd）。<br>2）再从内核协议栈copy数据到应用程序。  </p><p>由此可见，客户端与应用程序之间的数据交互，多了两次数据拷贝的操作，在大量数据并发的情况下，必将会严重影响性能。</p><p>优化思路：可以跳过内核协议栈，去除拷贝操作，数据直接从网卡到应用程序，这种方式称为零拷贝。</p><p><strong>mmap</strong><br>mmap是一种内存映射文件的方法，即将一个文件或者其它对象映射到进程的地址空间，实现文件磁盘地址和进程虚拟地址空间中一段虚拟地址的一一对应关系。<br><img src="/2021/05/02/用户态协议栈的实现/2.png"></p><p>有了mmap的映射，应用程序进程就可以采用指针的方式读写操作这一段内存，而系统会自动回写脏页面到对应的文件磁盘上，即完成了对文件的操作而不必再调用read,write等系统调用函数。netmap开源框架就是采用这种方式实现的。</p><img src="/2021/05/02/用户态协议栈的实现/3.png"><h2 id="net-map"><a href="#net-map" class="headerlink" title="net_map"></a>net_map</h2><p>在netmap框架，内核拥有数据包池，发送环接收环上的数据包不需要动态申请，有数据到达网卡时，直接从数据包池中取出一个数据包，然后将数据放入此数据包中，再将数据包的描述符放入接收环中。内核中的数据包池，通过mmap技术映射到用户空间，用户态程序最终通过netmap_if获取接收发送环netmap_ring，进行数据包的获取发送。</p><p>netmap API函数主要为2个头文件，netmap.h和netmap_user.h，当解压下载好的netmap程序后，在./netmap/sys/net/目录下，文本主要对这2个头文件进行分析。</p><h3 id="netmap-h"><a href="#netmap-h" class="headerlink" title="netmap.h"></a>netmap.h</h3><p>netmap.h 被 netmap_user.h 调用，里面定义了一些宏和几个主要的结构体，如nmreq{}, netmap_if{}, netmap_ring{}, netmap_slot{}。<br>一个网卡(或者网络接口)只有一个 netmap_if{}结构，在使用 mmap()申请的共享内存中，通过 netmap_if{}结构可以访问到任何一个发送/接收环(也就是 netmap_ring{}结构，一个netmap_if{}可以对应多发送/接收环,这应该和物理硬件有关。<br>找到 netmap_ring{}的地址后，我们就可以找到环中每一个 buffer 的地址(buffer 里面存储的是将要发送/接收的数据包)。<br>通过一个 nifp 是如何访问到多个收/发环的，通过一个 ring 如何找到多个不同的 buffer地址的，其实都是通过存储这些结构体相邻的后面一部分空间实现。  </p><h3 id="nm-open"><a href="#nm-open" class="headerlink" title="nm_open"></a>nm_open</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">static struct nm_desc *nm_open(const char *ifname, const struct nmreq *req,</span><br><span class="line">    uint64_t new_flags, const struct nm_desc *arg)</span><br><span class="line">&#123;</span><br><span class="line">    struct nm_desc *d = NULL;</span><br><span class="line">    if (strncmp(ifname, &quot;netmap:&quot;, 7) &amp;&amp; strncmp(ifname, &quot;vale&quot;, 4)) &#123;  // 判断是否是 netmap 模式接口名</span><br><span class="line">        errno = 0;</span><br><span class="line">        return NULL;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    nr_flags = NR_REG_ALL_NIC;</span><br><span class="line"></span><br><span class="line">    d = (struct nm_desc *)calloc(1, sizeof(*d));</span><br><span class="line"></span><br><span class="line">    d-&gt;self = d;</span><br><span class="line">    d-&gt;fd = open(NETMAP_DEVICE_NAME, O_RDWR); // NETMAP_DEVICE_NAME 是 /dev/netmap</span><br><span class="line">    d-&gt;req.nr_version = NETMAP_API;</span><br><span class="line">    d-&gt;req.nr_ringid &amp;= ~NETMAP_RING_MASK;</span><br><span class="line">    d-&gt;req.nr_ringid |= nr_ringid;</span><br><span class="line">    d-&gt;req.nr_flags |= nr_flags;</span><br><span class="line">    memcpy(d-&gt;req.nr_name, ifname, namelen);</span><br><span class="line">    d-&gt;req.nr_name[namelen] = &apos;\0&apos;;</span><br><span class="line"></span><br><span class="line">    if (ioctl(d-&gt;fd, NIOCREGIF, &amp;d-&gt;req)) &#123;  // 注册命令</span><br><span class="line">        snprintf(errmsg, MAXERRMSG, &quot;NIOCREGIF failed: %s&quot;, strerror(errno));</span><br><span class="line">        goto fail;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if ((!(new_flags &amp; NM_OPEN_NO_MMAP) || parent) &amp;&amp; nm_mmap(d, parent)) &#123;  // mmap 映射内存，下面分析细节过程</span><br><span class="line">            snprintf(errmsg, MAXERRMSG, &quot;mmap failed: %s&quot;, strerror(errno));</span><br><span class="line">        goto fail;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return d;</span><br><span class="line"></span><br><span class="line">fail:</span><br><span class="line">    nm_close(d);</span><br><span class="line">    if (errno == 0)</span><br><span class="line">        errno = EINVAL;</span><br><span class="line">    return NULL; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>说明：<br>1）调用nm_open函数会对传递的ifname指针里面的字符串进行分析，提取出网络接口名。<br>如：<strong>nmr = nm_open(“netmap:eth0”, NULL, 0, NULL)</strong></p><p>2）nm_open() 会 对 struct nm_desc *d 申 请 内 存 空 间 ， 并 通 过 <strong>d-&gt;fd =open(NETMAP_DEVICE_NAME, O_RDWR)</strong>;打开一个特殊的设备/dev/netmap 来创建文件描述符 d-&gt;fd。</p><p>3）通过 <strong>ioctl(d-&gt;fd, NIOCREGIF, &amp;d-&gt;req)</strong>语句，将 d-&gt;fd 绑定到一个特殊的接口，并对 d-&gt;req结构体里面的成员做初始化，包括：</p><p>在共享内存区域中 nifp 的偏移，<br>共享区域的大小nr_memsize，<br>tx/rx 环的大小 nr_tx_slots/nr_rx_slots(大小为 256)，<br>tx/rx 环的数量 nr_tx_rings、nr_rx_rings(视硬件性能而定)等。<br>4）接着在 <strong>if ((!(new_flags &amp; NM_OPEN_NO_MMAP) || parent) &amp;&amp; nm_mmap(d, parent))</strong>语句中调用 nm_mmap 函数， 继续给 d 指针指向的内存赋值。</p><h3 id="nm-mmap"><a href="#nm-mmap" class="headerlink" title="nm_mmap"></a>nm_mmap</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">static int nm_mmap(struct nm_desc *d, const struct nm_desc *parent)</span><br><span class="line">&#123;</span><br><span class="line">//XXX TODO: check if mmap is already done</span><br><span class="line"></span><br><span class="line">if (IS_NETMAP_DESC(parent) &amp;&amp; parent-&gt;mem &amp;&amp;</span><br><span class="line">    parent-&gt;req.nr_arg2 == d-&gt;req.nr_arg2) &#123;</span><br><span class="line">/* do not mmap, inherit from parent */</span><br><span class="line">D(&quot;do not mmap, inherit from parent&quot;);</span><br><span class="line">d-&gt;memsize = parent-&gt;memsize;</span><br><span class="line">d-&gt;mem = parent-&gt;mem;</span><br><span class="line">&#125; else &#123;</span><br><span class="line">/* XXX TODO: check if memsize is too large (or there is overflow) */</span><br><span class="line">d-&gt;memsize = d-&gt;req.nr_memsize; //将需要申请的内存大小赋值给d-&gt;memsize</span><br><span class="line">d-&gt;mem = mmap(0, d-&gt;memsize, PROT_WRITE | PROT_READ, MAP_SHARED,</span><br><span class="line">d-&gt;fd, 0); //申请共享内存</span><br><span class="line">if (d-&gt;mem == MAP_FAILED) &#123;</span><br><span class="line">goto fail;</span><br><span class="line">&#125;</span><br><span class="line">d-&gt;done_mmap = 1;</span><br><span class="line">&#125;</span><br><span class="line">&#123;</span><br><span class="line">struct netmap_if *nifp = NETMAP_IF(d-&gt;mem, d-&gt;req.nr_offset); //通过 d-&gt;req.nr_offset 这个偏移量的到 nifp 的地址， NETMAP_IF 前面说过</span><br><span class="line">struct netmap_ring *r = NETMAP_RXRING(nifp, d-&gt;first_rx_ring); ///对 nifp，找接收包的环 r，因为 index 为 0，所以省略了</span><br><span class="line">if ((void *)r == (void *)nifp) &#123;</span><br><span class="line">/* the descriptor is open for TX only */</span><br><span class="line">r = NETMAP_TXRING(nifp, d-&gt;first_tx_ring);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">*(struct netmap_if **)(uintptr_t)&amp;(d-&gt;nifp) = nifp;对d-&gt;nifp 赋值，虽然 d-&gt;nifp 使用 const 定义的，但对其取地址再强值类型转换后，依然可以对其指向的空间进行操作</span><br><span class="line">*(struct netmap_ring **)(uintptr_t)&amp;d-&gt;some_ring = r; //同理，对 d-&gt;some_ring 进行赋值，此处指向了第一个接受(rx)环。</span><br><span class="line">*(void **)(uintptr_t)&amp;d-&gt;buf_start = NETMAP_BUF(r, 0); //计算第一个 buffer 的地址，并存入 d-&gt;buf_start 指针中</span><br><span class="line">*(void **)(uintptr_t)&amp;d-&gt;buf_end =</span><br><span class="line">(char *)d-&gt;mem + d-&gt;memsize; //计算共享区间的最后一个地址，赋值给 d-&gt;buf_end</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">return 0;</span><br><span class="line"></span><br><span class="line">fail:</span><br><span class="line">return EINVAL;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>说明：<br>1）nifp 为申请的共享内存首地址 d-&gt;mem 向右偏移 d-&gt;req.nr_offset(该值在调用前面的ioctl()时得到)得到。并且一个网络接口(网卡)只对应一个 nifp。 (使用宏 NETMAP_IF 计算)</p><p>2）得到的 nifp 的地址，nifp 结构体里最后定义的 ring_ofs[0]以及接下来内存中的 ring_ofs[1]，ring_ofs[2]…，这些内存中存储的是访问每一个环(tx or rx ring)的偏移量，通过这个偏移量我们可以得到每一个环的地址(使用宏 NETMAP_RXRING/NETMAP_TXRING 进行计算)。</p><p>3）得到每个收/发环的地址了， netmap_ring 结构体最后面有一个 struct netmap_slot slot[0];，通过 slot[0],后面内存的slot[1], slot[2], slot[3]…, 取出里面的偏移量就可以得到每一个 buffer(也叫数据包槽)的地址了(使用宏 NETMAP_BUF 计算得到)。 到这里， netmap 如何访问到内存槽中的每一个 buffer 的。</p><p>4）在 struct nm_desc 中， nifp， some_ring， buf_start， buf_end 等指针都定义为 const 的，但我们通过对其取地址再强转指针的方式去往这些指针指向的内存中赋值。<br>注:在 nm_mmap()中使用 mmap()申请共享的时候， 这些数据结构里数据的设计是内核模块就已写好了的，我们在这里其实是在做验证。</p><h3 id="nm-nextpkt"><a href="#nm-nextpkt" class="headerlink" title="nm_nextpkt"></a>nm_nextpkt</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">static u_char *nm_nextpkt(struct nm_desc *d, struct nm_pkthdr *hdr)</span><br><span class="line">&#123;</span><br><span class="line">int ri = d-&gt;cur_rx_ring;  //当前接收环的编号</span><br><span class="line"></span><br><span class="line">do &#123;</span><br><span class="line">/* compute current ring to use */</span><br><span class="line">struct netmap_ring *ring = NETMAP_RXRING(d-&gt;nifp, ri); //得到当前rx环的地址</span><br><span class="line">if (!nm_ring_empty(ring)) &#123; //判断环里是否有新到的包</span><br><span class="line">u_int i = ring-&gt;cur;    //当前该访问哪个槽（buffer）了</span><br><span class="line">u_int idx = ring-&gt;slot[i].buf_idx;  //得到第i个buffer的下标</span><br><span class="line">u_char *buf = (u_char *)NETMAP_BUF(ring, idx); //得到存有到来数据包的地址</span><br><span class="line"></span><br><span class="line">// __builtin_prefetch(buf);</span><br><span class="line">hdr-&gt;ts = ring-&gt;ts;</span><br><span class="line">hdr-&gt;len = hdr-&gt;caplen = ring-&gt;slot[i].len;</span><br><span class="line">ring-&gt;cur = nm_ring_next(ring, i); //ring-&gt;cur向后移动一位</span><br><span class="line">/* we could postpone advancing head if we want</span><br><span class="line"> * to hold the buffer. This can be supported in</span><br><span class="line"> * the future.</span><br><span class="line"> */</span><br><span class="line">ring-&gt;head = ring-&gt;cur;</span><br><span class="line">d-&gt;cur_rx_ring = ri; //将当前环(d-&gt;cur_rx_ring)指向第ri个（因为可能有多个环）</span><br><span class="line">return buf;  //将数据包地址返回</span><br><span class="line">&#125;</span><br><span class="line">ri++;</span><br><span class="line">if (ri &gt; d-&gt;last_rx_ring) //如果ri超过了rx环的数量，则再从第一个rx环开始检测是否有包到来</span><br><span class="line">ri = d-&gt;first_rx_ring;</span><br><span class="line">&#125; while (ri != d-&gt;cur_rx_ring);</span><br><span class="line">return NULL; /* nothing found */</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>说明：<br>1）nm_nextpkt()是用来接收网卡上到来的数据包的函数。</p><p>2）nm_nextpkt()会将所有rx环都检查一遍，当发现有一个rx环有需要接收的数据包时，得到这个数据包的地址，并返回。所以nm_nextpkt()每次只能获取一个数据包。</p><h3 id="nm-inject"><a href="#nm-inject" class="headerlink" title="nm_inject"></a>nm_inject</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line"> * Same prototype as pcap_inject(), only need to cast.</span><br><span class="line"> */</span><br><span class="line">static int nm_inject(struct nm_desc *d, const void *buf, size_t size)</span><br><span class="line">&#123;</span><br><span class="line">u_int c, n = d-&gt;last_tx_ring - d-&gt;first_tx_ring + 1,</span><br><span class="line">ri = d-&gt;cur_tx_ring;</span><br><span class="line"></span><br><span class="line">for (c = 0; c &lt; n ; c++, ri++) &#123;</span><br><span class="line">/* compute current ring to use */</span><br><span class="line">struct netmap_ring *ring;</span><br><span class="line">uint32_t i, j, idx;</span><br><span class="line">size_t rem;</span><br><span class="line"></span><br><span class="line">if (ri &gt; d-&gt;last_tx_ring)</span><br><span class="line">ri = d-&gt;first_tx_ring;</span><br><span class="line">ring = NETMAP_TXRING(d-&gt;nifp, ri);</span><br><span class="line">rem = size;</span><br><span class="line">j = ring-&gt;cur;</span><br><span class="line">while (rem &gt; ring-&gt;nr_buf_size &amp;&amp; j != ring-&gt;tail) &#123;</span><br><span class="line">rem -= ring-&gt;nr_buf_size;</span><br><span class="line">j = nm_ring_next(ring, j);</span><br><span class="line">&#125;</span><br><span class="line">if (j == ring-&gt;tail &amp;&amp; rem &gt; 0)</span><br><span class="line">continue;</span><br><span class="line">i = ring-&gt;cur;</span><br><span class="line">while (i != j) &#123;</span><br><span class="line">idx = ring-&gt;slot[i].buf_idx;</span><br><span class="line">ring-&gt;slot[i].len = ring-&gt;nr_buf_size;</span><br><span class="line">ring-&gt;slot[i].flags = NS_MOREFRAG;</span><br><span class="line">nm_pkt_copy(buf, NETMAP_BUF(ring, idx), ring-&gt;nr_buf_size);</span><br><span class="line">i = nm_ring_next(ring, i);</span><br><span class="line">buf = (char *)buf + ring-&gt;nr_buf_size;</span><br><span class="line">&#125;</span><br><span class="line">idx = ring-&gt;slot[i].buf_idx;</span><br><span class="line">ring-&gt;slot[i].len = rem;</span><br><span class="line">ring-&gt;slot[i].flags = 0;</span><br><span class="line">nm_pkt_copy(buf, NETMAP_BUF(ring, idx), rem);</span><br><span class="line">ring-&gt;head = ring-&gt;cur = nm_ring_next(ring, i);</span><br><span class="line">d-&gt;cur_tx_ring = ri;</span><br><span class="line">return size;</span><br><span class="line">&#125;</span><br><span class="line">return 0; /* fail */</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>说明：<br>1）nm_inject()是用来往共享内存中写入待发送的数据包数据的。数据包经共享内存拷贝到网卡，然后发送出去。所以 nm_inject()是用来发包的。</p><p>2）nm_inject()也会查找所有的发送环(tx 环)，找到一个可以发送的槽，就将数据包写入并返回，所以每次函数调用也只能发送一个包。</p><h3 id="nm-close"><a href="#nm-close" class="headerlink" title="nm_close"></a>nm_close</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">static int nm_close(struct nm_desc *d)</span><br><span class="line">&#123;</span><br><span class="line">/*</span><br><span class="line"> * ugly trick to avoid unused warnings</span><br><span class="line"> */</span><br><span class="line">static void *__xxzt[] __attribute__ ((unused))  =</span><br><span class="line">&#123; (void *)nm_open, (void *)nm_inject,</span><br><span class="line">  (void *)nm_dispatch, (void *)nm_nextpkt &#125; ;</span><br><span class="line"></span><br><span class="line">if (d == NULL || d-&gt;self != d)</span><br><span class="line">return EINVAL;</span><br><span class="line">if (d-&gt;done_mmap &amp;&amp; d-&gt;mem)</span><br><span class="line">munmap(d-&gt;mem, d-&gt;memsize);  //释放申请的共享内存</span><br><span class="line">if (d-&gt;fd != -1) &#123;</span><br><span class="line">close(d-&gt;fd);  //关闭文件描述符</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bzero(d, sizeof(*d)); //将d指向的空间全部置0</span><br><span class="line">free(d);//释放指针d指向的空间</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>说明：<br>nm_close 函数就是回收动态内存，回收共享内存，关闭文件描述符。</p><h2 id="使用net-map实现udp代码"><a href="#使用net-map实现udp代码" class="headerlink" title="使用net_map实现udp代码"></a>使用net_map实现udp代码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line"></span><br><span class="line">#include &lt;sys/poll.h&gt;</span><br><span class="line">#include &lt;arpa/inet.h&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#define NETMAP_WITH_LIBS</span><br><span class="line"></span><br><span class="line">#include &lt;net/netmap_user.h&gt; </span><br><span class="line">#pragma pack(1)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#define ETH_ALEN6</span><br><span class="line">#define PROTO_IP0x0800 // IP声明地址</span><br><span class="line">#define PROTO_ARP0x0806</span><br><span class="line"></span><br><span class="line">#define PROTO_UDP17</span><br><span class="line">#define PROTO_ICMP1</span><br><span class="line">#define PROTO_IGMP2</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">根据TCP/IP协议，分别组装每个结构体</span><br><span class="line">*/</span><br><span class="line">struct ethhdr &#123;</span><br><span class="line">unsigned char h_dest[ETH_ALEN];</span><br><span class="line">unsigned char h_source[ETH_ALEN];</span><br><span class="line">unsigned short h_proto;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">struct iphdr &#123;</span><br><span class="line">unsigned char version;</span><br><span class="line">unsigned char tos;</span><br><span class="line">unsigned short tot_len;</span><br><span class="line">unsigned short id;</span><br><span class="line">unsigned short flag_off;</span><br><span class="line">unsigned char ttl;</span><br><span class="line">unsigned char protocol;</span><br><span class="line">unsigned short check;</span><br><span class="line">unsigned int saddr;</span><br><span class="line">unsigned int daddr;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">struct udphdr &#123;</span><br><span class="line">unsigned short source;</span><br><span class="line">unsigned short dest;</span><br><span class="line">unsigned short len;</span><br><span class="line">unsigned short check;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">struct udppkt &#123;</span><br><span class="line">struct ethhdr eh;</span><br><span class="line">struct iphdr ip;</span><br><span class="line">struct udphdr udp;</span><br><span class="line">unsigned char body[128];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">struct arphdr &#123;</span><br><span class="line">unsigned short h_type;</span><br><span class="line">unsigned short h_proto;</span><br><span class="line">unsigned char h_addrlen;</span><br><span class="line">unsigned char protolen;</span><br><span class="line">unsigned short oper;</span><br><span class="line">unsigned char smac[ETH_ALEN];</span><br><span class="line">unsigned int sip;</span><br><span class="line">unsigned char dmac[ETH_ALEN];</span><br><span class="line">unsigned int dip;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">struct arppkt &#123;</span><br><span class="line">struct ethhdr eh;</span><br><span class="line">struct arphdr arp;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">struct icmphdr &#123;</span><br><span class="line">unsigned char type;</span><br><span class="line">unsigned char code;</span><br><span class="line">unsigned short check;</span><br><span class="line">unsigned short identifier;</span><br><span class="line">unsigned short seq;</span><br><span class="line">unsigned char data[32];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">struct icmppkt &#123;</span><br><span class="line">struct ethhdr eh;</span><br><span class="line">struct iphdr ip;</span><br><span class="line">struct icmphdr icmp;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">void print_mac(unsigned char *mac) &#123;</span><br><span class="line">int i = 0;</span><br><span class="line">for (i = 0;i &lt; ETH_ALEN-1;i ++) &#123;</span><br><span class="line">printf(&quot;%02x:&quot;, mac[i]);</span><br><span class="line">&#125;</span><br><span class="line">printf(&quot;%02x&quot;, mac[i]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void print_ip(unsigned char *ip) &#123;</span><br><span class="line">int i = 0;</span><br><span class="line"></span><br><span class="line">for (i = 0;i &lt; 3;i ++) &#123;</span><br><span class="line">printf(&quot;%d.&quot;, ip[i]);</span><br><span class="line">&#125;</span><br><span class="line">printf(&quot;%d&quot;, ip[i]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">void print_arp(struct arppkt *arp) &#123;</span><br><span class="line">print_mac(arp-&gt;eh.h_dest);</span><br><span class="line">printf(&quot; &quot;);</span><br><span class="line"></span><br><span class="line">print_mac(arp-&gt;eh.h_source);</span><br><span class="line">printf(&quot; &quot;);</span><br><span class="line"></span><br><span class="line">printf(&quot;0x%04x &quot;, ntohs(arp-&gt;eh.h_proto));</span><br><span class="line">printf(&quot;  &quot;);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int str2mac(char *mac, char *str) &#123;</span><br><span class="line"></span><br><span class="line">char *p = str;</span><br><span class="line">unsigned char value = 0x0;</span><br><span class="line">int i = 0;</span><br><span class="line"></span><br><span class="line">while (p != &apos;\0&apos;) &#123;</span><br><span class="line"></span><br><span class="line">if (*p == &apos;:&apos;) &#123;</span><br><span class="line">mac[i++] = value;</span><br><span class="line">value = 0x0;</span><br><span class="line">&#125; else &#123;</span><br><span class="line"></span><br><span class="line">unsigned char temp = *p;</span><br><span class="line">if (temp &lt;= &apos;9&apos; &amp;&amp; temp &gt;= &apos;0&apos;) &#123;</span><br><span class="line">temp -= &apos;0&apos;;</span><br><span class="line">&#125; else if (temp &lt;= &apos;f&apos; &amp;&amp; temp &gt;= &apos;a&apos;) &#123;</span><br><span class="line">temp -= &apos;a&apos;;</span><br><span class="line">temp += 10;</span><br><span class="line">&#125; else if (temp &lt;= &apos;F&apos; &amp;&amp; temp &gt;= &apos;A&apos;) &#123;</span><br><span class="line">temp -= &apos;A&apos;;</span><br><span class="line">temp += 10;</span><br><span class="line">&#125; else &#123;</span><br><span class="line">break;</span><br><span class="line">&#125;</span><br><span class="line">value &lt;&lt;= 4;</span><br><span class="line">value |= temp;</span><br><span class="line">&#125;</span><br><span class="line">p ++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">mac[i] = value;</span><br><span class="line"></span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void echo_arp_pkt(struct arppkt *arp, struct arppkt *arp_rt, char *hmac) &#123;</span><br><span class="line"></span><br><span class="line">memcpy(arp_rt, arp, sizeof(struct arppkt));</span><br><span class="line"></span><br><span class="line">memcpy(arp_rt-&gt;eh.h_dest, arp-&gt;eh.h_source, ETH_ALEN);</span><br><span class="line">str2mac(arp_rt-&gt;eh.h_source, hmac);</span><br><span class="line">arp_rt-&gt;eh.h_proto = arp-&gt;eh.h_proto;</span><br><span class="line"></span><br><span class="line">arp_rt-&gt;arp.h_addrlen = 6;</span><br><span class="line">arp_rt-&gt;arp.protolen = 4;</span><br><span class="line">arp_rt-&gt;arp.oper = htons(2);</span><br><span class="line"></span><br><span class="line">str2mac(arp_rt-&gt;arp.smac, hmac);</span><br><span class="line">arp_rt-&gt;arp.sip = arp-&gt;arp.dip;</span><br><span class="line"></span><br><span class="line">memcpy(arp_rt-&gt;arp.dmac, arp-&gt;arp.smac, ETH_ALEN);</span><br><span class="line">arp_rt-&gt;arp.dip = arp-&gt;arp.sip;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">void echo_udp_pkt(struct udppkt *udp, struct udppkt *udp_rt) &#123;</span><br><span class="line"></span><br><span class="line">memcpy(udp_rt, udp, sizeof(struct udppkt));</span><br><span class="line"></span><br><span class="line">memcpy(udp_rt-&gt;eh.h_dest, udp-&gt;eh.h_source, ETH_ALEN);</span><br><span class="line">memcpy(udp_rt-&gt;eh.h_source, udp-&gt;eh.h_dest, ETH_ALEN);</span><br><span class="line"></span><br><span class="line">udp_rt-&gt;ip.saddr = udp-&gt;ip.daddr;</span><br><span class="line">udp_rt-&gt;ip.daddr = udp-&gt;ip.saddr;</span><br><span class="line"></span><br><span class="line">udp_rt-&gt;udp.source = udp-&gt;udp.dest;</span><br><span class="line">udp_rt-&gt;udp.dest = udp-&gt;udp.source;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">unsigned short in_cksum(unsigned short *addr, int len)</span><br><span class="line">&#123;</span><br><span class="line">register int nleft = len;</span><br><span class="line">register unsigned short *w = addr;</span><br><span class="line">register int sum = 0;</span><br><span class="line">unsigned short answer = 0;</span><br><span class="line"></span><br><span class="line">while (nleft &gt; 1)  &#123;</span><br><span class="line">sum += *w++;</span><br><span class="line">nleft -= 2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">if (nleft == 1) &#123;</span><br><span class="line">*(u_char *)(&amp;answer) = *(u_char *)w ;</span><br><span class="line">sum += answer;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">sum = (sum &gt;&gt; 16) + (sum &amp; 0xffff);</span><br><span class="line">sum += (sum &gt;&gt; 16);</span><br><span class="line">answer = ~sum;</span><br><span class="line"></span><br><span class="line">return (answer);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">void echo_icmp_pkt(struct icmppkt *icmp, struct icmppkt *icmp_rt) &#123;</span><br><span class="line"></span><br><span class="line">memcpy(icmp_rt, icmp, sizeof(struct icmppkt));</span><br><span class="line"></span><br><span class="line">icmp_rt-&gt;icmp.type = 0x0; //</span><br><span class="line">icmp_rt-&gt;icmp.code = 0x0; //</span><br><span class="line">icmp_rt-&gt;icmp.check = 0x0;</span><br><span class="line"></span><br><span class="line">icmp_rt-&gt;ip.saddr = icmp-&gt;ip.daddr;</span><br><span class="line">icmp_rt-&gt;ip.daddr = icmp-&gt;ip.saddr;</span><br><span class="line"></span><br><span class="line">memcpy(icmp_rt-&gt;eh.h_dest, icmp-&gt;eh.h_source, ETH_ALEN);</span><br><span class="line">memcpy(icmp_rt-&gt;eh.h_source, icmp-&gt;eh.h_dest, ETH_ALEN);</span><br><span class="line"></span><br><span class="line">icmp_rt-&gt;icmp.check = in_cksum((unsigned short*)&amp;icmp_rt-&gt;icmp, sizeof(struct icmphdr));</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line"></span><br><span class="line">struct ethhdr *eh;</span><br><span class="line">struct pollfd pfd = &#123;0&#125;;</span><br><span class="line">struct nm_pkthdr h;</span><br><span class="line">unsigned char *stream = NULL;</span><br><span class="line"></span><br><span class="line">struct nm_desc *nmr = nm_open(&quot;netmap:eth0&quot;, NULL, 0, NULL);// netmap 使用eth0网卡</span><br><span class="line">if (nmr == NULL) &#123;</span><br><span class="line">return -1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">pfd.fd = nmr-&gt;fd;</span><br><span class="line">pfd.events = POLLIN;</span><br><span class="line"></span><br><span class="line">while (1) &#123;</span><br><span class="line">int ret = poll(&amp;pfd, 1, -1);</span><br><span class="line">if (ret &lt; 0) continue;</span><br><span class="line"></span><br><span class="line">if (pfd.revents &amp; POLLIN) &#123;// 这里使用poll 是因为只有一个fd，poll足够处理了，比epoll简单</span><br><span class="line">stream = nm_nextpkt(nmr, &amp;h);//每次从eth0取数据的方式通过nm_nextpkt读数据流</span><br><span class="line">eh = (struct ethhdr*)stream;</span><br><span class="line"></span><br><span class="line">if (ntohs(eh-&gt;h_proto) == PROTO_IP) &#123;// 判断是不是PROTP_IP</span><br><span class="line"></span><br><span class="line">struct udppkt *udp = (struct udppkt*)stream;</span><br><span class="line">if (udp-&gt;ip.protocol == PROTO_UDP) &#123;// 一层一层继续判断</span><br><span class="line"></span><br><span class="line">struct in_addr addr;</span><br><span class="line">addr.s_addr = udp-&gt;ip.saddr;</span><br><span class="line"></span><br><span class="line">int udp_length = ntohs(udp-&gt;udp.len);</span><br><span class="line">printf(&quot;%s:%d:length:%d, ip_len:%d --&gt; &quot;, inet_ntoa(addr), udp-&gt;udp.source, </span><br><span class="line">udp_length, ntohs(udp-&gt;ip.tot_len));</span><br><span class="line"></span><br><span class="line">udp-&gt;body[udp_length-8] = &apos;\0&apos;;</span><br><span class="line">printf(&quot;udp --&gt; %s\n&quot;, udp-&gt;body);</span><br><span class="line">#if 1</span><br><span class="line">struct udppkt udp_rt;</span><br><span class="line">echo_udp_pkt(udp, &amp;udp_rt);</span><br><span class="line">nm_inject(nmr, &amp;udp_rt, sizeof(struct udppkt));</span><br><span class="line">#endif</span><br><span class="line">&#125; else if (udp-&gt;ip.protocol == PROTO_ICMP) &#123;</span><br><span class="line"></span><br><span class="line">struct icmppkt *icmp = (struct icmppkt*)stream;</span><br><span class="line"></span><br><span class="line">printf(&quot;icmp ---------- --&gt; %d, %x\n&quot;, icmp-&gt;icmp.type, icmp-&gt;icmp.check);</span><br><span class="line">if (icmp-&gt;icmp.type == 0x08) &#123;</span><br><span class="line">struct icmppkt icmp_rt = &#123;0&#125;;</span><br><span class="line">echo_icmp_pkt(icmp, &amp;icmp_rt);</span><br><span class="line"></span><br><span class="line">//printf(&quot;icmp check %x\n&quot;, icmp_rt.icmp.check);</span><br><span class="line">nm_inject(nmr, &amp;icmp_rt, sizeof(struct icmppkt));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125; else if (udp-&gt;ip.protocol == PROTO_IGMP) &#123;</span><br><span class="line"></span><br><span class="line">&#125; else &#123;</span><br><span class="line">printf(&quot;other ip packet&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;  else if (ntohs(eh-&gt;h_proto) == PROTO_ARP) &#123;</span><br><span class="line"></span><br><span class="line">struct arppkt *arp = (struct arppkt *)stream;</span><br><span class="line">struct arppkt arp_rt;</span><br><span class="line"></span><br><span class="line">if (arp-&gt;arp.dip == inet_addr(&quot;192.168.2.217&quot;)) &#123;</span><br><span class="line">echo_arp_pkt(arp, &amp;arp_rt, &quot;00:50:56:33:1c:ca&quot;);</span><br><span class="line">nm_inject(nmr, &amp;arp_rt, sizeof(struct arppkt));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>为什么用代码发送消息，一会儿过后无效？</strong></p><p>arp协议有IP地址映射，用PING命令时，ICMP更新了arp表，一旦arp更新了IP地址，上诉代码就无效了</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;C10M问题&quot;&gt;&lt;a href=&quot;#C10M问题&quot; class=&quot;headerlink&quot; title=&quot;C10M问题&quot;&gt;&lt;/a&gt;C10M问题&lt;/h2&gt;&lt;h3 id=&quot;C10K&quot;&gt;&lt;a href=&quot;#C10K&quot; class=&quot;headerlink&quot; title=&quot;C
      
    
    </summary>
    
      <category term="中间件" scheme="http://twh233.github.io/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6/"/>
    
    
      <category term="中间件" scheme="http://twh233.github.io/tags/%E4%B8%AD%E9%97%B4%E4%BB%B6/"/>
    
  </entry>
  
  <entry>
    <title>mysql集群与性能优化</title>
    <link href="http://twh233.github.io/2020/12/28/Mysql%E9%9B%86%E7%BE%A4%E4%B8%8E%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    <id>http://twh233.github.io/2020/12/28/Mysql集群与性能优化/</id>
    <published>2020-12-28T11:50:00.000Z</published>
    <updated>2021-05-02T02:56:43.647Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Mysql与Redis数据同步"><a href="#Mysql与Redis数据同步" class="headerlink" title="Mysql与Redis数据同步"></a>Mysql与Redis数据同步</h2><p>1.func() {<br>    write to mysql;<br>    write to redis;<br>}<br>2.mysql 触发器 调用存储redis，只能处理小数据<br>3.主从同步  mysql binlog -&gt; redis  (Canal)</p><img src="/2020/12/28/Mysql集群与性能优化/2.png"><p>parser -&gt; slave<br>slave -&gt; redis client<br>store -&gt; 避免数据丢失</p><h2 id="MySQL-Replication"><a href="#MySQL-Replication" class="headerlink" title="MySQL Replication"></a>MySQL Replication</h2><p>主从复制是通过重放 binlog 实现主库数据的<br>异步复制。即当主库执行了一条 sql 命令，那么在从库同样的执行一遍，从而达到主从复制的效果。在这个过程中，master 对数据的写操作记入二进制日志文件中(binlog)，生成一个 log dump 线程，用来给从库的 i/o 线程传 binlog。而从库的 i/o 线程去请求主库的binlog，并将得到的 binlog 日志写到中继日志（relaylog）中，从库的 sql 线程，会读<br>取 relaylog 文件中的日志，并解析成具体操作，通过主从的操作一致，而达到最终数据一致。</p><p>其优势为：</p><ol><li>主从复制是 mysql 自带的，无需借助第三方。  </li><li>数据被删除，可以从 binlog 日志中恢复。  </li><li>配置较为简单方便。<br>其劣势为：</li><li>从库要从 binlog 获取数据并重放，这肯定与主库写入数据存在时间延迟，因此从库的数据总是要滞后主库。  </li><li>对主库与从库之间的网络延迟要求较高，若网络延迟太高，将加重上述的滞后，造成最终数据的不一致。  </li><li>单一的主节点挂了，将不能对外提供写服务。  </li></ol><h2 id="MySQL-Fabirc"><a href="#MySQL-Fabirc" class="headerlink" title="MySQL Fabirc"></a>MySQL Fabirc</h2><p>这是在 MySQL Replication 的基础上，增加了故障检测<br>与转移，自动数据分片功能。不过依旧是一主多从的结构，MySQL Fabirc 只有一个主节点，<br>区别是当该主节点挂了以后，会从从节点中选择一个来当主节点。</p><p>相比Replication，主节点挂了会重新拉一个从节点做主节点。<br>节点故障恢复 30 秒或更长（采用 InnoDB 存储引擎的都这样）。</p><h2 id="MySQL-Cluster"><a href="#MySQL-Cluster" class="headerlink" title="MySQL Cluster"></a>MySQL Cluster</h2><p>MySQL Cluster 是多主多从结构的<br>就各个集群方案来说，其优势为：</p><ol><li>mysql 官方提供的工具，无需第三方插件。  </li><li>高可用性优秀，99.999%的可用性，可以自动切分数据，能跨节点冗余数据（其数据集并不是存储某个特定的 MySQL 实例上，而是被分布在多个 Data Nodes 中，即一个 table 的数据可能被分散在多个物理节点上，任何数据都会在多个 Data Nodes 上冗余备份。任何一个数据变更操作，都将在一组 Data Nodes 上同步，以保证数据的一致性）。  </li><li>可伸缩性优秀，能自动切分数据，方便数据库的水平拓展。  </li><li>负载均衡优秀，可同时用于读操作、写操作都都密集的应用，也可以使用 SQL 和 NOSQL接口访问数据。  </li><li>多个主节点，没有单点故障的问题，节点故障恢复通常小于 1 秒。<br>其劣势为：</li><li>架构模式和原理很复杂。  </li><li>只能使用存储引擎 NDB ，与平常使用的 InnoDB 有很多明显的差距。比如在事务（其事务隔离级别只支持 Read Committed，即一个事务在提交前，查询不到在事务内所做的修改），外键（虽然最新的 NDB 存储引擎已经支持外键，但性能有问题，因为外键所关联的记录可能在别的分片节点），表限制上的不同，可能会导致日常开发出现意外。  </li><li>作为分布式的数据库系统，各个节点之间存在大量的数据通讯，比如所有访问都是需要经过超过一个节点（至少有一个 SQL Node 和一个 NDB Node）才能完成，因此对节点之间的内部互联网络带宽要求高。  </li><li>Data Node 数据会被尽量放在内存中，对内存要求大，而且重启的时候，数据节点将数据 load 到内存需要很长时间。  </li></ol><h2 id="MMM"><a href="#MMM" class="headerlink" title="MMM"></a>MMM</h2><p>双主多从结构，MMM 是在 MySQL Replication的基础上，对其进行优化。</p><img src="/2020/12/28/Mysql集群与性能优化/1.png"><p>这里的双主节点，虽然叫做双主复制，但是业务上同一时刻只允许对一个主进行写入，<br>另一台备选主上提供部分读服务，以加速在主主切换时刻备选主的预热。<br>就各个集群方案来说，其优势为：</p><ol><li>自动的主主 Failover 切换，一般 3s 以内切换备机。  </li><li>多个从节点读的负载均衡。<br>其劣势为：</li><li>无法完全保证数据的一致性。如主 1 挂了，MMM monitor 已经切换到主 2 上来了，而若此时双主复制中，主 2 数据落后于主 1（即还未完全复制完毕），那么此时的主 2 已经成为主节点，对外提供写服务，从而导致数据不一。  </li><li>由于是使用虚拟 IP 浮动技术，类似 Keepalived，故 RIP（真实 IP）要和 VIP（虚拟 IP）在同一网段。如果是在不同网段也可以，需要用到虚拟路由技术。但是绝对要在同一个 IDC机房，不可跨 IDC 机房组建集群。</li></ol><h2 id="Galera-Cluster"><a href="#Galera-Cluster" class="headerlink" title="Galera Cluster"></a>Galera Cluster</h2><p>Galera Cluster 是由 Codership 开发的 MySQL 多主结构集群，这些主节点互为其它节点的从节点。不同于 MySQL 原生的主从异步复制，Galera 采用的是多主同步复制，并针对同步复制过程中，会大概率出现的事务冲突和死锁进行优化，就是复制不基于官方 binlog 而是 Galera<br>复制插件，重写了 wsrep api。异步复制中，主库将数据更新传播给从库后立即提交事务，而不论从库是否成功读取或重放数据变化。这种情况下，在主库事务提交后短时间内，主从库数据并不一致。同步复制时，主库的单个更新事务需要在所有从库上同步 更新。换句话说，当主库提交事务时，集群中所有节点的数据保持一致。<br>对于读操作，从每个节点读取到的数据都是相同的。对于写操作，当数据写入某一节点后，集群会将其同步到其它节点。</p><p>能做到数据的强一致性，毫无疑问，也是以牺牲性能为代价。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Mysql与Redis数据同步&quot;&gt;&lt;a href=&quot;#Mysql与Redis数据同步&quot; class=&quot;headerlink&quot; title=&quot;Mysql与Redis数据同步&quot;&gt;&lt;/a&gt;Mysql与Redis数据同步&lt;/h2&gt;&lt;p&gt;1.func() {&lt;br&gt;    
      
    
    </summary>
    
      <category term="基础" scheme="http://twh233.github.io/categories/%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="mysql" scheme="http://twh233.github.io/tags/mysql/"/>
    
      <category term="分布式" scheme="http://twh233.github.io/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>Kafaka与Zookeeper</title>
    <link href="http://twh233.github.io/2020/12/03/Kafaka%E4%B8%8EZookeeper/"/>
    <id>http://twh233.github.io/2020/12/03/Kafaka与Zookeeper/</id>
    <published>2020-12-03T15:11:34.000Z</published>
    <updated>2020-12-03T15:13:20.471Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Kafaka-总体架构"><a href="#Kafaka-总体架构" class="headerlink" title="Kafaka 总体架构"></a>Kafaka 总体架构</h2><img src="/2020/12/03/Kafaka与Zookeeper/1.png"><img src="/2020/12/03/Kafaka与Zookeeper/2.png"><p>Producer： 生产者，即消息发送者，Push 消息到 Kafka 集群的 Broker（就是 Server）中；<br>Broker： Kafka 集群由多个 Kafka 实例（Server）组成，每个实例构成一个 Broker，其实就是服务器；<br>Topic： Producer 向 Kafka 集群 Push 的消息会被归于某一类别，即 Topic。本质上，这只是一个逻辑概念，面向的对象是 Producer 和 Consumer，Producer 只需关注将消息 Push 到哪一个 Topic 中，而 Consumer 只需关心自己订阅了哪个 Topic；<br>Partition： 每个 Topic 又被分为多个 Partition，即物理分区。出于负载均衡的考虑，同一个 Topic 的 Partition 分别存储于 Kafka 集群的多个 Broker 上。而为了提高可靠性，这些 Partition 可以由 Kafka 机制中的 Replicas 来设置备份的数量。如上面框架图所示，每个 Partition 都存在两个备份；<br>Consumer： 消费者，从 Kafka 集群的 Broker 中 Pull 消息、消费消息；<br>Consumer Group： High-Level Consumer API 中，每个 Consumer 都属于一个 Consumer Group，每条消息只能被 Consumer Group 中的一个 Consumer 消费，但可以被多个 Consumer Group 消费；<br>Replicas： Partition 的副本，保障 Partition 的高可用；<br>Leader： Replicas 中的一个角色， Producer 和 Consumer 只与 Leader 交互；<br>Follower： Replicas 中的一个角色，从 Leader 中复制数据，作为它的副本，同时一旦某 Leader 挂掉，便会从它的所有 Follower 中选举出一个新的 Leader 继续提供服务；<br>Controller： Kafka 集群中的一个服务器，用来进行 Leader Election 以及各种 Fail Over；<br>Zookeeper： Kafka 通过 ZooKeeper 存储集群的 Meta 信息等，文中将详述。  </p><h2 id="Kafka-为什么要将-Topic-分区？"><a href="#Kafka-为什么要将-Topic-分区？" class="headerlink" title="Kafka 为什么要将 Topic 分区？"></a>Kafka 为什么要将 Topic 分区？</h2><p>Topic 只是逻辑概念，面向的是 Producer 和 Consumer，而 Partition 则是物理概念。可以想象，如果 Topic 不进行分区，而将 Topic 内的消息存储于一个 Broker，那么该 Topic 的所有读写请求都将由这个 Broker 处理，吞吐量很容易陷入瓶颈，这显然不适合高吞吐量应用场景。</p><p>有了 Partition 概念，假设一个 Topic 被分为 10 个 Partition，Kafka 会根据一定的算法将 10 个 Partition 尽可能均匀地分布到不同的 Broker（服务器）上。</p><h2 id="Kafka-文件存储机制"><a href="#Kafka-文件存储机制" class="headerlink" title="Kafka 文件存储机制"></a>Kafka 文件存储机制</h2><p>Partition 并不是最终的存储粒度，Partition 还可以进一步细分为 Segment。</p><h2 id="为什么不能以-Partition-作为存储单位？"><a href="#为什么不能以-Partition-作为存储单位？" class="headerlink" title="为什么不能以 Partition 作为存储单位？"></a>为什么不能以 Partition 作为存储单位？</h2><p>任何一个 Topic 中的 Partition 数量受限于 Kafka Broker 的数量。为了保证可靠性，每个 Partition 都应有若干个副本（Replica），其中一个 Replica 为 Leader，其它都为 Follower。Leader 负责处理 Partition 的所有读写请求，Follower 则负责被动地复制 Leader 上的数据。<br>基于 Segment 机制，可以很方便地清理那些陈旧的消息（已被消费的消息），从而提高磁盘的利用率。</p><h2 id="Segment-的工作原理是什么？"><a href="#Segment-的工作原理是什么？" class="headerlink" title="Segment 的工作原理是什么？"></a>Segment 的工作原理是什么？</h2><p>Partition 全局的第一个 Segment 从 0 开始，后续每个 Segment 文件名为上一个 Segment 文件最后一条消息的偏移量（Offset）值</p><img src="/2020/12/03/Kafaka与Zookeeper/3.png"><h2 id="复制原理和同步方式"><a href="#复制原理和同步方式" class="headerlink" title="复制原理和同步方式"></a>复制原理和同步方式</h2><p>Leader 副本：响应 Client 端读写请求的副本，Producer 和 Consumer 只跟 Leader 交互；<br>Follower 副本：被动地备份 Leader 副本中的数据，不能响应 Client 端读写请求。一旦 Leader 挂掉，会从它的 Follower 中选举出一个新的 Leader 继续提供服务；<br>ISR 副本：包含了 Leader 副本和所有与 Leader 副本保持同步的 Follower 副本。如何判定是否与 Leader 同步，后面详述。  </p><p>Leader 将负责维护和跟踪一个 ISR（In-Sync Replicas）列表，即同步副本队列，这个列表里面的副本与 Leader 保持同步，状态一致。</p><h3 id="ISR"><a href="#ISR" class="headerlink" title="ISR"></a>ISR</h3><p>Follower 从 Leader 那里同步数据会有一些延迟（由参数 replica.lag.time.max.ms 设置超时阈值），超过阈值的 Follower 将被剔除出 ISR， 存入 OSR（Outof-Sync Replicas）列表，新加入的 Follower 也会先存放在 OSR 中，即有关系式 AR=ISR+OSR  </p><h3 id="LEO-amp-HW"><a href="#LEO-amp-HW" class="headerlink" title="LEO &amp; HW"></a>LEO &amp; HW</h3><p>LEO=10、HW=7，则表示该副本保存了 10 条消息，而后面 3 条处于 Uncommitted 状态。</p><p>每个 Replica （包含 Leader 和 Follower）都有 HW，它们各自负责更新自己的 HW 的状态。</p><img src="/2020/12/03/Kafaka与Zookeeper/4.png"><h2 id="可靠性"><a href="#可靠性" class="headerlink" title="可靠性"></a>可靠性</h2><p>在客户端，可以通过 request.required.acks 参数来设置数据可靠性的级别<br>（1）request.required.acks = 1 Producer 发送数据到 Leader，只要 Leader 成功写入本地日志，即成功返回客户端，不要求 ISR 中的其它副本与 Leader 保持同步<br>（2）request.required.acks = 0 Producer 不停向 Leader 发送数据，而不需要 Leader 反馈成功消息<br>（3）request.required.acks = -1（all） 消息的强制备份数量为 ISR 列表中副本的数量，Leader收到消息后才向生产者返回成功</p><p>Kafka 提供了这样一个参数：min.insync.replicas，该参数用于设定 ISR 中的最小副本数，默认值为 1，当且仅当 request.required.acks 参数设置为 -1 时，此参数才生效。</p><h3 id="参数-batch-size"><a href="#参数-batch-size" class="headerlink" title="参数 batch.size"></a>参数 batch.size</h3><p>当多条消息的目标 Partition 相同时，Producer 会尝试将它们组装成一个批量消息，以便减少请求的数量，有助于提升客户端和服务器的性能。批量消息的大小由参数 batch.size 控制。</p><h3 id="参数-linger-ms"><a href="#参数-linger-ms" class="headerlink" title="参数 linger.ms"></a>参数 linger.ms</h3><p>如果消息到达的速度比后台线程发送到 Partition 的速度快，则会出现消息堆积的问题。不过，在某些情况下，客户端可能通过添加人工延迟来减少请求数量。</p><h3 id="参数-buffer-memory-和-max-block-ms"><a href="#参数-buffer-memory-和-max-block-ms" class="headerlink" title="参数 buffer.memory 和 max.block.ms"></a>参数 buffer.memory 和 max.block.ms</h3><p>Producer 可以用来缓冲等待发送给服务器的消息的总字节数。如果消息的发送速度快于传送到服务器的速度，那么缓冲区将被占满，之后 Producer 将阻塞 max.block.ms，随后将抛出异常。buffer.memory 的大小大致与 Producer 可使用的总内存相对应</p><p>在 buffer.memory 指定的缓存被占满后，Producer 相关的方法可阻塞的最大时间由 max.block.ms 控制，之后将抛出异常。</p><h3 id="参数-retries"><a href="#参数-retries" class="headerlink" title="参数 retries"></a>参数 retries</h3><p>发送消息具有“重试机制”，由参数 retries 控制</p><h3 id="避免消息重排序"><a href="#避免消息重排序" class="headerlink" title="避免消息重排序"></a>避免消息重排序</h3><p>先T1、T2，T1失败，T2成功，T1重试</p><p>max.in.flight.requests.per.connection，通过它，客户端可以设置在单个连接上发送的未确认请求的最大数目。如果设置大于 1，并且发送失败，则存在由于重试（如果启用了重试机制）而导致消息重新排序的风险。</p><h3 id="消息接收的可靠性"><a href="#消息接收的可靠性" class="headerlink" title="消息接收的可靠性"></a>消息接收的可靠性</h3><p>为了保证消息接收的可靠性，通常将参数 enable.auto.commit 设置为 False，防止程序自动提交。</p><h3 id="消息存储的可靠性"><a href="#消息存储的可靠性" class="headerlink" title="消息存储的可靠性"></a>消息存储的可靠性</h3><p>Kafka 通过持久化消息到磁盘来保障消息存储的可靠性，但存在矛盾点：由于磁盘的 IO 瓶颈，过于频繁的“刷盘”会降低 Kafka 的性能。但是，“刷盘” 的时间间隔过长又存在消息丢失的风险，降低可靠性</p><p>log.flush.interval.ms 用于控制日志刷盘的时间间隔，即每隔多长时间将消息刷到磁盘上</p><p>log.flush.interval.messages 用于控制日志刷盘的消息量，即每积累多少条消息后将消息刷到磁盘上</p><h2 id="Kafka-选举-Leader-的策略是怎样的？"><a href="#Kafka-选举-Leader-的策略是怎样的？" class="headerlink" title="Kafka 选举 Leader 的策略是怎样的？"></a>Kafka 选举 Leader 的策略是怎样的？</h2><p>Kafka 通过 ZooKeeper 为每一个 Partition 动态维护了一个 ISR 列表。对于任意一条消息，只有它被 ISR 中的所有 Follower 都从 Leader 复制过去才会被认为 Committed，并返回信息给 Producer，从而保证可靠性。但与“少数服从多数”策略不同的是，Kafka ISR 列表中副本的数量不需要超过副本总数的一半，即不需要满足“多数派”原则，通常，ISR 列表副本数大于等于 2 即可，如此，便在可靠性和吞吐量方面取得平衡。</p><h2 id="Kafka-架构中-ZooKeeper-以怎样的形式存在？"><a href="#Kafka-架构中-ZooKeeper-以怎样的形式存在？" class="headerlink" title="Kafka 架构中 ZooKeeper 以怎样的形式存在？"></a>Kafka 架构中 ZooKeeper 以怎样的形式存在？</h2><p>在基于 Kafka 的分布式消息队列中，ZooKeeper 的作用有 Broker 注册、Topic 注册、Producer 和 Consumer 负载均衡、维护 Partition 与 Consumer 的关系、记录消息消费的进度以及 Consumer 注册等。</p><p>当 Producer Push 的消息写入 Partition（分区）时，作为 Leader 的 Broker（Kafka 节点）会将消息写入自己的分区，同时还会将此消息复制到各个 Follower，实现同步。如果某个 Follower 挂掉，Leader 会再找一个替代并同步消息；如果 Leader 挂了，Follower 们会选举出一个新的 Leader 替代，继续业务，这些都是由 ZooKeeper 完成的。</p><h3 id="Consumer-在-ZooKeeper-中的注册"><a href="#Consumer-在-ZooKeeper-中的注册" class="headerlink" title="Consumer 在 ZooKeeper 中的注册"></a>Consumer 在 ZooKeeper 中的注册</h3><p>在 ZooKeeper 中，/consumers/{group_id} 虽然被称为节点，但本质上是一个目录。</p><p>ids：Consumer Group 中有多个 Consumer，ids 用于记录这些 Consumer；<br>owners：记录该 Consumer Group 可消费的 Topic 信息；<br>offsets：记录 owners 中每个 Topic 的所有 Partition 的 Offset。  </p><h3 id="Producers-负载均衡"><a href="#Producers-负载均衡" class="headerlink" title="Producers 负载均衡"></a>Producers 负载均衡</h3><p>Producers 会通过 Watcher 机制监听 Brokers 注册节点的变化。一旦 Brokers 发生变化，如增加、减少，Producers 可以收到通知并更新自己记录的 Broker 列表 。此外，基于 ZooKeeper 提供的 Watcher 机制，还可以监听其它在 ZooKeeper 上注册的节点，如 Topic、Consumer 等。</p><h3 id="Consumer-负载均衡"><a href="#Consumer-负载均衡" class="headerlink" title="Consumer 负载均衡"></a>Consumer 负载均衡</h3><p>为 Consumer Group 中的各个 Consumer 分别指定不同的 Partition，只要保证该过程“相对公平”即可。</p><h3 id="借助-ZooKeeper-实现负载均衡"><a href="#借助-ZooKeeper-实现负载均衡" class="headerlink" title="借助 ZooKeeper 实现负载均衡"></a>借助 ZooKeeper 实现负载均衡</h3><ol><li>对任意一个 Topic 中所有的 Partirtion 进行排序，用数组 PT 记录；</li><li>某一 Consumer Group 订阅了上述 Topic，对它的所有 Consumer 排序，用数组 CG 记录，第 i 个 Consumer 记为 CG[i]；</li><li>比例系数为 F=size(PT)/size(CG)，向上取整；</li><li>解除 CG[i] 对原来分配的 Partition 的消费权（i 从 0 开始，最大值为 size(CG)-1）;</li><li>将第 i<em>F 到 (i+1)</em>F-1 个 Partition 分配给 CG[i]。</li></ol><h3 id="记录消费进度-Offset"><a href="#记录消费进度-Offset" class="headerlink" title="记录消费进度 Offset"></a>记录消费进度 Offset</h3><p>Offset 在 ZooKeeper 中，有一个专属的节点（目录）用于记录 Offset</p><p>节点内容就是Offset的值。<br>/consumers/[group_id]/offsets/[topic]/[broker_id-partition_id]</p><h2 id="全程解析"><a href="#全程解析" class="headerlink" title="全程解析"></a>全程解析</h2><h3 id="Producer-发布消息"><a href="#Producer-发布消息" class="headerlink" title="Producer 发布消息"></a>Producer 发布消息</h3><p>Producer 采用 Push 模式将消息发布到 Kafka Broker，根据负载均衡算法（如轮询、Hash 等），这些消息将均衡写入到相应 Topic 对应的各个 Partition 中。在存储层面，采用顺序写磁盘（即 Append）模式写入。</p><ol><li>Producer Push 消息，基于负载均衡算法获得目标 Partition 后，Producer 先从 ZooKeeper 的 /brokers/…/state 节点找到该Partition 的 Leader；</li><li>Producer 将消息发送给该 Leader；</li><li>Leader 将消息写入本地 Log；</li><li>所有 Follower 主动从 Leader Pull 消息，写入本地 Log 后向 Leader 发送 ACK；</li><li>Leader 收到所有 ISR 中所有 Replica 的 ACK 后，更新 HW（High Watermark，最后 Commit 的 Offset），并向 Producer 发送 ACK；</li><li>Producer 接到 ACK，确认发送成功。</li></ol><h3 id="Broker-存储消息"><a href="#Broker-存储消息" class="headerlink" title="Broker 存储消息"></a>Broker 存储消息</h3><p>Topic 是逻辑概念，而 Topic 对应的 Partition 则是物理概念，每个 Partition 在存储层面都对应一个文件夹（目录）。由于 Partition 并不是最终的存储粒度，该文件夹下还有多个 Segment（消息索引和数据文件，它们是真正的存储文件）。</p><h3 id="Consumer-消费消息"><a href="#Consumer-消费消息" class="headerlink" title="Consumer 消费消息"></a>Consumer 消费消息</h3><p>目前采用的高级 API，Consumer 在消费消息时，只需指定 Topic 即可，API 内部实现负载均衡，并将 Offset 记录到 ZooKeeper 上。<br>Consumer 采用 Pull 模式从 Broker 中读取数据，这是一种异步消费模式，与 Producer 采用的 Push 模式全然不同。Push 模式追求速度，越快越好，当然它取决于 Broker 的性能，而 Pull 模式则是追求自适应能力，Consumer 根据自己的消费能力消费。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Kafaka-总体架构&quot;&gt;&lt;a href=&quot;#Kafaka-总体架构&quot; class=&quot;headerlink&quot; title=&quot;Kafaka 总体架构&quot;&gt;&lt;/a&gt;Kafaka 总体架构&lt;/h2&gt;&lt;img src=&quot;/2020/12/03/Kafaka与Zookeepe
      
    
    </summary>
    
      <category term="基础" scheme="http://twh233.github.io/categories/%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="分布式" scheme="http://twh233.github.io/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
      <category term="Kafaka" scheme="http://twh233.github.io/tags/Kafaka/"/>
    
  </entry>
  
  <entry>
    <title>分布式一致性算法Raft和Etcd</title>
    <link href="http://twh233.github.io/2020/11/30/%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%80%E8%87%B4%E6%80%A7%E7%AE%97%E6%B3%95Raft%E5%92%8CEtcd/"/>
    <id>http://twh233.github.io/2020/11/30/分布式一致性算法Raft和Etcd/</id>
    <published>2020-11-30T15:19:34.000Z</published>
    <updated>2020-11-30T15:47:14.568Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Raft"><a href="#Raft" class="headerlink" title="Raft"></a>Raft</h1><h2 id="Raft角色"><a href="#Raft角色" class="headerlink" title="Raft角色"></a>Raft角色</h2><p>Leader（领导者）：负责日志的同步管理，处理来自客户端的请求，与Follower保持heartBeat的联系；<br>Follower（追随者）：响应 Leader 的日志同步请求，响应Candidate的邀票请求，以及把客户端请求到Follower的事务转发（重定向）给Leader；<br>Candidate（候选者）：负责选举投票，集群刚启动或者Leader宕机时，状态为Follower的节点将转为Candidate并发起选举，选举胜出（获得超过半数节点的投票）后，从Candidate转为Leader状态。  </p><h2 id="Raft-三个子问题"><a href="#Raft-三个子问题" class="headerlink" title="Raft 三个子问题"></a>Raft 三个子问题</h2><p>选举（Leader Election）：当 Leader 宕机或者集群初创时，一个新的 Leader 需要被选举出来；<br>日志复制（Log Replication）：Leader 接收来自客户端的请求并将其以日志条目的形式复制到集群中的其它节点，并且强制要求其它节点的日志和自己保持一致；<br>安全性（Safety）：如果有任何的服务器节点已经应用了一个确定的日志条目到它的状态机中，那么其它服务器节点不能在同一个日志索引位置应用一个不同的指令。  </p><h2 id="Raft-算法之-Leader-Election-原理"><a href="#Raft-算法之-Leader-Election-原理" class="headerlink" title="Raft 算法之 Leader Election 原理"></a>Raft 算法之 Leader Election 原理</h2><p>第一阶段：所有节点都是 Follower。<br>第二阶段：Follower 转为 Candidate 并发起投票。<br>第三阶段：投票策略。  </p><p>节点收到投票请求后会根据以下情况决定是否接受投票请求：</p><p>请求节点的 Term 大于自己的 Term，且自己尚未投票给其它节点，则接受请求，把票投给它；<br>请求节点的 Term 小于自己的 Term，且自己尚未投票，则拒绝请求，将票投给自己。</p><p>第四阶段：Candidate 转为 Leader。</p><h2 id="Raft-算法之-Log-Replication-原理"><a href="#Raft-算法之-Log-Replication-原理" class="headerlink" title="Raft 算法之 Log Replication 原理"></a>Raft 算法之 Log Replication 原理</h2><p>第一阶段：客户端请求提交到 Leader。</p><p>Follower 将会把请求重定向到 Leader。Leader 在收到请求后，会将它作为日志条目（Entry）写入本地日志中。需要注意的是，此时该 Entry 的状态是未提交（Uncommitted），Leader 并不会更新本地数据，因此它是不可读的。</p><p>第二阶段：Leader 将 Entry 发送到其它 Follower</p><p>在发送追加日志条目的时候，Leader 会把新的日志条目紧接着之前条目的索引位置（prevLogIndex）， Leader 任期号（Term）也包含在其中。如果 Follower 在它的日志中找不到包含相同索引位置和任期号的条目，那么它就会拒绝接收新的日志条目，因为出现这种情况说明 Follower 和 Leader 不一致。</p><p>要使 Follower 的日志与 Leader 恢复一致，Leader 必须找到最后两者达成一致的地方（说白了就是回溯，找到两者最近的一致点），然后删除从那个点之后的所有日志条目，发送自己的日志给 Follower。所有的这些操作都在进行附加日志的一致性检查时完成。</p><p>如果一个 Follower 的日志和 Leader 不一致，那么在下一次附加日志时一致性检查就会失败。在被 Follower 拒绝之后，Leader 就会减小该 Follower 对应的 nextIndex 值并进行重试。最终 nextIndex 会在某个位置使得 Leader 和 Follower 的日志达成一致。</p><p>第三阶段：Leader 等待 Followers 回应。</p><p>第四阶段：Leader 回应客户端。</p><p>第五阶段，Leader 通知 Followers Entry 已提交</p><p>Leader 回应客户端后，将随着下一个心跳通知 Followers，Followers 收到通知后也会将 Entry 标记为提交状态。至此，Raft 集群超过半数节点已经达到一致状态，可以确保强一致性。</p><h2 id="Raft-算法之安全性"><a href="#Raft-算法之安全性" class="headerlink" title="Raft 算法之安全性"></a>Raft 算法之安全性</h2><p>保证任何的 Leader 对于给定的任期号（Term），都拥有之前任期的所有被提交的日志条目</p><h3 id="选举限制"><a href="#选举限制" class="headerlink" title="选举限制"></a>选举限制</h3><p>日志条目的传送是单向的，只从 Leader 传给 Follower，并且 Leader 从不会覆盖自身本地日志中已经存在的条目。</p><p>比较新的可以赢得大多数投票。</p><h3 id="提交之前任期内的日志条目"><a href="#提交之前任期内的日志条目" class="headerlink" title="提交之前任期内的日志条目"></a>提交之前任期内的日志条目</h3><p>如果一个 Leader 在提交日志条目之前崩溃了，继任的 Leader 会继续尝试复制这条日志记录。但不能保证在Follower上的日志条目提交。</p><p>当 Leader 复制之前任期里的日志时，Raft 会为所有日志保留原始的任期号，这在提交规则上产生了额外的复杂性。但是，这种策略更加容易辨别出日志，即使随着时间和日志的变化，日志仍维护着同一个任期编号。此外，该策略使得新 Leader 只需要发送较少日志条目。</p><h1 id="Etcd"><a href="#Etcd" class="headerlink" title="Etcd"></a>Etcd</h1><p>Etcd 主要分为四个部分：HTTP Server、Store、Raft 以及 WAL。 </p><p>HTTP Server：用于处理客户端发送的 API 请求以及其它 Etcd 节点的同步与心跳信息请求。<br>Store：用于处理 Etcd 支持的各类功能的事务，包括数据索引、节点状态变更、监控与反馈、事件处理与执行等等，是 Etcd 对用户提供的大多数 API 功能的具体实现。<br>Raft：Raft 强一致性算法的具体实现，是 Etcd 的核心。<br>WAL：Write Ahead Log（预写式日志），是 Etcd 的数据存储方式。除了在内存中存有所有数据的状态以及节点的索引，Etcd 还通过 WAL 进行持久化存储。WAL 中，所有的数据提交前都会事先记录日志。Snapshot 是为了防止数据过多而进行的状态快照。Entry 表示存储的具体日志内容。  </p><p>一个用户的请求发送过来，会经由 HTTP Server 转发给 Store 进行具体的事务处理；如果涉及到节点的修改，则交给 Raft 模块进行状态的变更、日志的记录，然后再同步给别的 Etcd 节点以确认数据提交；最后进行数据的提交，再次同步。</p><p>Lease 机制：续约机制<br>Prefix 机制：即前缀机制，也称目录机制<br>Watch 机制：即监听机制，Watch 机制支持监听某个固定的 Key，也支持监听一个范围（前缀机制），当被监听的 Key 或范围发生变化，客户端将收到通知；<br>Revision 机制：每个 Key 带有一个 Revision 号，每进行一次事务便加一，因此它是全局唯一的</p><p>应用场景 1：服务发现<br>应用场景 2：消息发布和订阅<br>应用场景 3：分布式锁<br>Etcd 支持 Revision 机制，那么对于同一个 Lock，即便有多个客户端争夺（本质上就是 put(lockName, value) 操作），Revision 机制可以保证它们的 Revision 编号有序且唯一，那么，客户端只要根据 Revision 的大小顺序就可以确定获得锁的先后顺序，从而很容易实现“公平锁”。<br>应用场景4： 集群监控与 Leader 竞选</p><h2 id="基于-Etcd-的分布式锁业务流程"><a href="#基于-Etcd-的分布式锁业务流程" class="headerlink" title="基于 Etcd 的分布式锁业务流程"></a>基于 Etcd 的分布式锁业务流程</h2><h3 id="步骤1：准备"><a href="#步骤1：准备" class="headerlink" title="步骤1：准备"></a>步骤1：准备</h3><p>客户端连接 Etcd，以 /lock/mylock 为前缀创建全局唯一的 Key，假设第一个客户端对应的 Key=”/lock/mylock/UUID1”，第二个为 Key=”/lock/mylock/UUID2”；客户端分别为自己的 Key 创建租约 Lease，租约的长度根据业务耗时确定，假设为 15s。</p><h3 id="步骤2：创建定时任务作为租约的“心跳”"><a href="#步骤2：创建定时任务作为租约的“心跳”" class="headerlink" title="步骤2：创建定时任务作为租约的“心跳”"></a>步骤2：创建定时任务作为租约的“心跳”</h3><p>在一个客户端持有锁期间，其它客户端只能等待，为了避免等待期间租约失效，客户端需创建一个定时任务作为“心跳”进行续约。此外，如果持有锁期间客户端崩溃，心跳停止，Key 将因租约到期而被删除，从而锁释放，避免死锁。</p><h3 id="步骤3：客户端将自己全局唯一的-Key-写入-Etcd"><a href="#步骤3：客户端将自己全局唯一的-Key-写入-Etcd" class="headerlink" title="步骤3：客户端将自己全局唯一的 Key 写入 Etcd"></a>步骤3：客户端将自己全局唯一的 Key 写入 Etcd</h3><p>进行 Put 操作，将步骤 1 中创建的 Key 绑定租约写入 Etcd，根据 Etcd 的 Revision 机制，假设两个客户端 Put 操作返回的 Revision 分别为1、2，客户端需记录 Revision 用以接下来判断自己是否获得锁。</p><h3 id="步骤4：客户端判断是否获得锁"><a href="#步骤4：客户端判断是否获得锁" class="headerlink" title="步骤4：客户端判断是否获得锁"></a>步骤4：客户端判断是否获得锁</h3><p>客户端以前缀 /lock/mylock 读取 Key-Value 列表（Key-Value 中带有 Key 对应的 Revision），判断自己 Key 的 Revision 是否为当前列表中最小的，如果是则认为获得锁；否则监听列表中前一个 Revision 比自己小的 Key 的删除事件，一旦监听到删除事件或者因租约失效而删除的事件，则自己获得锁。 </p><h3 id="步骤5：执行业务"><a href="#步骤5：执行业务" class="headerlink" title="步骤5：执行业务"></a>步骤5：执行业务</h3><p>获得锁后，操作共享资源，执行业务代码。 </p><h3 id="步骤6：释放锁"><a href="#步骤6：释放锁" class="headerlink" title="步骤6：释放锁"></a>步骤6：释放锁</h3><p>完成业务流程后，删除对应的 Key 释放锁。</p><img src="/2020/11/30/分布式一致性算法Raft和Etcd/1.png">]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Raft&quot;&gt;&lt;a href=&quot;#Raft&quot; class=&quot;headerlink&quot; title=&quot;Raft&quot;&gt;&lt;/a&gt;Raft&lt;/h1&gt;&lt;h2 id=&quot;Raft角色&quot;&gt;&lt;a href=&quot;#Raft角色&quot; class=&quot;headerlink&quot; title=&quot;Raft角
      
    
    </summary>
    
      <category term="基础" scheme="http://twh233.github.io/categories/%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="分布式" scheme="http://twh233.github.io/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>Redis分布式</title>
    <link href="http://twh233.github.io/2020/11/25/Redis%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    <id>http://twh233.github.io/2020/11/25/Redis分布式/</id>
    <published>2020-11-25T13:43:01.000Z</published>
    <updated>2021-05-18T07:27:23.659Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Redis-Cluster特点"><a href="#Redis-Cluster特点" class="headerlink" title="Redis Cluster特点"></a>Redis Cluster特点</h2><p>节点互通：所有的 Redis 节点彼此互联（PING-PONG机制），内部使用二进制协议优化传输速度和带宽；  </p><p>去中心化：Redis Cluster 不存在中心节点，每个节点都记录有集群的状态信息，并且通过 Gossip 协议，使每个节点记录的信息实现最终一致性；</p><p>客户端直连：客户端与 Redis 节点直连，不需要中间 Proxy 层，客户端不需要连接集群所有节点，连接集群中任何一个可用节点即可；</p><p>数据分片：Redis Cluster 的键空间被分割为 16384 个 Slot，这些 Slot 被分别指派给主节点，当存储 Key-Value 时，根据 CRC16(key) Mod 16384的值，决定将一个 Key-Value 放到哪个 Slot 中；</p><p>多数派原则：对于集群中的任何一个节点，需要超过半数的节点检测到它失效（pFail），才会将其判定为失效（Fail）；</p><p>自动 Failover：当集群中某个主节点故障后（Fail），其它主节点会从故障主节点的从节点中选举一个“最佳”从节点升主，替代故障的主节点；</p><p>功能弱化：集群模式下，由于数据分布在多个节点，不支持单机模式下的集合操作，也不支持多数据库功能，集群只能使用默认的0号数据库；</p><p>集群规模：官方推荐的最大节点数量为 1000 个左右，这是因为当集群规模过大时，Gossip 协议的效率会显著下降，通信成本剧增。</p><h2 id="Redis-Cluster路由"><a href="#Redis-Cluster路由" class="headerlink" title="Redis Cluster路由"></a>Redis Cluster路由</h2><img src="/2020/11/25/Redis分布式/1.png"><p>在客户端缓存 Slot 与 Redis 节点的映射关系，当接收到 MOVED 响应时修改缓存中的映射关系。</p><h2 id="Gossip-在-Redis-Cluster-的作用"><a href="#Gossip-在-Redis-Cluster-的作用" class="headerlink" title="Gossip 在 Redis Cluster 的作用"></a>Gossip 在 Redis Cluster 的作用</h2><p>在分布式系统中，需要提供维护节点元数据信息的机制，所谓元数据是指节点负责哪些数据、主从属性、是否出现故障等状态信息。常见的元数据维护方式分为集中式和无中心式。Redis Cluster 采用 Gossip 协议实现了无中心式。</p><p>Meet 消息：用于通知新节点加入。消息发送者通知接收者加入到当前集群，Meet 消息通信正常完成后，接收节点会加入到集群中并进行周期性的 Ping、Pong 消息交换；<br>Ping 消息：集群内交换最频繁的消息，集群内每个节点每秒向多个其它节点发送 Ping 消息，用于检测节点是否在线和交换彼此状态信息。Ping 消息发送封装了自身节点和部分其它节点的状态数据；<br>Pong 消息：当接收到 Ping、Meet 消息时，作为响应消息回复给发送方确认消息正常通信。Pong 消息内部封装了自身状态数据。节点也可以向集群内广播自身的 Pong 消息来通知整个集群对自身状态进行更新；<br>Fail 消息：当节点判定集群内另一个节点下线时，会向集群内广播一个 Fail 消息，其他节点接收到 Fail 消息之后把对应节点更新为下线状态。</p><h2 id="故障转移"><a href="#故障转移" class="headerlink" title="故障转移"></a>故障转移</h2><p>发送Ping Pong消息，转到疑下线状态，再到传播消息，最后做半数以上统计的下线判决。</p><h2 id="投票"><a href="#投票" class="headerlink" title="投票"></a>投票</h2><p>如果一个主节点具有投票权（负责处理 Slot 的主节点)，并且这个主节点尚未投票给其它从节点，那么这个主节点将向请求投票的从节点返回一条回应消息，表示支持该从节点升主。</p><p>在同一轮选举中，只可能有一个从节点收到的票数大于 N/2 + 1。</p><p>接管Master结点后：<br>身份切换、接管职权、广而告之、履行义务</p><h2 id="其他分布式方案"><a href="#其他分布式方案" class="headerlink" title="其他分布式方案"></a>其他分布式方案</h2><h3 id="客户端分片"><a href="#客户端分片" class="headerlink" title="客户端分片"></a>客户端分片</h3><p>如下图所示，客户端与 Redis 节点直连，为了提高可用性，每个主节点挂一个从节点，故障倒换可由“哨兵”系统实现（其它方案也可实现）。客户端对任何一个主节点的读写操作本质上就是单机模式下的读写操作；对于一个 Key-Value，其读写节点完全由客户端决定。</p><p>缺点：1.不支持动态增加节点 2.不支持动态减少节点，原理同上 3.有业务逻辑与数据存储逻辑耦合，可运维性差</p><h3 id="基于代理的分片"><a href="#基于代理的分片" class="headerlink" title="基于代理的分片"></a>基于代理的分片</h3><p>中间层proxy </p><img src="/2020/11/25/Redis分布式/2.png"><h2 id="Redis集群可靠性"><a href="#Redis集群可靠性" class="headerlink" title="Redis集群可靠性"></a>Redis集群可靠性</h2><h3 id="问题一"><a href="#问题一" class="headerlink" title="问题一"></a>问题一</h3><p>三个物理节点，分别部署两个 redis-server，且交叉互为主备，这样做可以提高可靠性：如节点 1 宕机，主节点 A-M 对应的从节点 A-S 将发起投票，作为唯一的备节点，其必然升主成功，与 B-M、C-M 构成新的集群，继续提供服务，如下图所示：</p><img src="/2020/11/25/Redis分布式/3.png"><p>如果宕机的节点 1 经过修复重新上线，根据 Redis 集群原理，节点 1 上的 A-M 将意识到自己已经被替代，将降级为备，形成的集群拓扑结构如下：</p><img src="/2020/11/25/Redis分布式/4.png"><h3 id="问题二"><a href="#问题二" class="headerlink" title="问题二"></a>问题二</h3><p>如果节点 3 宕机，Redis 集群将只有一个主节点 C-M 存活，存活的主节点总数少于集群主节点总数的一半 （1&lt;3/2+1），集群无法自愈，不能继续提供服务。</p><p>为了解决这个问题，我们可以设计一个常驻守护进程对 Redis 集群的状态进行监控，当出现主-备状态不合理的情况（如节点 1 重新上线后的拓扑结构），守护进程主动发起主备倒换（clusterFailover），将节点 1 上的 A-S 升为主，节点 3 上的 A-M 降为备，如此，集群拓扑结构恢复正常，并且能够支持单节点故障。</p><img src="/2020/11/25/Redis分布式/5.png"><h3 id="问题三"><a href="#问题三" class="headerlink" title="问题三"></a>问题三</h3><p>如果节点 1 故障后无法修复，为了保障可靠性，通常会用一个新的节点来替换掉故障的节点——所谓故障替换。拓扑结构如下：</p><img src="/2020/11/25/Redis分布式/6.png"><p>将新节点上的两个 redis-server 纳入现有集群，通过 clusterMeet() 方法可以完成；<br>为新加入集群的两个 redis-server 设置主节点：节点 3 上的两个主 A-M 和 B-M 都没有对应的从节点，因此，可将新加入的两个 redis-server 分别设置为它们的从节点。  </p><img src="/2020/11/25/Redis分布式/7.png"><h2 id="基于-Lettuce-的-Redis-集群运维软件设计及实现"><a href="#基于-Lettuce-的-Redis-集群运维软件设计及实现" class="headerlink" title="基于 Lettuce 的 Redis 集群运维软件设计及实现"></a>基于 Lettuce 的 Redis 集群运维软件设计及实现</h2><img src="/2020/11/25/Redis分布式/8.png"><h2 id="Redis分布式锁实现"><a href="#Redis分布式锁实现" class="headerlink" title="Redis分布式锁实现"></a>Redis分布式锁实现</h2><p>分布式锁需同时满足以下四个约束条件</p><p>互斥性：在任意时刻，只有一个客户端能持有锁；<br>安全性：即不会形成死锁，当一个客户端在持有锁的期间崩溃而没有主动解锁的情况下，其持有的锁也能够被正确释放，并保证后续其它客户端能加锁；<br>可用性：就 Redis 而言，当提供锁服务的 Redis Master 节点发生宕机等不可恢复性故障时，Slave 节点能够升主并继续提供服务，支持客户端加锁和解锁；对基于分布式一致性算法实现的锁服务（如 ETCD）而言，当 Leader 节点宕机时，Follow 节点能够选举出新的 Leader 继续提供锁服务；<br>对称性：对于任意一个锁，其加锁和解锁必须是同一个客户端，即客户端 A 不能把客户端 B 加的锁给解了。  </p><h3 id="预防死锁"><a href="#预防死锁" class="headerlink" title="预防死锁"></a>预防死锁</h3><p>一个客户端获取锁成功，但是在释放锁之前崩溃了，此时该客户端实际上已经失去了对公共资源的操作权，但却没有办法请求解锁（删除 Key-Value 键值对），那么，它就会一直持有这个锁，而其它客户端永远无法获得锁。</p><p>在加锁时为锁设置过期时间</p><h3 id="设置锁自动过期时间以预防死锁存在的隐患"><a href="#设置锁自动过期时间以预防死锁存在的隐患" class="headerlink" title="设置锁自动过期时间以预防死锁存在的隐患"></a>设置锁自动过期时间以预防死锁存在的隐患</h3><p>1.客户端 A 恢复后，可以比较下目前已经持有锁的时间，如果发现已经过期，则放弃对共享资源的操作即可避免互斥性失效的问题。<br>2.既然比较时间不可取，那么，还可以比较 my_random_value，即客户端 A 恢复后，在操作共享资源前应比较目前自身所持有锁的 my_random_value 与 Redis 中存储的 my_random_value 是否一致，如果不相同，说明已经不再持有锁，则放弃对共享资源的操作以避免互斥性失效的问题。</p><h3 id="解锁操作的原子性"><a href="#解锁操作的原子性" class="headerlink" title="解锁操作的原子性"></a>解锁操作的原子性</h3><p>1.使用 Redis 事务功能，使用 Watch 命令监控锁对应的 Key，释放锁则采用事务功能（Multi 命令），如果持有的锁已经因过期而释放（或者过期释放后又被其它客户端持有），则 Key 对应的 Value 将改变，释放锁的事务将不会被执行，从而避免错误的释放锁，示例代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">Jedis jedis = new Jedis(&quot;127.0.0.1&quot;, 6379);</span><br><span class="line"></span><br><span class="line">// “自旋”，等待锁</span><br><span class="line">String result = null;</span><br><span class="line">while (true)</span><br><span class="line">&#123;</span><br><span class="line">    // 申请锁，只有当“lock_name”不存在时才能申请成功，返回“OK&quot;,锁的过期时间设置为5s</span><br><span class="line">    result = jedis.set(&quot;lock_name&quot;, &quot;my_random_value&quot;, SET_IF_NOT_EXIST,</span><br><span class="line">            SET_WITH_EXPIRE_TIME, 5000);</span><br><span class="line">    if (&quot;OK&quot;.equals(result))</span><br><span class="line">    &#123;</span><br><span class="line">        break;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 监控锁对应的 Key，如果其它的客户端对这个 Key 进行了更改，那么本次事务会被取消。</span><br><span class="line">jedis.watch(&quot;lock_name&quot;);</span><br><span class="line">// 成功获取锁，则操作公共资源，自定义流程</span><br><span class="line">// to do something...</span><br><span class="line"></span><br><span class="line">// 释放锁之前，校验是否持有锁</span><br><span class="line">if (jedis.get(&quot;lock_name&quot;).equals(&quot;my_random_value&quot;))</span><br><span class="line">&#123;</span><br><span class="line">    // 开启事务功能，</span><br><span class="line">    Transaction multi = jedis.multi();</span><br><span class="line">    // 模拟客户端阻塞10s，锁超时，自动清除</span><br><span class="line">    try</span><br><span class="line">    &#123;</span><br><span class="line">        Thread.sleep(5000);</span><br><span class="line">    &#125;</span><br><span class="line">    catch (InterruptedException e)</span><br><span class="line">    &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    // 客户端恢复，继续释放锁</span><br><span class="line">    multi.del(&quot;lock_name&quot;);</span><br><span class="line">    // 执行事务（如果其它的客户端对这个Key进行了更改，那么本次事务会被取消,不会执行)</span><br><span class="line">    multi.exec();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 释放资源</span><br><span class="line">jedis.unwatch();</span><br><span class="line">jedis.close();</span><br></pre></td></tr></table></figure><p>2.使用 Lua 脚本实现锁校验与释放，并使用 Redis 的 eval 函数执行 Lua 脚本</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">Jedis jedis = new Jedis(&quot;127.0.0.1&quot;, 6379);</span><br><span class="line"></span><br><span class="line">// “自旋”，等待锁</span><br><span class="line">String result = null;</span><br><span class="line">while (true)</span><br><span class="line">&#123;</span><br><span class="line">    // 申请锁，只有当“lock_name”不存在时才能申请成功，返回“OK&quot;，锁的过期时间设置为 5s</span><br><span class="line">    result = jedis.set(&quot;lock_name&quot;, &quot;my_random_value&quot;, SET_IF_NOT_EXIST,</span><br><span class="line">            SET_WITH_EXPIRE_TIME, 5000);</span><br><span class="line">    if (&quot;OK&quot;.equals(result))</span><br><span class="line">    &#123;</span><br><span class="line">        break;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">// 成功获取锁，则操作公共资源，自定义流程</span><br><span class="line">// to do something...</span><br><span class="line"></span><br><span class="line">// Lua脚本，用于校验并释放锁     </span><br><span class="line">String script = &quot;if redis.call(&apos;get&apos;, KEYS[1]) == ARGV[1] then return redis.call(&apos;del&apos;, KEYS[1]) else return 0 end&quot;;</span><br><span class="line">try</span><br><span class="line">&#123;</span><br><span class="line">    // 模拟客户端阻塞10s，锁超时，自动清除</span><br><span class="line">    Thread.sleep(10000);</span><br><span class="line">&#125;</span><br><span class="line">catch (InterruptedException e)</span><br><span class="line">&#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 执行Lua脚本，校验并释放锁</span><br><span class="line">jedis.eval(script, Collections.singletonList(&quot;lock_name&quot;),</span><br><span class="line">        Collections.singletonList(&quot;my_random_value&quot;));</span><br><span class="line"></span><br><span class="line">jedis.close();</span><br></pre></td></tr></table></figure><h3 id="Redis-节点故障后，主备切换的数据一致性"><a href="#Redis-节点故障后，主备切换的数据一致性" class="headerlink" title="Redis 节点故障后，主备切换的数据一致性"></a>Redis 节点故障后，主备切换的数据一致性</h3><p>客户端 A 从 Master 获取了锁；<br>Master 宕机了，存储锁的 Key 还没有来得及同步到 Slave 上；<br>Slave 升级为 Master；<br>客户端 B 从新的 Master 获取到了对应同一个资源的锁；<br>客户端 A 和客户端 B 同时持有了同一个资源的锁，锁的安全性被打破。</p><p>方案1：还是使用my_random_value</p><p>方案2：RedLock</p><p>运行 Redlock 算法的客户端依次执行以下步骤，来进行加锁的操作：<br>1.获取当前系统时间（毫秒数）。<br>2.按顺序依次向 N 个 Redis 节点执行获取锁的操作。这个获取操作跟前面基于单 Redis 节点获取锁的过程相同，包含随机字符串 my_random_value，也包含过期时间（比如 PX 30000，即锁的有效时间）。为了保证在某个 Redis 节点不可用的时候算法能够继续运行，这个获取锁的操作还有一个超时时间（Time Out），它要远小于锁的有效时间（几十毫秒量级）。客户端在向某个 Redis 节点获取锁失败以后，应该立即尝试下一个 Redis 节点。这里的失败，应该包含任何类型的失败，比如该 Redis 节点不可用。<br>3.计算获取锁的整个过程总共消耗了多长时间，计算方法是用当前时间减去第 1 步记录的时间。如果客户端从大多数 Redis 节点（&gt;=N/2+1）成功获取到了锁，并且获取锁总共消耗的时间没有超过锁的有效时间（Lock Validity Time），那么这时客户端才认为最终获取锁成功；否则，认为最终获取锁失败。<br>4.如果最终获取锁成功了，那么这个锁的有效时间应该重新计算，它等于最初的锁的有效时间减去第 3 步计算出来的获取锁消耗的时间。<br>5.如果最终获取锁失败了（可能由于获取到锁的 Redis 节点个数少于 N/2+1，或者整个获取锁的过程消耗的时间超过了锁的最初有效时间），那么客户端应该立即向所有 Redis 节点发起释放锁的操作（即前面介绍的 Redis Lua 脚本）。  </p><h3 id="典型错误案例"><a href="#典型错误案例" class="headerlink" title="典型错误案例"></a>典型错误案例</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public static void lock(JedisPool jedisPool, String lockName, String myRandomValue, int expireTime) </span><br><span class="line">    &#123;</span><br><span class="line">        Jedis jedis = jedisPool.getResource();</span><br><span class="line">        // 如果锁不存在，则加锁</span><br><span class="line">        Long result = jedis.setnx(lockName, myRandomValue);</span><br><span class="line">        if (result == 1) </span><br><span class="line">        &#123;</span><br><span class="line">            // 为锁设置过期时间，由于加锁和设置过期时间是两步完成的，非原子操作</span><br><span class="line">            jedis.expire(lockName, expireTime);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Redis-Cluster特点&quot;&gt;&lt;a href=&quot;#Redis-Cluster特点&quot; class=&quot;headerlink&quot; title=&quot;Redis Cluster特点&quot;&gt;&lt;/a&gt;Redis Cluster特点&lt;/h2&gt;&lt;p&gt;节点互通：所有的 Redis 节点彼
      
    
    </summary>
    
      <category term="redis" scheme="http://twh233.github.io/categories/redis/"/>
    
    
      <category term="分布式" scheme="http://twh233.github.io/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
      <category term="redis" scheme="http://twh233.github.io/tags/redis/"/>
    
  </entry>
  
  <entry>
    <title>try/catch实现</title>
    <link href="http://twh233.github.io/2020/11/24/try-catch%E5%AE%9E%E7%8E%B0/"/>
    <id>http://twh233.github.io/2020/11/24/try-catch实现/</id>
    <published>2020-11-24T14:08:11.000Z</published>
    <updated>2020-11-24T14:15:26.842Z</updated>
    
    <content type="html"><![CDATA[<p>大体是通过setjmp，longjmp 跨越函数的跳动。</p><p>原理类似if else，但要解决try catch嵌套问题，引入栈空间。</p><p>每个结点存有上一个结点的地址，用链表串起来。</p><p>通过pthread_setspecific，pthread_getspecific 保存当前空间私有信息。解决线程同步的问题。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line"></span><br><span class="line">#include &lt;stdarg.h&gt;</span><br><span class="line"></span><br><span class="line">#include &lt;pthread.h&gt;</span><br><span class="line">#include &lt;setjmp.h&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#define ntyThreadDatapthread_key_t</span><br><span class="line">#define ntyThreadDataSet(key, value)pthread_setspecific((key), (value))</span><br><span class="line">#define ntyThreadDataGet(key)pthread_getspecific((key))</span><br><span class="line">#define ntyThreadDataCreate(key)pthread_key_create(&amp;(key), NULL)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#define EXCEPTIN_MESSAGE_LENGTH512</span><br><span class="line"></span><br><span class="line">typedef struct _ntyException &#123;</span><br><span class="line">const char *name;</span><br><span class="line">&#125; ntyException; </span><br><span class="line"></span><br><span class="line">ntyException SQLException = &#123;&quot;SQLException&quot;&#125;;</span><br><span class="line">ntyException TimeoutException = &#123;&quot;TimeoutException&quot;&#125;;</span><br><span class="line"></span><br><span class="line">ntyThreadData ExceptionStack;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">typedef struct _ntyExceptionFrame &#123;</span><br><span class="line">jmp_buf env;</span><br><span class="line"></span><br><span class="line">int line;</span><br><span class="line">const char *func;</span><br><span class="line">const char *file;</span><br><span class="line"></span><br><span class="line">ntyException *exception;</span><br><span class="line">struct _ntyExceptionFrame *prev;</span><br><span class="line"></span><br><span class="line">char message[EXCEPTIN_MESSAGE_LENGTH+1];</span><br><span class="line"></span><br><span class="line">&#125; ntyExceptionFrame;</span><br><span class="line"></span><br><span class="line">#define ntyExceptionPopStack\</span><br><span class="line">ntyThreadDataSet(ExceptionStack, ((ntyExceptionFrame*)ntyThreadDataGet(ExceptionStack))-&gt;prev)</span><br><span class="line"></span><br><span class="line">#define ReThrowntyExceptionThrow(frame.exception, frame.func, frame.file, frame.line, NULL)</span><br><span class="line">#define Throw(e, cause, ...) ntyExceptionThrow(&amp;(e), __func__, __FILE__, __LINE__, cause, ##__VA_ARGS__, NULL)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">enum &#123;</span><br><span class="line">ExceptionEntered = 0,</span><br><span class="line">ExceptionThrown,</span><br><span class="line">ExceptionHandled,</span><br><span class="line">ExceptionFinalized</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#define Try do &#123;\</span><br><span class="line">volatile int Exception_flag;\</span><br><span class="line">ntyExceptionFrame frame;\</span><br><span class="line">frame.message[0] = 0;\</span><br><span class="line">frame.prev = (ntyExceptionFrame*)ntyThreadDataGet(ExceptionStack);\</span><br><span class="line">ntyThreadDataSet(ExceptionStack, &amp;frame);\</span><br><span class="line">Exception_flag = setjmp(frame.env);\</span><br><span class="line">if (Exception_flag == ExceptionEntered) &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#define Catch(e) \</span><br><span class="line">if (Exception_flag == ExceptionEntered) ntyExceptionPopStack; \</span><br><span class="line">&#125; else if (frame.exception == &amp;(e)) &#123; \</span><br><span class="line">Exception_flag = ExceptionHandled;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#define Finally \</span><br><span class="line">if (Exception_flag == ExceptionEntered) ntyExceptionPopStack; \</span><br><span class="line">&#125; &#123; \</span><br><span class="line">if (Exception_flag == ExceptionEntered)\</span><br><span class="line">Exception_flag = ExceptionFinalized; </span><br><span class="line"></span><br><span class="line">#define EndTry \</span><br><span class="line">if (Exception_flag == ExceptionEntered) ntyExceptionPopStack; \</span><br><span class="line">&#125; if (Exception_flag == ExceptionThrown) ReThrow; \</span><br><span class="line">        &#125; while (0)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">static pthread_once_t once_control = PTHREAD_ONCE_INIT;</span><br><span class="line"></span><br><span class="line">static void init_once(void) &#123; </span><br><span class="line">ntyThreadDataCreate(ExceptionStack); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">void ntyExceptionInit(void) &#123;</span><br><span class="line">pthread_once(&amp;once_control, init_once);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">void ntyExceptionThrow(ntyException *excep, const char *func, const char *file, int line, const char *cause, ...) &#123;</span><br><span class="line"></span><br><span class="line">va_list ap;</span><br><span class="line">ntyExceptionFrame *frame = (ntyExceptionFrame*)ntyThreadDataGet(ExceptionStack);</span><br><span class="line"></span><br><span class="line">if (frame) &#123;</span><br><span class="line"></span><br><span class="line">frame-&gt;exception = excep;</span><br><span class="line">frame-&gt;func = func;</span><br><span class="line">frame-&gt;file = file;</span><br><span class="line">frame-&gt;line = line;</span><br><span class="line"></span><br><span class="line">if (cause) &#123;</span><br><span class="line">va_start(ap, cause);</span><br><span class="line">vsnprintf(frame-&gt;message, EXCEPTIN_MESSAGE_LENGTH, cause, ap);</span><br><span class="line">va_end(ap);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ntyExceptionPopStack;</span><br><span class="line"></span><br><span class="line">longjmp(frame-&gt;env, ExceptionThrown);</span><br><span class="line"></span><br><span class="line">&#125; else if (cause) &#123;</span><br><span class="line"></span><br><span class="line">char message[EXCEPTIN_MESSAGE_LENGTH+1];</span><br><span class="line"></span><br><span class="line">va_start(ap, cause);</span><br><span class="line">vsnprintf(message, EXCEPTIN_MESSAGE_LENGTH, cause, ap);</span><br><span class="line">va_end(ap);</span><br><span class="line"></span><br><span class="line">printf(&quot;%s: %s\n raised in %s at %s:%d\n&quot;, excep-&gt;name, message, func ? func : &quot;?&quot;, file ? file : &quot;?&quot;, line);</span><br><span class="line"></span><br><span class="line">&#125; else &#123;</span><br><span class="line"></span><br><span class="line">printf(&quot;%s: %p\n raised in %s at %s:%d\n&quot;, excep-&gt;name, excep, func ? func : &quot;?&quot;, file ? file : &quot;?&quot;, line);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">/* ** **** ******** **************** debug **************** ******** **** ** */</span><br><span class="line"></span><br><span class="line">ntyException A = &#123;&quot;AException&quot;&#125;;</span><br><span class="line">ntyException B = &#123;&quot;BException&quot;&#125;;</span><br><span class="line">ntyException C = &#123;&quot;CException&quot;&#125;;</span><br><span class="line">ntyException D = &#123;&quot;DException&quot;&#125;;</span><br><span class="line"></span><br><span class="line">void *thread(void *args) &#123;</span><br><span class="line"></span><br><span class="line">pthread_t selfid = pthread_self();</span><br><span class="line"></span><br><span class="line">Try &#123;</span><br><span class="line"></span><br><span class="line">Throw(A, &quot;A&quot;);</span><br><span class="line"></span><br><span class="line">&#125; Catch (A) &#123;</span><br><span class="line"></span><br><span class="line">printf(&quot;catch A : %ld\n&quot;, selfid);</span><br><span class="line"></span><br><span class="line">&#125; EndTry;</span><br><span class="line"></span><br><span class="line">Try &#123;</span><br><span class="line"></span><br><span class="line">Throw(B, &quot;B&quot;);</span><br><span class="line"></span><br><span class="line">&#125; Catch (B) &#123;</span><br><span class="line"></span><br><span class="line">printf(&quot;catch B : %ld\n&quot;, selfid);</span><br><span class="line"></span><br><span class="line">&#125; EndTry;</span><br><span class="line"></span><br><span class="line">Try &#123;</span><br><span class="line"></span><br><span class="line">Throw(C, &quot;C&quot;);</span><br><span class="line"></span><br><span class="line">&#125; Catch (C) &#123;</span><br><span class="line"></span><br><span class="line">printf(&quot;catch C : %ld\n&quot;, selfid);</span><br><span class="line"></span><br><span class="line">&#125; EndTry;</span><br><span class="line"></span><br><span class="line">Try &#123;</span><br><span class="line"></span><br><span class="line">Throw(D, &quot;D&quot;);</span><br><span class="line"></span><br><span class="line">&#125; Catch (D) &#123;</span><br><span class="line"></span><br><span class="line">printf(&quot;catch D : %ld\n&quot;, selfid);</span><br><span class="line"></span><br><span class="line">&#125; EndTry;</span><br><span class="line"></span><br><span class="line">Try &#123;</span><br><span class="line"></span><br><span class="line">Throw(A, &quot;A Again&quot;);</span><br><span class="line">Throw(B, &quot;B Again&quot;);</span><br><span class="line">Throw(C, &quot;C Again&quot;);</span><br><span class="line">Throw(D, &quot;D Again&quot;);</span><br><span class="line"></span><br><span class="line">&#125; Catch (A) &#123;</span><br><span class="line"></span><br><span class="line">printf(&quot;catch A again : %ld\n&quot;, selfid);</span><br><span class="line"></span><br><span class="line">&#125; Catch (B) &#123;</span><br><span class="line"></span><br><span class="line">printf(&quot;catch B again : %ld\n&quot;, selfid);</span><br><span class="line"></span><br><span class="line">&#125; Catch (C) &#123;</span><br><span class="line"></span><br><span class="line">printf(&quot;catch C again : %ld\n&quot;, selfid);</span><br><span class="line"></span><br><span class="line">&#125; Catch (D) &#123;</span><br><span class="line"></span><br><span class="line">printf(&quot;catch B again : %ld\n&quot;, selfid);</span><br><span class="line"></span><br><span class="line">&#125; EndTry;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#define THREADS50</span><br><span class="line"></span><br><span class="line">int main(void) &#123;</span><br><span class="line"></span><br><span class="line">ntyExceptionInit();</span><br><span class="line"></span><br><span class="line">Throw(D, NULL);</span><br><span class="line"></span><br><span class="line">Throw(C, &quot;null C&quot;);</span><br><span class="line"></span><br><span class="line">printf(&quot;\n\n=&gt; Test1: Try-Catch\n&quot;);</span><br><span class="line"></span><br><span class="line">Try &#123;</span><br><span class="line"></span><br><span class="line">Try &#123;</span><br><span class="line">Throw(B, &quot;recall B&quot;);</span><br><span class="line">&#125; Catch (B) &#123;</span><br><span class="line">printf(&quot;recall B \n&quot;);</span><br><span class="line">&#125; EndTry;</span><br><span class="line"></span><br><span class="line">Throw(A, NULL);</span><br><span class="line"></span><br><span class="line">&#125; Catch(A) &#123;</span><br><span class="line"></span><br><span class="line">printf(&quot;\tResult: Ok\n&quot;);</span><br><span class="line"></span><br><span class="line">&#125; EndTry;</span><br><span class="line"></span><br><span class="line">printf(&quot;=&gt; Test1: Ok\n\n&quot;);</span><br><span class="line"></span><br><span class="line">printf(&quot;=&gt; Test2: Test Thread-safeness\n&quot;);</span><br><span class="line">#if 1</span><br><span class="line">int i = 0;</span><br><span class="line">pthread_t threads[THREADS];</span><br><span class="line"></span><br><span class="line">for (i = 0;i &lt; THREADS;i ++) &#123;</span><br><span class="line">pthread_create(&amp;threads[i], NULL, thread, NULL);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">for (i = 0;i &lt; THREADS;i ++) &#123;</span><br><span class="line">pthread_join(threads[i], NULL);</span><br><span class="line">&#125;</span><br><span class="line">#endif</span><br><span class="line">printf(&quot;=&gt; Test2: Ok\n\n&quot;);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;大体是通过setjmp，longjmp 跨越函数的跳动。&lt;/p&gt;
&lt;p&gt;原理类似if else，但要解决try catch嵌套问题，引入栈空间。&lt;/p&gt;
&lt;p&gt;每个结点存有上一个结点的地址，用链表串起来。&lt;/p&gt;
&lt;p&gt;通过pthread_setspecific，pthre
      
    
    </summary>
    
      <category term="基础" scheme="http://twh233.github.io/categories/%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="基础" scheme="http://twh233.github.io/tags/%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>rpc应用和原理</title>
    <link href="http://twh233.github.io/2020/11/23/rpc%E5%BA%94%E7%94%A8%E5%92%8C%E5%8E%9F%E7%90%86/"/>
    <id>http://twh233.github.io/2020/11/23/rpc应用和原理/</id>
    <published>2020-11-23T15:21:37.000Z</published>
    <updated>2020-11-23T15:29:49.778Z</updated>
    
    <content type="html"><![CDATA[<img src="/2020/11/23/rpc应用和原理/1.png"><p>rpc是实现图中RPC协议部分。</p><img src="/2020/11/23/rpc应用和原理/2.png"><p>等于是把接口写在存根里，然后通过同步或者异步的方式去调用对端的接口。这样做等于封装了框架，业务逻辑不用再管协议层，通过rpc来解决协议对接问题。</p><p>服务寻址可以使用 Call ID 映射，在 RPC 中，所有的函数都必须有自己的一个 ID 。<br>因为在本地调用中，函数体是直接通过函数指针来指定的，但是在远程调用中，函数指针是不<br>行的，因为两个进程的地址空间是完全不一样的。</p><p>客户端在做远程过程调用时，必须附上这个 ID。然后我们还需要在客户端和服务端分别维护一<br>个函数和Call ID的对应表。<br>当客户端需要进行远程调用时，它就查一下这个表，找出相应的 Call ID，然后把它传给服务端，<br>服务端也通过查表，来确定客户端需要调用的函数，然后执行相应函数的代码。</p><h2 id="使用rpc还有哪些问题要解决"><a href="#使用rpc还有哪些问题要解决" class="headerlink" title="使用rpc还有哪些问题要解决"></a>使用rpc还有哪些问题要解决</h2><ol><li><p>调用超时处理</p></li><li><p>单向调用（只send）</p></li><li><p>幂等问题</p><p> 一端数据丢失，给另一端多次发送请求。另一端只处理一次</p></li><li><p>反向调用（Nat穿越）</p> <img src="/2020/11/23/rpc应用和原理/3.png"><p> (1 客户机A1、B1顺利通过各自网关访问服务器C ，均没有问题（类似于登录）<br> (2 服务器C保存了 A1、B1各自在其网关的信息（1.2.3.4:62000、1.2.3.5:31000）没有问题。并可将该信息告知A1、B2。<br> (3 此时A1发送给B1网关的1.2.3.5:31000是否会被B1收到？答案是基本上不行（除非Y1设置为完全圆锥型，但这种设置非常少），因为Y1上检测到其存活的会话中没有一个的目的IP或端口与1.2.3.4:62000有关而将数据包全部丢弃！<br> (4 此时要实现A1、B1通过X1、Y1来互访，需要服务器C告诉它们各自在自己的网关上建立“UDP隧道”，即命令A1发送一个 192.168.0.8:4000——1.2.3.5:31000的数据报，B1发送一个192.168.1.8:4000——1.2.3.4:62000的数据报，UDP形式，这样X1、Y1上均存在了IP端口相同的两个不同会话（很显然，这要求网关为Cone NAT型–地址限制锥型或端口限制锥型），否则，对称型Symmetric NAT设置网关将导致对不同会话开启了不同端口，而该端口无法为服务器和对方所知，也就没有意义）。<br> (5 此时A1发给Y1，或者B1发给X1的数据报将不会被丢弃且正确的被对方收到.</p><p> 综合P2P可实现的条件需要：</p><p> 1、 中间服务器保存信息、并能发出建立UDP隧道的命令</p><p> 2、 网关均要求为Cone NAT类型。Symmetric NAT不适合。</p><p> 3、 完全圆锥型网关可以无需建立udp隧道，但这种情况非常少，要求双方均为这种类型网关的更少。</p><p> 4、 假如X1网关为Symmetric NAT， Y1为Address Restricted Cone NAT 或Full Cone NAT型网关，各自建立隧道后，A1可通过X1发送数据报给Y1到B1(因为Y1最多只进行IP级别的甄别)，但B1发送给X1的将会被丢弃（因为发送来的数据报中端口与X1上存在会话的端口不一致，虽然IP地址一致），所以同样没有什么意义。</p><p> 5、 假如双方均为Symmetric NAT的情形，新开了端口，对方可以在不知道的情况下尝试猜解，也可以达到目的，但这种情形成功率很低，且带来额外的系统开支，不是个好的解决办法。</p><p> 6、 不同网关型设置的差异在于，对内会采用替换IP的方式、使用不同端口不同会话的方式，使用相同端口不同会话的方式；对外会采用什么都不限制、限制IP地址、限制IP地址及端口。</p></li><li><p>MQ异步</p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;img src=&quot;/2020/11/23/rpc应用和原理/1.png&quot;&gt;
&lt;p&gt;rpc是实现图中RPC协议部分。&lt;/p&gt;
&lt;img src=&quot;/2020/11/23/rpc应用和原理/2.png&quot;&gt;
&lt;p&gt;等于是把接口写在存根里，然后通过同步或者异步的方式去调用对端的接口。这
      
    
    </summary>
    
      <category term="协议层" scheme="http://twh233.github.io/categories/%E5%8D%8F%E8%AE%AE%E5%B1%82/"/>
    
    
      <category term="rpc" scheme="http://twh233.github.io/tags/rpc/"/>
    
  </entry>
  
  <entry>
    <title>Redis/Mysql 连接池</title>
    <link href="http://twh233.github.io/2020/11/22/Redis-Mysql-%E8%BF%9E%E6%8E%A5%E6%B1%A0/"/>
    <id>http://twh233.github.io/2020/11/22/Redis-Mysql-连接池/</id>
    <published>2020-11-22T10:01:35.000Z</published>
    <updated>2020-11-22T11:54:12.797Z</updated>
    
    <content type="html"><![CDATA[<h2 id="为什么需要数据库连接池"><a href="#为什么需要数据库连接池" class="headerlink" title="为什么需要数据库连接池"></a>为什么需要数据库连接池</h2><img src="/2020/11/22/Redis-Mysql-连接池/1.png"><img src="/2020/11/22/Redis-Mysql-连接池/2.png"><h2 id="好处"><a href="#好处" class="headerlink" title="好处"></a>好处</h2><img src="/2020/11/22/Redis-Mysql-连接池/3.png"><p>做法，参考线程池</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;为什么需要数据库连接池&quot;&gt;&lt;a href=&quot;#为什么需要数据库连接池&quot; class=&quot;headerlink&quot; title=&quot;为什么需要数据库连接池&quot;&gt;&lt;/a&gt;为什么需要数据库连接池&lt;/h2&gt;&lt;img src=&quot;/2020/11/22/Redis-Mysql-连接池
      
    
    </summary>
    
      <category term="基础" scheme="http://twh233.github.io/categories/%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="连接池" scheme="http://twh233.github.io/tags/%E8%BF%9E%E6%8E%A5%E6%B1%A0/"/>
    
  </entry>
  
  <entry>
    <title>协程设计原理与实现</title>
    <link href="http://twh233.github.io/2020/11/22/%E5%8D%8F%E7%A8%8B%E8%AE%BE%E8%AE%A1%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E7%8E%B0/"/>
    <id>http://twh233.github.io/2020/11/22/协程设计原理与实现/</id>
    <published>2020-11-22T08:01:16.000Z</published>
    <updated>2020-11-22T09:48:41.984Z</updated>
    
    <content type="html"><![CDATA[<h2 id="同步-异步与协程有什么关系？"><a href="#同步-异步与协程有什么关系？" class="headerlink" title="同步/异步与协程有什么关系？"></a>同步/异步与协程有什么关系？</h2><p>同步编程方式，更加的直观。但性能不高。</p><p>目的就是以同步的编程方式，有异步的性能。</p><h2 id="如何实现？"><a href="#如何实现？" class="headerlink" title="如何实现？"></a>如何实现？</h2><p>当我们需要异步调用的时候，我们会创建一个协程。比如 accept 返回一个新的sockfd，创建一个客户端处理的子过程。再比如需要监听多个端口的时候，创建一个 server的子过程，这样多个端口同时工作的，是符合微服务的架构的。</p><h3 id="实现IO异步操作"><a href="#实现IO异步操作" class="headerlink" title="实现IO异步操作"></a>实现IO异步操作</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">while (1) &#123;</span><br><span class="line"> int nready = epoll_wait(epfd, events, EVENT_SIZE, -1);</span><br><span class="line"> for (i = 0;i &lt; nready;i ++) &#123;</span><br><span class="line"> int sockfd = events[i].data.fd;</span><br><span class="line"> if (sockfd == listenfd) &#123;</span><br><span class="line"> int connfd = accept(listenfd, xxx, xxxx);</span><br><span class="line"></span><br><span class="line"> setnonblock(connfd);</span><br><span class="line"> ev.events = EPOLLIN | EPOLLET;</span><br><span class="line"> ev.data.fd = connfd;</span><br><span class="line"> epoll_ctl(epfd, EPOLL_CTL_ADD, connfd, &amp;ev);</span><br><span class="line">  &#125; else &#123;</span><br><span class="line"></span><br><span class="line"> epoll_ctl(epfd, EPOLL_CTL_DEL, sockfd, NULL);</span><br><span class="line"> recv(sockfd, buffer, length, 0);</span><br><span class="line"> //parser_proto(buffer, length);</span><br><span class="line"> send(sockfd, buffer, length, 0);</span><br><span class="line"> epoll_ctl(epfd, EPOLL_CTL_ADD, sockfd, NULL);</span><br><span class="line"> &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>能够保证 sockfd 只在一个上下文中能够操作 IO 的。不会出现在多个上下文同时对一个 IO 进行操作的。协程的 IO 异步操作正式是采用此模式进行的。</p><img src="/2020/11/22/协程设计原理与实现/1.png"><h3 id="切换"><a href="#切换" class="headerlink" title="切换"></a>切换</h3><p>上下文通过保存CPU寄存器状态，并切换到下个CPU寄存器状态来实现。</p><img src="/2020/11/22/协程设计原理与实现/2.png"><p>底层是汇编代码</p><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><ol><li>运行体 R：包含运行状态{就绪，睡眠，等待}，运行体回调函数，<br>回调参数，栈指针，栈大小，当前运行体</li><li>调度器 S：包含执行集合{就绪，睡眠，等待}</li></ol><p>本身在使用协程的时候是创建协程，但内部是创建了一个R，需要上层S调度。</p><p>协程定义:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">typedef struct _nty_coroutine &#123;</span><br><span class="line">nty_cpu_ctx ctx;</span><br><span class="line">proc_coroutine func;</span><br><span class="line">void *arg;</span><br><span class="line">size_t stack_size;</span><br><span class="line">nty_coroutine_status status;</span><br><span class="line">nty_schedule *sched;</span><br><span class="line">uint64_t birth;</span><br><span class="line">uint64_t id;</span><br><span class="line">void *stack;</span><br><span class="line">RB_ENTRY(_nty_coroutine) sleep_node;</span><br><span class="line">RB_ENTRY(_nty_coroutine) wait_node;</span><br><span class="line">TAILQ_ENTRY(_nty_coroutine) ready_next;</span><br><span class="line">TAILQ_ENTRY(_nty_coroutine) defer_next;</span><br><span class="line">&#125; nty_coroutine;</span><br></pre></td></tr></table></figure></p><p>调度器定义:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">typedef struct _nty_coroutine_queue nty_coroutine_queue;</span><br><span class="line">typedef struct _nty_coroutine_rbtree_sleep nty_coroutine_rbtree_sleep;</span><br><span class="line">typedef struct _nty_coroutine_rbtree_wait nty_coroutine_rbtree_wait;</span><br><span class="line">typedef struct _nty_schedule &#123;</span><br><span class="line">uint64_t birth;</span><br><span class="line">nty_cpu_ctx ctx;</span><br><span class="line">struct _nty_coroutine *curr_thread;</span><br><span class="line">int page_size;</span><br><span class="line">int poller_fd;</span><br><span class="line">int eventfd;</span><br><span class="line">struct epoll_event eventlist[NTY_CO_MAX_EVENTS];</span><br><span class="line">int nevents;</span><br><span class="line">int num_new_events;</span><br><span class="line">nty_coroutine_queue ready;</span><br><span class="line">nty_coroutine_rbtree_sleep sleeping;</span><br><span class="line">nty_coroutine_rbtree_wait waiting;</span><br><span class="line">&#125; nty_schedule;</span><br></pre></td></tr></table></figure></p><h3 id="调度器"><a href="#调度器" class="headerlink" title="调度器"></a>调度器</h3><ol><li>生产者消费者模式</li></ol><img src="/2020/11/22/协程设计原理与实现/3.png"><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">while (1) &#123;</span><br><span class="line">//遍历睡眠集合，将满足条件的加入到 ready</span><br><span class="line"> nty_coroutine *expired = NULL;</span><br><span class="line"> while ((expired = sleep_tree_expired(sched)) != ) &#123;</span><br><span class="line">TAILQ_ADD(&amp;sched-&gt;ready, expired);</span><br><span class="line"> &#125;</span><br><span class="line"> //遍历等待集合，将满足添加的加入到 ready</span><br><span class="line"> nty_coroutine *wait = NULL;</span><br><span class="line"> int nready = epoll_wait(sched-&gt;epfd, events, EVENT_MAX, 1);</span><br><span class="line"> for (i = 0;i &lt; nready;i ++) &#123;</span><br><span class="line"> wait = wait_tree_search(events[i].data.fd);</span><br><span class="line"> TAILQ_ADD(&amp;sched-&gt;ready, wait);</span><br><span class="line"> &#125;</span><br><span class="line"> // 使用 resume 回复 ready 的协程运行权</span><br><span class="line"> while (!TAILQ_EMPTY(&amp;sched-&gt;ready)) &#123;</span><br><span class="line"> nty_coroutine *ready = TAILQ_POP(sched-&gt;ready);</span><br><span class="line"> resume(ready);</span><br><span class="line"> &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>多状态运行模式 </li></ol><img src="/2020/11/22/协程设计原理与实现/4.png"><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">while (1) &#123;</span><br><span class="line"> //遍历睡眠集合，使用 resume 恢复 expired 的协程运行权</span><br><span class="line"> nty_coroutine *expired = NULL;</span><br><span class="line"> while ((expired = sleep_tree_expired(sched)) != ) &#123;</span><br><span class="line">resume(expired);</span><br><span class="line"> &#125;</span><br><span class="line"> //遍历等待集合，使用 resume 恢复 wait 的协程运行权</span><br><span class="line"> nty_coroutine *wait = NULL;</span><br><span class="line"> int nready = epoll_wait(sched-&gt;epfd, events, EVENT_MAX, 1);</span><br><span class="line"> for (i = 0;i &lt; nready;i ++) &#123;</span><br><span class="line"> wait = wait_tree_search(events[i].data.fd);</span><br><span class="line">resume(wait);</span><br><span class="line"> &#125;</span><br><span class="line"> // 使用 resume 恢复 ready 的协程运行权</span><br><span class="line"> while (!TAILQ_EMPTY(sched-&gt;ready)) &#123;</span><br><span class="line"> nty_coroutine *ready = TAILQ_POP(sched-&gt;ready);</span><br><span class="line"> resume(ready);</span><br><span class="line"> &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>如果没有一个协程，调度器没有任何意义，空转。</p><p>如果只有一个协程，会在init的时候把这个状态直接改成就绪。</p><h2 id="多核开发"><a href="#多核开发" class="headerlink" title="多核开发"></a>多核开发</h2><ol><li><p>借助线程</p><p> 所有线程公用一个调度器的话，会出现线程之间互跳。最好是每个线程单独一个调度器 </p></li><li><p>借助进程<br> 每个进程一个调度器</p><p> 每个CPU都有自己的ID，把调度器的进程通过系统调用挂在CPU上。<br> 那么CPU不会切换调度队列。    </p></li><li><p>汇编</p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;同步-异步与协程有什么关系？&quot;&gt;&lt;a href=&quot;#同步-异步与协程有什么关系？&quot; class=&quot;headerlink&quot; title=&quot;同步/异步与协程有什么关系？&quot;&gt;&lt;/a&gt;同步/异步与协程有什么关系？&lt;/h2&gt;&lt;p&gt;同步编程方式，更加的直观。但性能不高。&lt;/p
      
    
    </summary>
    
      <category term="基础" scheme="http://twh233.github.io/categories/%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="协程" scheme="http://twh233.github.io/tags/%E5%8D%8F%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>内核spinlock的说明和使用</title>
    <link href="http://twh233.github.io/2020/11/19/%E5%86%85%E6%A0%B8spinlock%E7%9A%84%E8%AF%B4%E6%98%8E%E5%92%8C%E4%BD%BF%E7%94%A8/"/>
    <id>http://twh233.github.io/2020/11/19/内核spinlock的说明和使用/</id>
    <published>2020-11-19T15:47:16.000Z</published>
    <updated>2020-11-19T16:05:40.584Z</updated>
    
    <content type="html"><![CDATA[<img src="/2020/11/19/内核spinlock的说明和使用/1.png"><p>进程与进程之间同步，临界区代码要睡眠的话，一定不要使用自旋锁，<br>用信号量。</p><p>获取自旋锁合适的方法：  int spin_trylock(spinlock_t *lock)</p><h2 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h2><img src="/2020/11/19/内核spinlock的说明和使用/2.png"><img src="/2020/11/19/内核spinlock的说明和使用/3.png"><p>owner表示持有这个数字的thread可以获取自旋锁</p><p>next表示如果后续再有thread请求获取这个自旋锁，就给它分配这个数字</p><img src="/2020/11/19/内核spinlock的说明和使用/4.png"><p>汇编，把next位加一进入while循环。如果成了，那么进入临界区smp_mb()；如果没有，那么wfe()睡眠，然后从内存ACCESS_ONCE读数据到内地lockval变量。所以说其他线程没拿到锁都会锁在这里忙等。</p><img src="/2020/11/19/内核spinlock的说明和使用/5.png">]]></content>
    
    <summary type="html">
    
      
      
        &lt;img src=&quot;/2020/11/19/内核spinlock的说明和使用/1.png&quot;&gt;
&lt;p&gt;进程与进程之间同步，临界区代码要睡眠的话，一定不要使用自旋锁，&lt;br&gt;用信号量。&lt;/p&gt;
&lt;p&gt;获取自旋锁合适的方法：  int spin_trylock(spinlock_t *
      
    
    </summary>
    
      <category term="linux" scheme="http://twh233.github.io/categories/linux/"/>
    
    
      <category term="linux" scheme="http://twh233.github.io/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>skynet-定时器</title>
    <link href="http://twh233.github.io/2020/11/19/skynet-%E5%AE%9A%E6%97%B6%E5%99%A8/"/>
    <id>http://twh233.github.io/2020/11/19/skynet-定时器/</id>
    <published>2020-11-19T15:38:56.000Z</published>
    <updated>2021-05-19T03:06:45.977Z</updated>
    
    <content type="html"><![CDATA[<h1 id="定时器skynet-timer-c"><a href="#定时器skynet-timer-c" class="headerlink" title="定时器skynet_timer.c"></a>定时器skynet_timer.c</h1><p>skynet自带定时器功能skynet-src/skynet_timer.c，在skynet启动时会创建一个线程专门跑定时器。每帧(0.0025秒/帧)调用skynet_updatetime()</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">// skynet-src/skynet_start.c</span><br><span class="line"></span><br><span class="line">create_thread(&amp;pid[1], thread_timer, m);</span><br><span class="line"></span><br><span class="line">static void *</span><br><span class="line">thread_timer(void *p) &#123;</span><br><span class="line">    struct monitor * m = p;</span><br><span class="line">    skynet_initthread(THREAD_TIMER);</span><br><span class="line">    for (;;) &#123;</span><br><span class="line">        skynet_updatetime();</span><br><span class="line">        CHECK_ABORT</span><br><span class="line">        wakeup(m,m-&gt;count-1);</span><br><span class="line">        usleep(2500);  //2500微妙=0.0025秒</span><br><span class="line">        if (SIG) &#123;</span><br><span class="line">            signal_hup();</span><br><span class="line">            SIG = 0;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="设计思想"><a href="#设计思想" class="headerlink" title="设计思想"></a>设计思想</h2><p>在skynet里，时间精度是0.01秒，这对于游戏服务器来说已经足够了，定义1滴答=0.01秒，1秒=100滴答。其核心思想是：每个定时器设置一个到期的滴答数，与当前系统的滴答数(启动时是0，然后1滴答1滴答往后跳)比较差值，如果差值interval比较小（0&lt;=interval&lt;=2^8-1），表示定时器即将到来，需要严格关注，把它们保存在2^8个定时器链表里；如果interval越大，表示定时器越远，可以不用太关注，划分成4个等级，2^8&lt;=interval&lt;=2^(8+6)-1，2^(8+6)&lt;=interval&lt;=2^(8+6+6)，…，每个等级只需要2^6个定时器链表保存，比如对于2^8&lt;=interval&lt;=2^(8+6)-1的定时器，将interval&gt;&gt;8相同的值idx保存在第一个等级位置为idx的链表里。</p><p>这样做的优势是：不用为每一个interval创建一个链表，而只需要2^8+4*(2^6)个链表，大大节省了内存。</p><p>之后，在不同情况下，分配不同等级的定时器，等级越高，表示越遥远，需要重新分配的次数越少。</p><h2 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h2><p>数据结构：timer-&gt;near，保存2^8个即将到来的定时器链表；timer-&gt;t，保存4个分级数组，数组的每一项是一个链表；timer-&gt;time保存从skynet启动到现在走过的滴答数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">// skynet-src/skynet_timer.c</span><br><span class="line">struct timer_event &#123;</span><br><span class="line">    uint32_t handle;</span><br><span class="line">    int session;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">struct timer_node &#123; //单个定时器节点</span><br><span class="line">    struct timer_node *next;</span><br><span class="line">    uint32_t expire; //到期滴答数</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">struct link_list &#123; //定时器链表</span><br><span class="line">    struct timer_node head;</span><br><span class="line">    struct timer_node *tail;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">struct timer &#123;</span><br><span class="line">    struct link_list near[TIME_NEAR];</span><br><span class="line">    struct link_list t[4][TIME_LEVEL];</span><br><span class="line">    struct spinlock lock;</span><br><span class="line">    uint32_t time; //启动到现在走过的滴答数，等同于current</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">// skynet-src/skynet_timer.c</span><br><span class="line">int</span><br><span class="line">skynet_timeout(uint32_t handle, int time, int session) &#123;</span><br><span class="line">    ...</span><br><span class="line">    struct timer_event event;</span><br><span class="line">    event.handle = handle;</span><br><span class="line">    event.session = session;</span><br><span class="line">    timer_add(TI, &amp;event, sizeof(event), time);</span><br><span class="line">/*</span><br><span class="line">timer_node指针分配空间</span><br><span class="line">*/</span><br><span class="line">    return session;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static void</span><br><span class="line">timer_add(struct timer *T,void *arg,size_t sz,int time) &#123;</span><br><span class="line">    struct timer_node *node = (struct timer_node *)skynet_malloc(sizeof(*node)+sz);</span><br><span class="line">/*</span><br><span class="line">timer_node结构里并没有timer_event字段，除了分配node自身大小外，额外再分配timer_event大小的空间用来存放event，之后通过node+1的位置可以获取到timer_event数据</span><br><span class="line">*/</span><br><span class="line">    memcpy(node+1,arg,sz);</span><br><span class="line"></span><br><span class="line">    SPIN_LOCK(T);</span><br><span class="line"></span><br><span class="line">    node-&gt;expire=time+T-&gt;time;</span><br><span class="line">    /*</span><br><span class="line">添加到定时器链表里，如果定时器的到期滴答数跟当前比较近(&lt;2^8)，表示即将触发定时器添加到T-&gt;near数组里，否则根据差值大小添加到对应的T-&gt;T[i]中</span><br><span class="line">*/</span><br><span class="line">add_node(T,node);</span><br><span class="line"></span><br><span class="line">    SPIN_UNLOCK(T);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static void</span><br><span class="line">add_node(struct timer *T,struct timer_node *node) &#123;</span><br><span class="line">    uint32_t time=node-&gt;expire;</span><br><span class="line">    uint32_t current_time=T-&gt;time;</span><br><span class="line"></span><br><span class="line">    if ((time|TIME_NEAR_MASK)==(current_time|TIME_NEAR_MASK)) &#123;</span><br><span class="line">        link(&amp;T-&gt;near[time&amp;TIME_NEAR_MASK],node);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        int i;</span><br><span class="line">        uint32_t mask=TIME_NEAR &lt;&lt; TIME_LEVEL_SHIFT;</span><br><span class="line">        for (i=0;i&lt;3;i++) &#123;</span><br><span class="line">            if ((time|(mask-1))==(current_time|(mask-1))) &#123;</span><br><span class="line">                 break;</span><br><span class="line">            &#125;</span><br><span class="line">            mask &lt;&lt;= TIME_LEVEL_SHIFT;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        link(&amp;T-&gt;t[i][((time&gt;&gt;(TIME_NEAR_SHIFT + i*TIME_LEVEL_SHIFT)) &amp; TIME_LEVEL_MASK)],node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">// skynet-src/skynet_timer.c</span><br><span class="line">static inline void</span><br><span class="line">timer_execute(struct timer *T) &#123;</span><br><span class="line">    int idx = T-&gt;time &amp; TIME_NEAR_MASK;</span><br><span class="line">/*</span><br><span class="line">每帧从T-&gt;near中触发到期的定时器链表，near数组里每一项的链表中的所有节点的到期滴答数是相同的</span><br><span class="line">*/</span><br><span class="line">    while (T-&gt;near[idx].head.next) &#123;</span><br><span class="line">        struct timer_node *current = link_clear(&amp;T-&gt;near[idx]);</span><br><span class="line">        SPIN_UNLOCK(T);</span><br><span class="line">        // dispatch_list don&apos;t need lock T</span><br><span class="line">        dispatch_list(current);</span><br><span class="line">        SPIN_LOCK(T);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static inline void</span><br><span class="line">dispatch_list(struct timer_node *current) &#123;</span><br><span class="line">    do &#123;</span><br><span class="line">/*</span><br><span class="line">调用dispatch_list进行分发，通过current+1获取timer_event数据</span><br><span class="line">*/</span><br><span class="line">        struct timer_event * event = (struct timer_event *)(current+1);</span><br><span class="line">        struct skynet_message message;</span><br><span class="line">        message.source = 0;</span><br><span class="line">        message.session = event-&gt;session;</span><br><span class="line">        message.data = NULL;</span><br><span class="line">        message.sz = (size_t)PTYPE_RESPONSE &lt;&lt; MESSAGE_TYPE_SHIFT;</span><br><span class="line">/*</span><br><span class="line">然后给event-&gt;handle push一条消息表示触发定时器</span><br><span class="line">*/</span><br><span class="line">       skynet_context_push(event-&gt;handle, &amp;message);</span><br><span class="line"></span><br><span class="line">       struct timer_node * temp = current;</span><br><span class="line">       current=current-&gt;next;</span><br><span class="line">       skynet_free(temp);</span><br><span class="line">    &#125; while (current);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>每帧除了触发定时器外，还需重新分配定时器所在区间(timer_shift)，因为T-&gt;near里保存即将触发的定时器，所以每TIME_NEAR-1（2^8-1）个滴答数才有可能需要分配（第22行）。否则，分配T-&gt;t中某个等级即可。</p><p>当T-&gt;time的低8位不全为0时，不需要分配，所以每2^8个滴答数才有需要分配一次；</p><p>当T-&gt;time的第9-14位不全为0时，重新分配T[0]等级，每2^8个滴答数分配一次，idx从1开始，每次分配+1；</p><p>当T-&gt;time的第15-20位不全为0时，重新分配T[1]等级，每2^(8+6)个滴答数分配一次，idx从1开始，每次分配+1；</p><p>当T-&gt;time的第21-26位不全为0时，重新分配T[2]等级，每2^(8+6+6)个滴答数分配一次，idx从1开始，每次分配+1；</p><p>当T-&gt;time的第27-32位不全为0时，重新分配T[3]等级，每2^(8+6+6+6)个滴答数分配一次，idx从1开始，每次分配+1；</p><p>即等级越大的定时器越遥远，越不关注，需要重新分配的次数也就越少。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">// skynet-src/skynet_timer.c</span><br><span class="line">static void</span><br><span class="line">move_list(struct timer *T, int level, int idx) &#123;</span><br><span class="line">    struct timer_node *current = link_clear(&amp;T-&gt;t[level][idx]);</span><br><span class="line">    while (current) &#123;</span><br><span class="line">        struct timer_node *temp=current-&gt;next;</span><br><span class="line">        add_node(T,current);</span><br><span class="line">        current=temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static void</span><br><span class="line">timer_shift(struct timer *T) &#123;</span><br><span class="line">    int mask = TIME_NEAR;</span><br><span class="line">    uint32_t ct = ++T-&gt;time;</span><br><span class="line">    if (ct == 0) &#123;</span><br><span class="line">        move_list(T, 3, 0);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        uint32_t time = ct &gt;&gt; TIME_NEAR_SHIFT;</span><br><span class="line">        int i=0;</span><br><span class="line"></span><br><span class="line">        while ((ct &amp; (mask-1))==0) &#123;</span><br><span class="line">            int idx=time &amp; TIME_LEVEL_MASK;</span><br><span class="line">            if (idx!=0) &#123;</span><br><span class="line">                move_list(T, i, idx);</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">            mask &lt;&lt;= TIME_LEVEL_SHIFT;</span><br><span class="line">            time &gt;&gt;= TIME_LEVEL_SHIFT;</span><br><span class="line">            ++i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;定时器skynet-timer-c&quot;&gt;&lt;a href=&quot;#定时器skynet-timer-c&quot; class=&quot;headerlink&quot; title=&quot;定时器skynet_timer.c&quot;&gt;&lt;/a&gt;定时器skynet_timer.c&lt;/h1&gt;&lt;p&gt;skynet自带定时
      
    
    </summary>
    
      <category term="skynet" scheme="http://twh233.github.io/categories/skynet/"/>
    
    
      <category term="skynet" scheme="http://twh233.github.io/tags/skynet/"/>
    
  </entry>
  
  <entry>
    <title>分布式锁实现</title>
    <link href="http://twh233.github.io/2020/11/18/%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E5%AE%9E%E7%8E%B0/"/>
    <id>http://twh233.github.io/2020/11/18/分布式锁实现/</id>
    <published>2020-11-18T15:44:36.000Z</published>
    <updated>2020-11-30T15:28:27.568Z</updated>
    
    <content type="html"><![CDATA[<h2 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h2><ol><li>线程锁<br>lock(mutex)<br>资源操作<br>unlock(mutex)</li><li>进程锁（nginx 中 accept 锁-共享内存+信号量）</li><li>分布式锁 在不同机器的进程的锁</li></ol><h2 id="分布式锁特征"><a href="#分布式锁特征" class="headerlink" title="分布式锁特征"></a>分布式锁特征</h2><p>a) 互斥性<br>b) 可重入性 一个进程允许递归获取锁（需要递归释放锁）<br>c) 锁超时（进程 crash 掉，需要考虑释放分布式锁）<br>d) 高效、高可用（redis，zk）（最后一样，一直一样）<br>e) 公平锁和非公平锁 按获取锁顺序执行，反之就是随机执行  </p><h2 id="redis实现"><a href="#redis实现" class="headerlink" title="redis实现"></a>redis实现</h2><p>redis 数据请求的方式： 请求回应+监听发布</p><p>按请求顺序来执行命令，同样的返回按照执行顺序</p><h3 id="方案1"><a href="#方案1" class="headerlink" title="方案1"></a>方案1</h3><p>获取锁：setnx(key, val) 只有在 key 不存在的时候，才能设置成功。成功收到+ok，失败收到nil。使用 setnx(key, val)需要使用额外命令设置超时 expire(key)，在这里需要使用 redis 事务lua。<br>释放锁：del(key)。</p><h3 id="方案2"><a href="#方案2" class="headerlink" title="方案2"></a>方案2</h3><p>获取锁：将 setnx 和 expire 合并为 set(“lock”, 四元组, “NX”, “EX”, 30);<br>四元组解决只由该进程释放锁，需要添加线程给操作续时间（因为可能执行逻辑超过 30 秒）。<br>释放锁：先 get(key)比较四元组，再 delete；在这里需要添加 redis 事务 lua。<br>if (get(key) == 四元组)<br>delete(key);<br>另外，当 A 释放锁，B,C,D 如何竞争锁；第一种，B,C,D 定时查询；第二种使用监听机制<br>（<a href="http://www.redis.cn/topics/pubsub.html），释放的时候发布" target="_blank" rel="noopener">http://www.redis.cn/topics/pubsub.html），释放的时候发布</a> key 删除事件，同时要监听 key<br>的超时（<a href="http://www.redis.cn/topics/notifications.html）；一般采用第一种。" target="_blank" rel="noopener">http://www.redis.cn/topics/notifications.html）；一般采用第一种。</a>  </p><img src="/2020/11/18/分布式锁实现/1.png"><h2 id="zookeeper实现"><a href="#zookeeper实现" class="headerlink" title="zookeeper实现"></a>zookeeper实现</h2><p>数据模型 + 监听机制来驱动所有的功能 事务</p><ol><li>数据模型 类似文件系统存储方式<br>持久的 持久化<br>短暂的 连接相关，连接断开后，连接创建的节点自动删除<br>顺序的  持久顺序节点<br>（持久节点，短暂顺序节点，短暂节点）</li><li>监听机制 可监听节点的变化 （创建，删除，值的变化，子节点的变化（创建或者删除））</li></ol><p>互斥锁的实现：<br>获取锁：创建同名短暂的节点 只有一个能创建成功<br>释放锁：delete 节点或者断开连接自动删除 锁超时  </p><img src="/2020/11/18/分布式锁实现/2.png"><p>公平锁的实现：  </p><ol><li>每个进程创建 lock 节点（短暂顺序节点）；  </li><li>每个进程都有独自的一个序号；假设序号为 0，说明它获取锁，那么序号不为 0， 只需要监听序号排序中前一位（可能序号小一，可能序号小更多，因为前一个节点可能自动删除了）就行了。  </li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#include &lt;time.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#include &quot;include/zookeeper.h&quot;</span><br><span class="line">#include &quot;include/zookeeper_log.h&quot;</span><br><span class="line"></span><br><span class="line">typedef struct zk_mutex_s &#123;</span><br><span class="line">    int seq_me; // 序号</span><br><span class="line">    int seq_watch; // 监听的序号</span><br><span class="line">    char watch[64]; // 监听的节点名</span><br><span class="line">&#125; zk_mutex_t;</span><br><span class="line">static zk_mutex_t zmt = &#123;0&#125;;</span><br><span class="line">static int quit = 0;</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">typedef void (*void_completion_t)(int rc, const void *data);</span><br><span class="line">*/</span><br><span class="line">void zk_delete_lock_res1_children(int rc, const void *data) &#123;</span><br><span class="line">    printf(&quot;zk_delete_lock_res1_children rc = %d\n&quot;, rc);</span><br><span class="line">    quit = 1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">typedef void (*stat_completion_t)(int rc, const struct Stat *stat,</span><br><span class="line">        const void *data);</span><br><span class="line">*/</span><br><span class="line">void zk_watch_children(int rc, const struct Stat *stat, const void *data) &#123;</span><br><span class="line">    printf(&quot;zk_watch_children_disappear rc = %d\n&quot;, rc);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">typedef void (*strings_completion_t)(int rc,</span><br><span class="line">        const struct String_vector *strings, const void *data);</span><br><span class="line">*/</span><br><span class="line">void zk_get_children_lock_res1(int rc, const struct String_vector *strings, const void *data) &#123;</span><br><span class="line">    printf(&quot;zk_get_children_lock_res1 rc = %d\n&quot;, rc);</span><br><span class="line">    if (rc == 0) &#123;</span><br><span class="line">        int i,v,n;</span><br><span class="line">        n = 0;</span><br><span class="line">        char * value_self = NULL;</span><br><span class="line">        char * value_other = NULL;</span><br><span class="line">        zhandle_t* zk_hdl = (zhandle_t*)data;</span><br><span class="line">        for (i = 0; i &lt; strings-&gt;count; i++) &#123;</span><br><span class="line">            sscanf(strings-&gt;data[i], &quot;%d&quot;, &amp;v);</span><br><span class="line">            if (v &lt; zmt.seq_me) &#123;</span><br><span class="line">                if (n == 0) &#123;</span><br><span class="line">                    zmt.seq_watch = v;</span><br><span class="line">                    value_other = strings-&gt;data[i];</span><br><span class="line">                    n++;</span><br><span class="line">                &#125; else if (n &gt; 0 &amp;&amp; v &gt; zmt.seq_watch) &#123;</span><br><span class="line">                    zmt.seq_watch = v;</span><br><span class="line">                    value_other = strings-&gt;data[i];</span><br><span class="line">                    n++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; else if (v == zmt.seq_me) &#123;</span><br><span class="line">                value_self = strings-&gt;data[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (n == 0) &#123;</span><br><span class="line">            // 说明自己已经最小的了</span><br><span class="line">            char temp[64] = &#123;0&#125;;</span><br><span class="line">            sprintf(temp, &quot;/lock/res1/%s&quot;, value_self);</span><br><span class="line">            printf(&quot;%s 获取锁, 获取执行权, 释放锁\n&quot;, temp);</span><br><span class="line">            zoo_adelete(zk_hdl, temp, -1, zk_delete_lock_res1_children, zk_hdl);</span><br><span class="line">        &#125; else if (n &gt; 0) &#123; // 找到可以监听的对象</span><br><span class="line">            memset(zmt.watch, 0, 64*sizeof(char));</span><br><span class="line">            sprintf(zmt.watch, &quot;/lock/res1/%s&quot;, value_other);</span><br><span class="line">            zoo_aexists(zk_hdl, zmt.watch, 1, zk_watch_children, zk_hdl);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">typedef void</span><br><span class="line">        (*string_completion_t)(int rc, const char *value, const void *data);</span><br><span class="line">*/</span><br><span class="line">void zk_create_lock_res1_es(int rc, const char *value, const void *data) &#123;</span><br><span class="line">    printf(&quot;zk_create_lock_res1_es rc = %d\n&quot;, rc);</span><br><span class="line">    if (rc == 0) &#123;</span><br><span class="line">        zhandle_t* zk_hdl = (zhandle_t*)data;</span><br><span class="line">        int seq;</span><br><span class="line">        sscanf(value, &quot;/lock/res1/%d&quot;, &amp;seq);</span><br><span class="line">        printf(&quot;\tname = %s seq = %d\n&quot;, value, seq);</span><br><span class="line">        zmt.seq_me = seq;</span><br><span class="line">        if (seq &gt; 0) &#123;</span><br><span class="line">            int ret;</span><br><span class="line">            ret = zoo_aget_children(zk_hdl, &quot;/lock/res1&quot;, 0, zk_get_children_lock_res1, data);</span><br><span class="line">            if (ret) &#123;</span><br><span class="line">                printf(&quot;error: zk_create_lock_res1_es:zoo_aget_children\n&quot;);</span><br><span class="line">                exit(EXIT_FAILURE);</span><br><span class="line">            &#125;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        printf(&quot;%s 获取锁, 获取执行权, 释放锁\n&quot;, value);</span><br><span class="line">        zoo_adelete(zk_hdl, value, -1, zk_delete_lock_res1_children, &quot;&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">typedef void (*watcher_fn)(zhandle_t *zh, int type,</span><br><span class="line">        int state, const char *path,void *watcherCtx);</span><br><span class="line">*/</span><br><span class="line">void zk_watcher_disconnect(zhandle_t *zh, int type, int state, const char *path, void *ctx) &#123;</span><br><span class="line">    if (0 == strcmp(zmt.watch, path)) &#123;</span><br><span class="line">        int ret = zoo_aget_children(zh, &quot;/lock/res1&quot;, 0, zk_get_children_lock_res1, zh);</span><br><span class="line">        if (ret) &#123;</span><br><span class="line">            printf(&quot;error: zk_watcher_disconnect:zoo_aget_children\n&quot;);</span><br><span class="line">            exit(EXIT_FAILURE);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main(int argc, const char *argv[]) &#123;</span><br><span class="line">    zoo_set_debug_level(ZOO_LOG_LEVEL_WARN);</span><br><span class="line">    zoo_set_log_stream(stdout);</span><br><span class="line"></span><br><span class="line">    /* 初始化 zk */</span><br><span class="line">    zhandle_t* zk_hdl = zookeeper_init(&quot;127.0.0.1:2181&quot;,</span><br><span class="line">            zk_watcher_disconnect, 30000, 0, &quot;zookeeper for distribute mutex.&quot;, 0);</span><br><span class="line">    if (!zk_hdl) &#123;</span><br><span class="line">        printf(&quot;error: connecting to zookeeper server...\n&quot;);</span><br><span class="line">        exit(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int ret;</span><br><span class="line">    /* 创建 /lock/res1/ 短暂顺序节点*/</span><br><span class="line">    ret = zoo_acreate(zk_hdl, &quot;/lock/res1/&quot;, &quot;mark&quot;, 5, &amp;ZOO_OPEN_ACL_UNSAFE,</span><br><span class="line">        ZOO_EPHEMERAL_SEQUENTIAL, zk_create_lock_res1_es, zk_hdl);</span><br><span class="line">    if (ret) &#123;</span><br><span class="line">        printf(&quot;error: create /lock/res1 EPHEMERAL SEQUENTIAL\n&quot;);</span><br><span class="line">        exit(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line">    ret = 0;</span><br><span class="line"></span><br><span class="line">    for (;;) &#123;</span><br><span class="line">        if (quit) break;</span><br><span class="line">        usleep(2500);</span><br><span class="line">    &#125;</span><br><span class="line">    zookeeper_close(zk_hdl);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;锁&quot;&gt;&lt;a href=&quot;#锁&quot; class=&quot;headerlink&quot; title=&quot;锁&quot;&gt;&lt;/a&gt;锁&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;线程锁&lt;br&gt;lock(mutex)&lt;br&gt;资源操作&lt;br&gt;unlock(mutex)&lt;/li&gt;
&lt;li&gt;进程锁（nginx 中 acc
      
    
    </summary>
    
      <category term="基础" scheme="http://twh233.github.io/categories/%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="分布式" scheme="http://twh233.github.io/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>定时器方案的实现</title>
    <link href="http://twh233.github.io/2020/11/17/%E5%AE%9A%E6%97%B6%E5%99%A8%E6%96%B9%E6%A1%88%E7%9A%84%E5%AE%9E%E7%8E%B0/"/>
    <id>http://twh233.github.io/2020/11/17/定时器方案的实现/</id>
    <published>2020-11-17T14:37:37.000Z</published>
    <updated>2020-11-19T14:20:49.112Z</updated>
    
    <content type="html"><![CDATA[<p>定时器需要满足的需求：</p><p>1.能快速找到第一个时间快到的结点</p><p>2.插入删除 o(logn)</p><h2 id="跳表"><a href="#跳表" class="headerlink" title="跳表"></a>跳表</h2><p>利用跳表来实现，那么跳表最左下角的结点就是第一个结点。<br>查找的效率o(1)</p><p>插入的效率趋近o(logn)</p><h2 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h2><p>查找、插入的效率(logn)</p><p>查第一个结点的时候<br>需要不断递归左子树</p><h2 id="时间轮"><a href="#时间轮" class="headerlink" title="时间轮"></a>时间轮</h2><img src="/2020/11/17/定时器方案的实现/1.png"><p>如图是skynet的定时器设计，就像手表，层数越低代表时间越近。</p><p>层数越低就像秒针。<br>第二层就像分针。<br>第三层像时针。</p><p>等60秒转完，那么分针的数据push进秒针里。分针往后移一格。<br>时针同理，所以称作时间轮。</p><p>缺点：<br>1.移动的，不好删除 + 引用计数  处理比较麻烦<br>2.像时钟一样运行，确保每10ms运行一次</p><h3 id="如何取消呢？"><a href="#如何取消呢？" class="headerlink" title="如何取消呢？"></a>如何取消呢？</h3><p>如果加入定时器，还没触发之前又要删掉。</p><p>只能在业务层处理屏蔽。因为时间轮这种方式是找不到对应的结点位置的。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;定时器需要满足的需求：&lt;/p&gt;
&lt;p&gt;1.能快速找到第一个时间快到的结点&lt;/p&gt;
&lt;p&gt;2.插入删除 o(logn)&lt;/p&gt;
&lt;h2 id=&quot;跳表&quot;&gt;&lt;a href=&quot;#跳表&quot; class=&quot;headerlink&quot; title=&quot;跳表&quot;&gt;&lt;/a&gt;跳表&lt;/h2&gt;&lt;p&gt;利用跳表
      
    
    </summary>
    
      <category term="基础" scheme="http://twh233.github.io/categories/%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="定时器" scheme="http://twh233.github.io/tags/%E5%AE%9A%E6%97%B6%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>内核原子变量的说明和使用</title>
    <link href="http://twh233.github.io/2020/11/17/%E5%86%85%E6%A0%B8%E5%8E%9F%E5%AD%90%E5%8F%98%E9%87%8F%E7%9A%84%E8%AF%B4%E6%98%8E%E5%92%8C%E4%BD%BF%E7%94%A8/"/>
    <id>http://twh233.github.io/2020/11/17/内核原子变量的说明和使用/</id>
    <published>2020-11-17T13:11:15.000Z</published>
    <updated>2020-11-17T13:22:11.222Z</updated>
    
    <content type="html"><![CDATA[<img src="/2020/11/17/内核原子变量的说明和使用/1.png"><p>static atomic_t can_open = ATOMIC_INIT(1);</p><p>atomic_dec_and_test 先减一，如果结果是0返回true，否则返回false。</p><p>第一次可以打开，第二次进入if。</p><p>atomic_inc 再加一，不会被打断。 原子的加法分三步，最底层调用汇编代码。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;img src=&quot;/2020/11/17/内核原子变量的说明和使用/1.png&quot;&gt;
&lt;p&gt;static atomic_t can_open = ATOMIC_INIT(1);&lt;/p&gt;
&lt;p&gt;atomic_dec_and_test 先减一，如果结果是0返回true，否则返回fal
      
    
    </summary>
    
      <category term="linux" scheme="http://twh233.github.io/categories/linux/"/>
    
    
      <category term="linux" scheme="http://twh233.github.io/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>semaphore内核源码的实现</title>
    <link href="http://twh233.github.io/2020/11/15/semaphore%E5%86%85%E6%A0%B8%E6%BA%90%E7%A0%81%E7%9A%84%E5%AE%9E%E7%8E%B0/"/>
    <id>http://twh233.github.io/2020/11/15/semaphore内核源码的实现/</id>
    <published>2020-11-15T10:11:26.000Z</published>
    <updated>2020-11-15T10:21:55.067Z</updated>
    
    <content type="html"><![CDATA[<img src="/2020/11/15/semaphore内核源码的实现/5.png"><p>首先down 是获取锁，如果获取到可以独占临界区资源执行下面语句，如果获取不到不断轮询去获取。</p><img src="/2020/11/15/semaphore内核源码的实现/2.png"><p>第一个进程只是把count–，而第二个进程才会去__down函数里</p><img src="/2020/11/15/semaphore内核源码的实现/1.png"><p>current 当前进程，把等待在信号量上的task加入waiter结构体里。</p><p>(如果有信号打断goto interrupted)</p><p>自旋锁的开销非常大，尽可能尽量少的代码在自旋锁的粒度里，所以才会有外面加锁，里面解锁又加锁。schedule_timeout会睡眠，所以没办法放进自旋锁的保护区里，当到进程二唤醒的时候接着加锁，waiter.up == true 返回 </p><img src="/2020/11/15/semaphore内核源码的实现/3.png"><p>同理。进程count++，如果wait_list空，那么调用__up函数</p><img src="/2020/11/15/semaphore内核源码的实现/4.png"><p>从刚才的容器里拿出来waiter， waiter-&gt;up = true</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;img src=&quot;/2020/11/15/semaphore内核源码的实现/5.png&quot;&gt;
&lt;p&gt;首先down 是获取锁，如果获取到可以独占临界区资源执行下面语句，如果获取不到不断轮询去获取。&lt;/p&gt;
&lt;img src=&quot;/2020/11/15/semaphore内核源码的实现
      
    
    </summary>
    
      <category term="linux" scheme="http://twh233.github.io/categories/linux/"/>
    
    
      <category term="linux" scheme="http://twh233.github.io/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>用户态协议栈TCPIP</title>
    <link href="http://twh233.github.io/2020/11/15/%E7%94%A8%E6%88%B7%E6%80%81%E5%8D%8F%E8%AE%AE%E6%A0%88TCPIP/"/>
    <id>http://twh233.github.io/2020/11/15/用户态协议栈TCPIP/</id>
    <published>2020-11-15T09:18:06.000Z</published>
    <updated>2021-05-04T07:46:32.747Z</updated>
    
    <content type="html"><![CDATA[<h2 id="网卡是属于协议栈哪一层"><a href="#网卡是属于协议栈哪一层" class="headerlink" title="网卡是属于协议栈哪一层"></a>网卡是属于协议栈哪一层</h2><p>网卡不属于任何一层。<br>物理层传输的是：光电信号<br>数据链路层对应：数字信号</p><p>网卡作用：将光电信号转化成数字信号，数字信号转化为光电信号。</p><h2 id="利用-netmap-实现协议栈"><a href="#利用-netmap-实现协议栈" class="headerlink" title="利用 netmap 实现协议栈"></a>利用 netmap 实现协议栈</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;sys/poll.h&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#define NETMAP_WITH_LIBS</span><br><span class="line"></span><br><span class="line">#include &lt;net/netmap_user.h&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#pragma pack(1)</span><br><span class="line"></span><br><span class="line">#define PROTO_IP 0x0800</span><br><span class="line">#define PROTO_UDP17</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#define ETH_LEN6</span><br><span class="line"></span><br><span class="line">struct ethhdr &#123;</span><br><span class="line"></span><br><span class="line">unsigned char h_dest[ETH_LEN]; //mac</span><br><span class="line">unsigned char h_src[ETH_LEN];</span><br><span class="line">unsigned short h_proto;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line">// sizeof(struct ethhdr) == 14</span><br><span class="line"></span><br><span class="line">struct iphdr &#123;</span><br><span class="line"></span><br><span class="line">unsigned char version:4,</span><br><span class="line">  hdrlen:4;</span><br><span class="line"></span><br><span class="line">unsigned char tos; //</span><br><span class="line">unsigned short length;</span><br><span class="line"></span><br><span class="line">unsigned short id;</span><br><span class="line"></span><br><span class="line">unsigned short flag:3,</span><br><span class="line">   offset:13;</span><br><span class="line"></span><br><span class="line">unsigned char ttl;</span><br><span class="line">unsigned char proto;</span><br><span class="line"></span><br><span class="line">unsigned short check;</span><br><span class="line"></span><br><span class="line">unsigned int sip;</span><br><span class="line">unsigned int dip;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// sizeof(struct ip) == 20</span><br><span class="line"></span><br><span class="line">struct udphdr &#123;</span><br><span class="line"></span><br><span class="line">unsigned short sport;</span><br><span class="line">unsigned short dport;</span><br><span class="line">unsigned short length;</span><br><span class="line">unsigned short check;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// sizeof(udphdr)  8</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">struct udppkt &#123;</span><br><span class="line"></span><br><span class="line">struct ethhdr eh; // 14</span><br><span class="line">struct iphdr ip;  // 20</span><br><span class="line">struct udphdr udp; // 8</span><br><span class="line"></span><br><span class="line">unsigned char body[0]; // sizeof(body)=0;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// sizeof(udppkt) = 44</span><br><span class="line">// sizeof()</span><br><span class="line"></span><br><span class="line">// f-stack</span><br><span class="line">// dpdk + bsd </span><br><span class="line"></span><br><span class="line">// netmap , dpdk, raw_socket</span><br><span class="line"></span><br><span class="line">// netmap:eth0</span><br><span class="line">// eth0</span><br><span class="line">int main() &#123;</span><br><span class="line"></span><br><span class="line">// eth0  --&gt; ens33</span><br><span class="line">struct nm_desc *nmr = nm_open(&quot;netmap:eth0&quot;, NULL, 0, NULL);</span><br><span class="line">if (nmr == NULL) &#123;</span><br><span class="line">return -1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">struct pollfd pfd = &#123;0&#125;;</span><br><span class="line">pfd.fd = nmr-&gt;fd; //</span><br><span class="line">pfd.events = POLLIN;</span><br><span class="line">// select/poll  or epoll</span><br><span class="line">// poll --&gt; select</span><br><span class="line">while (1) &#123;</span><br><span class="line"></span><br><span class="line">int ret = poll(&amp;pfd, 1, -1);</span><br><span class="line">if (ret &lt; 0) continue;</span><br><span class="line"></span><br><span class="line">if (pfd.revents &amp; POLLIN) &#123;</span><br><span class="line">struct nm_pkthdr h;</span><br><span class="line">unsigned char *stream = nm_nextpkt(nmr, &amp;h); // read</span><br><span class="line"></span><br><span class="line">struct ethhdr *eh = (struct ethhdr*)stream;</span><br><span class="line"></span><br><span class="line">// 0x0800</span><br><span class="line">if (ntohs(eh-&gt;h_proto) == PROTO_IP) &#123;</span><br><span class="line"></span><br><span class="line">struct udppkt *udp = (struct udppkt *)stream;</span><br><span class="line"></span><br><span class="line">if (udp-&gt;ip.proto == PROTO_UDP) &#123;</span><br><span class="line"></span><br><span class="line">//</span><br><span class="line">int udp_length = ntohs(udp-&gt;udp.length);</span><br><span class="line"></span><br><span class="line">udp-&gt;body[udp_length-8] = &apos;\0&apos;;</span><br><span class="line"></span><br><span class="line">printf(&quot;udp --&gt; %s\n&quot;, udp-&gt;body);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="为什么一会儿就不能接受发送到这个端口的数据了"><a href="#为什么一会儿就不能接受发送到这个端口的数据了" class="headerlink" title="为什么一会儿就不能接受发送到这个端口的数据了"></a>为什么一会儿就不能接受发送到这个端口的数据了</h3><p>因为arp过期了，icmp 会ping 对端，但是这个程序没有一直ping对端，导致arp过期。 不能再找到主机的MAC地址，所以发送不过去了。</p><h2 id="fd端口只有65535，为什么并发能做到上百万"><a href="#fd端口只有65535，为什么并发能做到上百万" class="headerlink" title="fd端口只有65535，为什么并发能做到上百万"></a>fd端口只有65535，为什么并发能做到上百万</h2><p>fd –&gt;  五元组(sip,dip,sport,dport,proto)</p><p>send(fd)的时候，fd 通过五元组判断客户端的唯一性</p><h2 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a>三次握手</h2><img src="/2020/11/15/用户态协议栈TCPIP/1.png"><p>第一次三次握手 window size 没意义，后面window size另外一边就知道这边的传输大小了。</p><p>syn 队列 accept队列满时，会造成真正要连接的fd阻塞。只能加外网防火墙拦截。</p><h2 id="滑动窗口"><a href="#滑动窗口" class="headerlink" title="滑动窗口"></a>滑动窗口</h2><img src="/2020/11/15/用户态协议栈TCPIP/2.png"><p>如果接收到ACK，那么说明从这个包之前的包都已经成功接受到，可以往后滑动，发送新的包。<br>对端ACK应答把窗口大小带上。</p><h2 id="快速重传"><a href="#快速重传" class="headerlink" title="快速重传"></a>快速重传</h2><p>当接收端收到比期望序号大的报文段时，便会重复发送最近一次确认的报文段的确认信号，我们称之为冗余ACK。<br>报文段1成功接收并被确认ACK 2，接收端的期待序号为2，当报文段2丢失，报文段3失序到来，与接收端的期望不匹配，接收端重复发送冗余ACK 2。</p><img src="/2020/11/15/用户态协议栈TCPIP/3.png"><h2 id="拥塞控制"><a href="#拥塞控制" class="headerlink" title="拥塞控制"></a>拥塞控制</h2><p>滑动窗口可以是动态控制大小的。跟rtt有关系。</p><p>rtt = 0.9 <em> oldrtt + 0.1 </em> newrtt</p><p>而cwnd 由慢启动 cwnd = cwnd * 2 再到拥塞控制 1/2这个过程逐步趋于一个平稳值。</p><p>cwind 变大 变小问题 rtt = round trip time   RTT增加，拥塞窗口减小，RTT减小，拥塞窗口增加<br>    慢启动(指数增长) 拥塞控制(减半) </p><h2 id="为什么会用udp做可靠传输"><a href="#为什么会用udp做可靠传输" class="headerlink" title="为什么会用udp做可靠传输"></a>为什么会用udp做可靠传输</h2><img src="/2020/11/15/用户态协议栈TCPIP/4.png"><p>下载的时候，TCP可以限制包数量，但是UDP不行。  </p><p>游戏打团得实时，TCP要保持有序，卡了怎么办，所以可以牺牲效率保证实时。</p><h2 id="四次挥手"><a href="#四次挥手" class="headerlink" title="四次挥手"></a>四次挥手</h2><img src="/2020/11/15/用户态协议栈TCPIP/5.png"><h3 id="为什么四次挥手是四次"><a href="#为什么四次挥手是四次" class="headerlink" title="为什么四次挥手是四次"></a>为什么四次挥手是四次</h3><p>因为对端都需要对方的确认，就像男女朋友，A提出分手，B先接受这个消息，表示我知道你要分手了。但是还需要一点时间消化，同意了再告诉A，我同意了。而且A提出分手的时候，B还有一些数据还在传，传完了之后再告诉A断开联系。所以必须是四次</p><h3 id="为什么还有fin-wait2状态"><a href="#为什么还有fin-wait2状态" class="headerlink" title="为什么还有fin_wait2状态"></a>为什么还有fin_wait2状态</h3><p>因为还要收B的数据 </p><h3 id="time-wait作用"><a href="#time-wait作用" class="headerlink" title="time_wait作用"></a>time_wait作用</h3><p>害怕最后一次ACK丢失，发送fin的时候有定时器，如果最后一次ACK可能丢失，如果在LAST_ACK状态的B收不到这个ACK的确认。B会超时重传FIN，所以time_wait是2MSL.A就能在这个时间内再次发送ACK确认，重新启动2MSL的计时器。并且有效防止了旧ACK的出现影响连接。下一个新的连接不会再出现这种旧的连接请求报文段。</p><h3 id="出现大量close-wait状态"><a href="#出现大量close-wait状态" class="headerlink" title="出现大量close_wait状态"></a>出现大量close_wait状态</h3><p>因为B端 recv() 没有调用close() 或者时机不对 </p><h3 id="如图，ACK丢失会怎样"><a href="#如图，ACK丢失会怎样" class="headerlink" title="如图，ACK丢失会怎样"></a>如图，ACK丢失会怎样</h3><p>A先收到FIN就出现closing状态，再收到ACK变为time_wait状态。</p><h3 id="中间ACK和FIN同时调用"><a href="#中间ACK和FIN同时调用" class="headerlink" title="中间ACK和FIN同时调用"></a>中间ACK和FIN同时调用</h3><p>出现A也发送关闭FIN，B也同时发送FIN，那么两边都会成为closing状态，各自收到ACK变成time_wait状态，四次挥手就变成了三次</p><h3 id="time-wait状态太多"><a href="#time-wait状态太多" class="headerlink" title="time_wait状态太多"></a>time_wait状态太多</h3><p>等待时间过长</p><h2 id="tcp与epoll的触发"><a href="#tcp与epoll的触发" class="headerlink" title="tcp与epoll的触发"></a>tcp与epoll的触发</h2><img src="/2020/11/15/用户态协议栈TCPIP/6.png">]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;网卡是属于协议栈哪一层&quot;&gt;&lt;a href=&quot;#网卡是属于协议栈哪一层&quot; class=&quot;headerlink&quot; title=&quot;网卡是属于协议栈哪一层&quot;&gt;&lt;/a&gt;网卡是属于协议栈哪一层&lt;/h2&gt;&lt;p&gt;网卡不属于任何一层。&lt;br&gt;物理层传输的是：光电信号&lt;br&gt;数据链路
      
    
    </summary>
    
      <category term="基础" scheme="http://twh233.github.io/categories/%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="TCP/IP" scheme="http://twh233.github.io/tags/TCP-IP/"/>
    
  </entry>
  
  <entry>
    <title>redis源码</title>
    <link href="http://twh233.github.io/2020/11/11/redis%E6%BA%90%E7%A0%81/"/>
    <id>http://twh233.github.io/2020/11/11/redis源码/</id>
    <published>2020-11-11T15:02:18.000Z</published>
    <updated>2021-05-18T07:01:34.464Z</updated>
    
    <content type="html"><![CDATA[<h2 id="redis的Hash如何解决冲突"><a href="#redis的Hash如何解决冲突" class="headerlink" title="redis的Hash如何解决冲突"></a>redis的Hash如何解决冲突</h2><p>链表法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">typedef struct dictht &#123;</span><br><span class="line">dictEntry **table;</span><br><span class="line">unsigned long size;</span><br><span class="line"> unsigned long sizemask;</span><br><span class="line"> unsigned long used;</span><br><span class="line">&#125; dictht;</span><br></pre></td></tr></table></figure><p>table 属性是⼀个数组，数组中的每个元素都是⼀个指向 dict.h/dictEntry 结构的指针，每个dictEntry 结构保存着⼀个键值对；<br>size 属性记录了哈希表的⼤⼩,也即是 table 数组的⼤⼩，⽽ used 属性则记录了哈希表⽬前已有节点（键值对）的数量；<br>sizemask 属性的值总是等于 size - 1 ，这个属性和哈希值⼀起决定⼀个键应该被放到 table 数组的哪个索引上⾯；used属性，表示hash表⾥已有的数量。如下图展示了⼀个空的hash表：</p><img src="/2020/11/11/redis源码/1.png"><p>hash表的节点哈希表节点使⽤ dictEntry 结构表示， 每个 dictEntry 结构都保存着⼀个键值对</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">typedef struct dictEntry &#123;</span><br><span class="line">    // 键</span><br><span class="line">    void *key;  </span><br><span class="line">    </span><br><span class="line">    // 值</span><br><span class="line">union &#123;</span><br><span class="line">void *val;</span><br><span class="line">uint64_t u64;</span><br><span class="line">int64_t s64;</span><br><span class="line">double d;</span><br><span class="line">&#125; v; </span><br><span class="line">    </span><br><span class="line">// 指向下个哈希表节点，形成链表</span><br><span class="line">struct dictEntry *next;</span><br><span class="line">&#125; dictEntry;</span><br></pre></td></tr></table></figure><p>举个例⼦，下图就展示了如何通过 next 指针，将两个索引值相同的键 k1 和 k0 连接在⼀起。</p><img src="/2020/11/11/redis源码/2.png"><p>hash表是随着K-V数量的增⼤⽽逐步增⼤的，并不直接以key的hash值为下标去取值得，⽽是以hash &amp; sizemask去获取hash表的对应节点的；hash表的节点实际上是⼀个链表，如果hash &amp;sizemask有冲突，则也把冲突key放在hash表的链表上，取值得时候还得遍历hash表⾥的链表。</p><h2 id="rehash"><a href="#rehash" class="headerlink" title="rehash"></a>rehash</h2><p>随着操作的不断执⾏，哈希表保存的键值对会逐渐地增多或者减少，为了让哈希表的负载因⼦（ratio）维持在⼀个合理的范围之内，当哈希表保存的键值对数量太多或者太少时，程序需要对哈希表的⼤⼩进⾏相应的扩展或者收缩。</p><p>扩容的步骤如下：<br>1、为字典ht[1]哈希表分配合适的空间；<br>2、将ht[0]中所有的键值对rehash到ht[1]：rehash 指的是重新计算键的哈希值和索引值，然后将键值对放置到 ht[1] 哈希表的指定位置上；<br>3、当 ht[0] 包含的所有键值对都迁移到了 ht[1] 之后（ht[0] 变为空表） 释放 ht[0] ，将 ht[1] 设置为 ht[0] ，并在 ht[1] 新创建⼀个空⽩哈希表，为下⼀次 rehash 做准备。  </p><p>当然rehash指渐进式hash，如果在服务器运作直接扩容，那么会影响服务器性能。以下是哈希表渐进式 rehash 的详细步骤：  </p><ol><li>为 ht[1] 分配空间，让字典同时持有 ht[0] 和 ht[1] 两个哈希表。</li><li>在字典中维持⼀个索引计数器变量 rehashidx ，并将它的值设置0 ， 表示 rehash ⼯作正式开始。  </li><li>在 rehash 进⾏期间，每次对字典执⾏添加、删除、查找或者更新操作时，程序除了执⾏指定的操作以外，还会顺带将 ht[0] 哈希表rehashidx 索引上的所有键值对 rehash 到 ht[1] ，当 rehash ⼯作完成之后，程序将 rehashidx 属性的值增⼀。</li><li>随着字典操作的不断执⾏，最终在某个时间点上 ht[0] 的所有键对都会被 rehash ⾄ ht[1] ，这时程序将 rehashidx 属性的值设为 -1 ， 表示 rehash 操作已完成。</li></ol><p>插曲：</p><p>keys hkeys 枚举形式，是通过高位加1的方式进行next，这样的好处是让每次扩缩容，前面的for不用再进行遍历。</p><h2 id="跳表"><a href="#跳表" class="headerlink" title="跳表"></a>跳表</h2><p>跳表与红黑树区别：<br>1) 结构的区别： 多层有序链表，二叉树<br>2）搜索的区别： 大概率的o(logn)<br>3) 功能性的区别： o(logn) zrange logn * o(logn)</p><img src="/2020/11/11/redis源码/3.png"><h2 id="主从复制"><a href="#主从复制" class="headerlink" title="主从复制"></a>主从复制</h2><h3 id="2-8版本以前的方案：全量同步"><a href="#2-8版本以前的方案：全量同步" class="headerlink" title="2.8版本以前的方案：全量同步"></a>2.8版本以前的方案：全量同步</h3><p>1.master 持久化，之后的命令写入缓冲区，发送rdb<br>2.slave接受rdb，加载至内存<br>3.master 发送缓冲区的命令，slave依次处理  </p><p>下面三种情况如何保证效率问题：<br>a.新加入从结点 b.主从连接故障  c.从结点重启 </p><p>其实如果是b情况，只需要将少量写操作同步给从数据库就行了<br>于是引入2.8版本 </p><h3 id="2-8版本"><a href="#2-8版本" class="headerlink" title="2.8版本"></a>2.8版本</h3><p>1.记录偏移量 psync<br>2.主master运行id </p><h3 id="之后版本"><a href="#之后版本" class="headerlink" title="之后版本"></a>之后版本</h3><p>rdb保存运行id以及offset<br>主切换 从需要记录之前运行id以及偏移量</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;redis的Hash如何解决冲突&quot;&gt;&lt;a href=&quot;#redis的Hash如何解决冲突&quot; class=&quot;headerlink&quot; title=&quot;redis的Hash如何解决冲突&quot;&gt;&lt;/a&gt;redis的Hash如何解决冲突&lt;/h2&gt;&lt;p&gt;链表法&lt;/p&gt;
&lt;figur
      
    
    </summary>
    
      <category term="redis" scheme="http://twh233.github.io/categories/redis/"/>
    
    
      <category term="redis" scheme="http://twh233.github.io/tags/redis/"/>
    
  </entry>
  
</feed>
