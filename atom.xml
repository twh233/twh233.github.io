<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Twh233&#39;s Blog</title>
  
  <subtitle>Love Coding,Enjoy Life</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://twh233.github.io/"/>
  <updated>2020-11-30T15:47:14.568Z</updated>
  <id>http://twh233.github.io/</id>
  
  <author>
    <name>Twh233</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>分布式一致性算法Raft和Etcd</title>
    <link href="http://twh233.github.io/2020/11/30/%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%80%E8%87%B4%E6%80%A7%E7%AE%97%E6%B3%95Raft%E5%92%8CEtcd/"/>
    <id>http://twh233.github.io/2020/11/30/分布式一致性算法Raft和Etcd/</id>
    <published>2020-11-30T15:19:34.000Z</published>
    <updated>2020-11-30T15:47:14.568Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Raft"><a href="#Raft" class="headerlink" title="Raft"></a>Raft</h1><h2 id="Raft角色"><a href="#Raft角色" class="headerlink" title="Raft角色"></a>Raft角色</h2><p>Leader（领导者）：负责日志的同步管理，处理来自客户端的请求，与Follower保持heartBeat的联系；<br>Follower（追随者）：响应 Leader 的日志同步请求，响应Candidate的邀票请求，以及把客户端请求到Follower的事务转发（重定向）给Leader；<br>Candidate（候选者）：负责选举投票，集群刚启动或者Leader宕机时，状态为Follower的节点将转为Candidate并发起选举，选举胜出（获得超过半数节点的投票）后，从Candidate转为Leader状态。  </p><h2 id="Raft-三个子问题"><a href="#Raft-三个子问题" class="headerlink" title="Raft 三个子问题"></a>Raft 三个子问题</h2><p>选举（Leader Election）：当 Leader 宕机或者集群初创时，一个新的 Leader 需要被选举出来；<br>日志复制（Log Replication）：Leader 接收来自客户端的请求并将其以日志条目的形式复制到集群中的其它节点，并且强制要求其它节点的日志和自己保持一致；<br>安全性（Safety）：如果有任何的服务器节点已经应用了一个确定的日志条目到它的状态机中，那么其它服务器节点不能在同一个日志索引位置应用一个不同的指令。  </p><h2 id="Raft-算法之-Leader-Election-原理"><a href="#Raft-算法之-Leader-Election-原理" class="headerlink" title="Raft 算法之 Leader Election 原理"></a>Raft 算法之 Leader Election 原理</h2><p>第一阶段：所有节点都是 Follower。<br>第二阶段：Follower 转为 Candidate 并发起投票。<br>第三阶段：投票策略。  </p><p>节点收到投票请求后会根据以下情况决定是否接受投票请求：</p><p>请求节点的 Term 大于自己的 Term，且自己尚未投票给其它节点，则接受请求，把票投给它；<br>请求节点的 Term 小于自己的 Term，且自己尚未投票，则拒绝请求，将票投给自己。</p><p>第四阶段：Candidate 转为 Leader。</p><h2 id="Raft-算法之-Log-Replication-原理"><a href="#Raft-算法之-Log-Replication-原理" class="headerlink" title="Raft 算法之 Log Replication 原理"></a>Raft 算法之 Log Replication 原理</h2><p>第一阶段：客户端请求提交到 Leader。</p><p>Follower 将会把请求重定向到 Leader。Leader 在收到请求后，会将它作为日志条目（Entry）写入本地日志中。需要注意的是，此时该 Entry 的状态是未提交（Uncommitted），Leader 并不会更新本地数据，因此它是不可读的。</p><p>第二阶段：Leader 将 Entry 发送到其它 Follower</p><p>在发送追加日志条目的时候，Leader 会把新的日志条目紧接着之前条目的索引位置（prevLogIndex）， Leader 任期号（Term）也包含在其中。如果 Follower 在它的日志中找不到包含相同索引位置和任期号的条目，那么它就会拒绝接收新的日志条目，因为出现这种情况说明 Follower 和 Leader 不一致。</p><p>要使 Follower 的日志与 Leader 恢复一致，Leader 必须找到最后两者达成一致的地方（说白了就是回溯，找到两者最近的一致点），然后删除从那个点之后的所有日志条目，发送自己的日志给 Follower。所有的这些操作都在进行附加日志的一致性检查时完成。</p><p>如果一个 Follower 的日志和 Leader 不一致，那么在下一次附加日志时一致性检查就会失败。在被 Follower 拒绝之后，Leader 就会减小该 Follower 对应的 nextIndex 值并进行重试。最终 nextIndex 会在某个位置使得 Leader 和 Follower 的日志达成一致。</p><p>第三阶段：Leader 等待 Followers 回应。</p><p>第四阶段：Leader 回应客户端。</p><p>第五阶段，Leader 通知 Followers Entry 已提交</p><p>Leader 回应客户端后，将随着下一个心跳通知 Followers，Followers 收到通知后也会将 Entry 标记为提交状态。至此，Raft 集群超过半数节点已经达到一致状态，可以确保强一致性。</p><h2 id="Raft-算法之安全性"><a href="#Raft-算法之安全性" class="headerlink" title="Raft 算法之安全性"></a>Raft 算法之安全性</h2><p>保证任何的 Leader 对于给定的任期号（Term），都拥有之前任期的所有被提交的日志条目</p><h3 id="选举限制"><a href="#选举限制" class="headerlink" title="选举限制"></a>选举限制</h3><p>日志条目的传送是单向的，只从 Leader 传给 Follower，并且 Leader 从不会覆盖自身本地日志中已经存在的条目。</p><p>比较新的可以赢得大多数投票。</p><h3 id="提交之前任期内的日志条目"><a href="#提交之前任期内的日志条目" class="headerlink" title="提交之前任期内的日志条目"></a>提交之前任期内的日志条目</h3><p>如果一个 Leader 在提交日志条目之前崩溃了，继任的 Leader 会继续尝试复制这条日志记录。但不能保证在Follower上的日志条目提交。</p><p>当 Leader 复制之前任期里的日志时，Raft 会为所有日志保留原始的任期号，这在提交规则上产生了额外的复杂性。但是，这种策略更加容易辨别出日志，即使随着时间和日志的变化，日志仍维护着同一个任期编号。此外，该策略使得新 Leader 只需要发送较少日志条目。</p><h1 id="Etcd"><a href="#Etcd" class="headerlink" title="Etcd"></a>Etcd</h1><p>Etcd 主要分为四个部分：HTTP Server、Store、Raft 以及 WAL。 </p><p>HTTP Server：用于处理客户端发送的 API 请求以及其它 Etcd 节点的同步与心跳信息请求。<br>Store：用于处理 Etcd 支持的各类功能的事务，包括数据索引、节点状态变更、监控与反馈、事件处理与执行等等，是 Etcd 对用户提供的大多数 API 功能的具体实现。<br>Raft：Raft 强一致性算法的具体实现，是 Etcd 的核心。<br>WAL：Write Ahead Log（预写式日志），是 Etcd 的数据存储方式。除了在内存中存有所有数据的状态以及节点的索引，Etcd 还通过 WAL 进行持久化存储。WAL 中，所有的数据提交前都会事先记录日志。Snapshot 是为了防止数据过多而进行的状态快照。Entry 表示存储的具体日志内容。  </p><p>一个用户的请求发送过来，会经由 HTTP Server 转发给 Store 进行具体的事务处理；如果涉及到节点的修改，则交给 Raft 模块进行状态的变更、日志的记录，然后再同步给别的 Etcd 节点以确认数据提交；最后进行数据的提交，再次同步。</p><p>Lease 机制：续约机制<br>Prefix 机制：即前缀机制，也称目录机制<br>Watch 机制：即监听机制，Watch 机制支持监听某个固定的 Key，也支持监听一个范围（前缀机制），当被监听的 Key 或范围发生变化，客户端将收到通知；<br>Revision 机制：每个 Key 带有一个 Revision 号，每进行一次事务便加一，因此它是全局唯一的</p><p>应用场景 1：服务发现<br>应用场景 2：消息发布和订阅<br>应用场景 3：分布式锁<br>Etcd 支持 Revision 机制，那么对于同一个 Lock，即便有多个客户端争夺（本质上就是 put(lockName, value) 操作），Revision 机制可以保证它们的 Revision 编号有序且唯一，那么，客户端只要根据 Revision 的大小顺序就可以确定获得锁的先后顺序，从而很容易实现“公平锁”。<br>应用场景4： 集群监控与 Leader 竞选</p><h2 id="基于-Etcd-的分布式锁业务流程"><a href="#基于-Etcd-的分布式锁业务流程" class="headerlink" title="基于 Etcd 的分布式锁业务流程"></a>基于 Etcd 的分布式锁业务流程</h2><h3 id="步骤1：准备"><a href="#步骤1：准备" class="headerlink" title="步骤1：准备"></a>步骤1：准备</h3><p>客户端连接 Etcd，以 /lock/mylock 为前缀创建全局唯一的 Key，假设第一个客户端对应的 Key=”/lock/mylock/UUID1”，第二个为 Key=”/lock/mylock/UUID2”；客户端分别为自己的 Key 创建租约 Lease，租约的长度根据业务耗时确定，假设为 15s。</p><h3 id="步骤2：创建定时任务作为租约的“心跳”"><a href="#步骤2：创建定时任务作为租约的“心跳”" class="headerlink" title="步骤2：创建定时任务作为租约的“心跳”"></a>步骤2：创建定时任务作为租约的“心跳”</h3><p>在一个客户端持有锁期间，其它客户端只能等待，为了避免等待期间租约失效，客户端需创建一个定时任务作为“心跳”进行续约。此外，如果持有锁期间客户端崩溃，心跳停止，Key 将因租约到期而被删除，从而锁释放，避免死锁。</p><h3 id="步骤3：客户端将自己全局唯一的-Key-写入-Etcd"><a href="#步骤3：客户端将自己全局唯一的-Key-写入-Etcd" class="headerlink" title="步骤3：客户端将自己全局唯一的 Key 写入 Etcd"></a>步骤3：客户端将自己全局唯一的 Key 写入 Etcd</h3><p>进行 Put 操作，将步骤 1 中创建的 Key 绑定租约写入 Etcd，根据 Etcd 的 Revision 机制，假设两个客户端 Put 操作返回的 Revision 分别为1、2，客户端需记录 Revision 用以接下来判断自己是否获得锁。</p><h3 id="步骤4：客户端判断是否获得锁"><a href="#步骤4：客户端判断是否获得锁" class="headerlink" title="步骤4：客户端判断是否获得锁"></a>步骤4：客户端判断是否获得锁</h3><p>客户端以前缀 /lock/mylock 读取 Key-Value 列表（Key-Value 中带有 Key 对应的 Revision），判断自己 Key 的 Revision 是否为当前列表中最小的，如果是则认为获得锁；否则监听列表中前一个 Revision 比自己小的 Key 的删除事件，一旦监听到删除事件或者因租约失效而删除的事件，则自己获得锁。 </p><h3 id="步骤5：执行业务"><a href="#步骤5：执行业务" class="headerlink" title="步骤5：执行业务"></a>步骤5：执行业务</h3><p>获得锁后，操作共享资源，执行业务代码。 </p><h3 id="步骤6：释放锁"><a href="#步骤6：释放锁" class="headerlink" title="步骤6：释放锁"></a>步骤6：释放锁</h3><p>完成业务流程后，删除对应的 Key 释放锁。</p><img src="/2020/11/30/分布式一致性算法Raft和Etcd/1.png">]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Raft&quot;&gt;&lt;a href=&quot;#Raft&quot; class=&quot;headerlink&quot; title=&quot;Raft&quot;&gt;&lt;/a&gt;Raft&lt;/h1&gt;&lt;h2 id=&quot;Raft角色&quot;&gt;&lt;a href=&quot;#Raft角色&quot; class=&quot;headerlink&quot; title=&quot;Raft角
      
    
    </summary>
    
      <category term="基础" scheme="http://twh233.github.io/categories/%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="分布式" scheme="http://twh233.github.io/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>Redis分布式</title>
    <link href="http://twh233.github.io/2020/11/25/Redis%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    <id>http://twh233.github.io/2020/11/25/Redis分布式/</id>
    <published>2020-11-25T13:43:01.000Z</published>
    <updated>2020-11-30T15:28:22.936Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Redis-Cluster特点"><a href="#Redis-Cluster特点" class="headerlink" title="Redis Cluster特点"></a>Redis Cluster特点</h2><p>节点互通：所有的 Redis 节点彼此互联（PING-PONG机制），内部使用二进制协议优化传输速度和带宽；  </p><p>去中心化：Redis Cluster 不存在中心节点，每个节点都记录有集群的状态信息，并且通过 Gossip 协议，使每个节点记录的信息实现最终一致性；</p><p>客户端直连：客户端与 Redis 节点直连，不需要中间 Proxy 层，客户端不需要连接集群所有节点，连接集群中任何一个可用节点即可；</p><p>数据分片：Redis Cluster 的键空间被分割为 16384 个 Slot，这些 Slot 被分别指派给主节点，当存储 Key-Value 时，根据 CRC16(key) Mod 16384的值，决定将一个 Key-Value 放到哪个 Slot 中；</p><p>多数派原则：对于集群中的任何一个节点，需要超过半数的节点检测到它失效（pFail），才会将其判定为失效（Fail）；</p><p>自动 Failover：当集群中某个主节点故障后（Fail），其它主节点会从故障主节点的从节点中选举一个“最佳”从节点升主，替代故障的主节点；</p><p>功能弱化：集群模式下，由于数据分布在多个节点，不支持单机模式下的集合操作，也不支持多数据库功能，集群只能使用默认的0号数据库；</p><p>集群规模：官方推荐的最大节点数量为 1000 个左右，这是因为当集群规模过大时，Gossip 协议的效率会显著下降，通信成本剧增。</p><h2 id="Redis-Cluster路由"><a href="#Redis-Cluster路由" class="headerlink" title="Redis Cluster路由"></a>Redis Cluster路由</h2><img src="/2020/11/25/Redis分布式/1.png"><p>在客户端缓存 Slot 与 Redis 节点的映射关系，当接收到 MOVED 响应时修改缓存中的映射关系。</p><h2 id="Gossip-在-Redis-Cluster-的作用"><a href="#Gossip-在-Redis-Cluster-的作用" class="headerlink" title="Gossip 在 Redis Cluster 的作用"></a>Gossip 在 Redis Cluster 的作用</h2><p>在分布式系统中，需要提供维护节点元数据信息的机制，所谓元数据是指节点负责哪些数据、主从属性、是否出现故障等状态信息。常见的元数据维护方式分为集中式和无中心式。Redis Cluster 采用 Gossip 协议实现了无中心式。</p><p>Meet 消息：用于通知新节点加入。消息发送者通知接收者加入到当前集群，Meet 消息通信正常完成后，接收节点会加入到集群中并进行周期性的 Ping、Pong 消息交换；<br>Ping 消息：集群内交换最频繁的消息，集群内每个节点每秒向多个其它节点发送 Ping 消息，用于检测节点是否在线和交换彼此状态信息。Ping 消息发送封装了自身节点和部分其它节点的状态数据；<br>Pong 消息：当接收到 Ping、Meet 消息时，作为响应消息回复给发送方确认消息正常通信。Pong 消息内部封装了自身状态数据。节点也可以向集群内广播自身的 Pong 消息来通知整个集群对自身状态进行更新；<br>Fail 消息：当节点判定集群内另一个节点下线时，会向集群内广播一个 Fail 消息，其他节点接收到 Fail 消息之后把对应节点更新为下线状态。</p><h2 id="故障转移"><a href="#故障转移" class="headerlink" title="故障转移"></a>故障转移</h2><p>发送Ping Pong消息，转到疑下线状态，再到传播消息，最后做半数以上统计的下线判决。</p><h2 id="投票"><a href="#投票" class="headerlink" title="投票"></a>投票</h2><p>如果一个主节点具有投票权（负责处理 Slot 的主节点)，并且这个主节点尚未投票给其它从节点，那么这个主节点将向请求投票的从节点返回一条回应消息，表示支持该从节点升主。</p><p>在同一轮选举中，只可能有一个从节点收到的票数大于 N/2 + 1。</p><p>接管Master结点后：<br>身份切换、接管职权、广而告之、履行义务</p><h2 id="其他分布式方案"><a href="#其他分布式方案" class="headerlink" title="其他分布式方案"></a>其他分布式方案</h2><h3 id="客户端分片"><a href="#客户端分片" class="headerlink" title="客户端分片"></a>客户端分片</h3><p>如下图所示，客户端与 Redis 节点直连，为了提高可用性，每个主节点挂一个从节点，故障倒换可由“哨兵”系统实现（其它方案也可实现）。客户端对任何一个主节点的读写操作本质上就是单机模式下的读写操作；对于一个 Key-Value，其读写节点完全由客户端决定。</p><p>缺点：1.不支持动态增加节点 2.不支持动态减少节点，原理同上 3.有业务逻辑与数据存储逻辑耦合，可运维性差</p><h3 id="基于代理的分片"><a href="#基于代理的分片" class="headerlink" title="基于代理的分片"></a>基于代理的分片</h3><p>中间层proxy </p><img src="/2020/11/25/Redis分布式/2.png"><h2 id="Redis集群可靠性"><a href="#Redis集群可靠性" class="headerlink" title="Redis集群可靠性"></a>Redis集群可靠性</h2><h3 id="问题一"><a href="#问题一" class="headerlink" title="问题一"></a>问题一</h3><p>三个物理节点，分别部署两个 redis-server，且交叉互为主备，这样做可以提高可靠性：如节点 1 宕机，主节点 A-M 对应的从节点 A-S 将发起投票，作为唯一的备节点，其必然升主成功，与 B-M、C-M 构成新的集群，继续提供服务，如下图所示：</p><img src="/2020/11/25/Redis分布式/3.png"><p>如果宕机的节点 1 经过修复重新上线，根据 Redis 集群原理，节点 1 上的 A-M 将意识到自己已经被替代，将降级为备，形成的集群拓扑结构如下：</p><img src="/2020/11/25/Redis分布式/4.png"><h3 id="问题二"><a href="#问题二" class="headerlink" title="问题二"></a>问题二</h3><p>如果节点 3 宕机，Redis 集群将只有一个主节点 C-M 存活，存活的主节点总数少于集群主节点总数的一半 （1&lt;3/2+1），集群无法自愈，不能继续提供服务。</p><p>为了解决这个问题，我们可以设计一个常驻守护进程对 Redis 集群的状态进行监控，当出现主-备状态不合理的情况（如节点 1 重新上线后的拓扑结构），守护进程主动发起主备倒换（clusterFailover），将节点 1 上的 A-S 升为主，节点 3 上的 A-M 降为备，如此，集群拓扑结构恢复正常，并且能够支持单节点故障。</p><img src="/2020/11/25/Redis分布式/5.png"><h3 id="问题三"><a href="#问题三" class="headerlink" title="问题三"></a>问题三</h3><p>如果节点 1 故障后无法修复，为了保障可靠性，通常会用一个新的节点来替换掉故障的节点——所谓故障替换。拓扑结构如下：</p><img src="/2020/11/25/Redis分布式/6.png"><p>将新节点上的两个 redis-server 纳入现有集群，通过 clusterMeet() 方法可以完成；<br>为新加入集群的两个 redis-server 设置主节点：节点 3 上的两个主 A-M 和 B-M 都没有对应的从节点，因此，可将新加入的两个 redis-server 分别设置为它们的从节点。  </p><img src="/2020/11/25/Redis分布式/7.png"><h2 id="基于-Lettuce-的-Redis-集群运维软件设计及实现"><a href="#基于-Lettuce-的-Redis-集群运维软件设计及实现" class="headerlink" title="基于 Lettuce 的 Redis 集群运维软件设计及实现"></a>基于 Lettuce 的 Redis 集群运维软件设计及实现</h2><img src="/2020/11/25/Redis分布式/8.png"><h2 id="Redis分布式锁实现"><a href="#Redis分布式锁实现" class="headerlink" title="Redis分布式锁实现"></a>Redis分布式锁实现</h2><p>分布式锁需同时满足以下四个约束条件</p><p>互斥性：在任意时刻，只有一个客户端能持有锁；<br>安全性：即不会形成死锁，当一个客户端在持有锁的期间崩溃而没有主动解锁的情况下，其持有的锁也能够被正确释放，并保证后续其它客户端能加锁；<br>可用性：就 Redis 而言，当提供锁服务的 Redis Master 节点发生宕机等不可恢复性故障时，Slave 节点能够升主并继续提供服务，支持客户端加锁和解锁；对基于分布式一致性算法实现的锁服务（如 ETCD）而言，当 Leader 节点宕机时，Follow 节点能够选举出新的 Leader 继续提供锁服务；<br>对称性：对于任意一个锁，其加锁和解锁必须是同一个客户端，即客户端 A 不能把客户端 B 加的锁给解了。  </p><h3 id="预防死锁"><a href="#预防死锁" class="headerlink" title="预防死锁"></a>预防死锁</h3><p>一个客户端获取锁成功，但是在释放锁之前崩溃了，此时该客户端实际上已经失去了对公共资源的操作权，但却没有办法请求解锁（删除 Key-Value 键值对），那么，它就会一直持有这个锁，而其它客户端永远无法获得锁。</p><p>在加锁时为锁设置过期时间</p><h3 id="设置锁自动过期时间以预防死锁存在的隐患"><a href="#设置锁自动过期时间以预防死锁存在的隐患" class="headerlink" title="设置锁自动过期时间以预防死锁存在的隐患"></a>设置锁自动过期时间以预防死锁存在的隐患</h3><p>1.客户端 A 恢复后，可以比较下目前已经持有锁的时间，如果发现已经过期，则放弃对共享资源的操作即可避免互斥性失效的问题。<br>2.既然比较时间不可取，那么，还可以比较 my_random_value，即客户端 A 恢复后，在操作共享资源前应比较目前自身所持有锁的 my_random_value 与 Redis 中存储的 my_random_value 是否一致，如果不相同，说明已经不再持有锁，则放弃对共享资源的操作以避免互斥性失效的问题。</p><h3 id="解锁操作的原子性"><a href="#解锁操作的原子性" class="headerlink" title="解锁操作的原子性"></a>解锁操作的原子性</h3><p>1.使用 Redis 事务功能，使用 Watch 命令监控锁对应的 Key，释放锁则采用事务功能（Multi 命令），如果持有的锁已经因过期而释放（或者过期释放后又被其它客户端持有），则 Key 对应的 Value 将改变，释放锁的事务将不会被执行，从而避免错误的释放锁，示例代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">Jedis jedis = new Jedis(&quot;127.0.0.1&quot;, 6379);</span><br><span class="line"></span><br><span class="line">// “自旋”，等待锁</span><br><span class="line">String result = null;</span><br><span class="line">while (true)</span><br><span class="line">&#123;</span><br><span class="line">    // 申请锁，只有当“lock_name”不存在时才能申请成功，返回“OK&quot;,锁的过期时间设置为5s</span><br><span class="line">    result = jedis.set(&quot;lock_name&quot;, &quot;my_random_value&quot;, SET_IF_NOT_EXIST,</span><br><span class="line">            SET_WITH_EXPIRE_TIME, 5000);</span><br><span class="line">    if (&quot;OK&quot;.equals(result))</span><br><span class="line">    &#123;</span><br><span class="line">        break;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 监控锁对应的 Key，如果其它的客户端对这个 Key 进行了更改，那么本次事务会被取消。</span><br><span class="line">jedis.watch(&quot;lock_name&quot;);</span><br><span class="line">// 成功获取锁，则操作公共资源，自定义流程</span><br><span class="line">// to do something...</span><br><span class="line"></span><br><span class="line">// 释放锁之前，校验是否持有锁</span><br><span class="line">if (jedis.get(&quot;lock_name&quot;).equals(&quot;my_random_value&quot;))</span><br><span class="line">&#123;</span><br><span class="line">    // 开启事务功能，</span><br><span class="line">    Transaction multi = jedis.multi();</span><br><span class="line">    // 模拟客户端阻塞10s，锁超时，自动清除</span><br><span class="line">    try</span><br><span class="line">    &#123;</span><br><span class="line">        Thread.sleep(5000);</span><br><span class="line">    &#125;</span><br><span class="line">    catch (InterruptedException e)</span><br><span class="line">    &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    // 客户端恢复，继续释放锁</span><br><span class="line">    multi.del(&quot;lock_name&quot;);</span><br><span class="line">    // 执行事务（如果其它的客户端对这个Key进行了更改，那么本次事务会被取消,不会执行)</span><br><span class="line">    multi.exec();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 释放资源</span><br><span class="line">jedis.unwatch();</span><br><span class="line">jedis.close();</span><br></pre></td></tr></table></figure><p>2.使用 Lua 脚本实现锁校验与释放，并使用 Redis 的 eval 函数执行 Lua 脚本</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">Jedis jedis = new Jedis(&quot;127.0.0.1&quot;, 6379);</span><br><span class="line"></span><br><span class="line">// “自旋”，等待锁</span><br><span class="line">String result = null;</span><br><span class="line">while (true)</span><br><span class="line">&#123;</span><br><span class="line">    // 申请锁，只有当“lock_name”不存在时才能申请成功，返回“OK&quot;，锁的过期时间设置为 5s</span><br><span class="line">    result = jedis.set(&quot;lock_name&quot;, &quot;my_random_value&quot;, SET_IF_NOT_EXIST,</span><br><span class="line">            SET_WITH_EXPIRE_TIME, 5000);</span><br><span class="line">    if (&quot;OK&quot;.equals(result))</span><br><span class="line">    &#123;</span><br><span class="line">        break;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">// 成功获取锁，则操作公共资源，自定义流程</span><br><span class="line">// to do something...</span><br><span class="line"></span><br><span class="line">// Lua脚本，用于校验并释放锁     </span><br><span class="line">String script = &quot;if redis.call(&apos;get&apos;, KEYS[1]) == ARGV[1] then return redis.call(&apos;del&apos;, KEYS[1]) else return 0 end&quot;;</span><br><span class="line">try</span><br><span class="line">&#123;</span><br><span class="line">    // 模拟客户端阻塞10s，锁超时，自动清除</span><br><span class="line">    Thread.sleep(10000);</span><br><span class="line">&#125;</span><br><span class="line">catch (InterruptedException e)</span><br><span class="line">&#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 执行Lua脚本，校验并释放锁</span><br><span class="line">jedis.eval(script, Collections.singletonList(&quot;lock_name&quot;),</span><br><span class="line">        Collections.singletonList(&quot;my_random_value&quot;));</span><br><span class="line"></span><br><span class="line">jedis.close();</span><br></pre></td></tr></table></figure><h3 id="Redis-节点故障后，主备切换的数据一致性"><a href="#Redis-节点故障后，主备切换的数据一致性" class="headerlink" title="Redis 节点故障后，主备切换的数据一致性"></a>Redis 节点故障后，主备切换的数据一致性</h3><p>客户端 A 从 Master 获取了锁；<br>Master 宕机了，存储锁的 Key 还没有来得及同步到 Slave 上；<br>Slave 升级为 Master；<br>客户端 B 从新的 Master 获取到了对应同一个资源的锁；<br>客户端 A 和客户端 B 同时持有了同一个资源的锁，锁的安全性被打破。</p><p>方案1：还是使用my_random_value</p><p>方案2：RedLock</p><p>运行 Redlock 算法的客户端依次执行以下步骤，来进行加锁的操作：<br>1.获取当前系统时间（毫秒数）。<br>2.按顺序依次向 N 个 Redis 节点执行获取锁的操作。这个获取操作跟前面基于单 Redis 节点获取锁的过程相同，包含随机字符串 my_random_value，也包含过期时间（比如 PX 30000，即锁的有效时间）。为了保证在某个 Redis 节点不可用的时候算法能够继续运行，这个获取锁的操作还有一个超时时间（Time Out），它要远小于锁的有效时间（几十毫秒量级）。客户端在向某个 Redis 节点获取锁失败以后，应该立即尝试下一个 Redis 节点。这里的失败，应该包含任何类型的失败，比如该 Redis 节点不可用。<br>3.计算获取锁的整个过程总共消耗了多长时间，计算方法是用当前时间减去第 1 步记录的时间。如果客户端从大多数 Redis 节点（&gt;=N/2+1）成功获取到了锁，并且获取锁总共消耗的时间没有超过锁的有效时间（Lock Validity Time），那么这时客户端才认为最终获取锁成功；否则，认为最终获取锁失败。<br>4.如果最终获取锁成功了，那么这个锁的有效时间应该重新计算，它等于最初的锁的有效时间减去第 3 步计算出来的获取锁消耗的时间。<br>5.如果最终获取锁失败了（可能由于获取到锁的 Redis 节点个数少于 N/2+1，或者整个获取锁的过程消耗的时间超过了锁的最初有效时间），那么客户端应该立即向所有 Redis 节点发起释放锁的操作（即前面介绍的 Redis Lua 脚本）。  </p><h3 id="典型错误案例"><a href="#典型错误案例" class="headerlink" title="典型错误案例"></a>典型错误案例</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public static void lock(JedisPool jedisPool, String lockName, String myRandomValue, int expireTime) </span><br><span class="line">    &#123;</span><br><span class="line">        Jedis jedis = jedisPool.getResource();</span><br><span class="line">        // 如果锁不存在，则加锁</span><br><span class="line">        Long result = jedis.setnx(lockName, myRandomValue);</span><br><span class="line">        if (result == 1) </span><br><span class="line">        &#123;</span><br><span class="line">            // 为锁设置过期时间，由于加锁和设置过期时间是两步完成的，非原子操作</span><br><span class="line">            jedis.expire(lockName, expireTime);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Redis-Cluster特点&quot;&gt;&lt;a href=&quot;#Redis-Cluster特点&quot; class=&quot;headerlink&quot; title=&quot;Redis Cluster特点&quot;&gt;&lt;/a&gt;Redis Cluster特点&lt;/h2&gt;&lt;p&gt;节点互通：所有的 Redis 节点彼
      
    
    </summary>
    
      <category term="基础" scheme="http://twh233.github.io/categories/%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="redis" scheme="http://twh233.github.io/tags/redis/"/>
    
      <category term="分布式" scheme="http://twh233.github.io/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>try/catch实现</title>
    <link href="http://twh233.github.io/2020/11/24/try-catch%E5%AE%9E%E7%8E%B0/"/>
    <id>http://twh233.github.io/2020/11/24/try-catch实现/</id>
    <published>2020-11-24T14:08:11.000Z</published>
    <updated>2020-11-24T14:15:26.842Z</updated>
    
    <content type="html"><![CDATA[<p>大体是通过setjmp，longjmp 跨越函数的跳动。</p><p>原理类似if else，但要解决try catch嵌套问题，引入栈空间。</p><p>每个结点存有上一个结点的地址，用链表串起来。</p><p>通过pthread_setspecific，pthread_getspecific 保存当前空间私有信息。解决线程同步的问题。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line"></span><br><span class="line">#include &lt;stdarg.h&gt;</span><br><span class="line"></span><br><span class="line">#include &lt;pthread.h&gt;</span><br><span class="line">#include &lt;setjmp.h&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#define ntyThreadDatapthread_key_t</span><br><span class="line">#define ntyThreadDataSet(key, value)pthread_setspecific((key), (value))</span><br><span class="line">#define ntyThreadDataGet(key)pthread_getspecific((key))</span><br><span class="line">#define ntyThreadDataCreate(key)pthread_key_create(&amp;(key), NULL)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#define EXCEPTIN_MESSAGE_LENGTH512</span><br><span class="line"></span><br><span class="line">typedef struct _ntyException &#123;</span><br><span class="line">const char *name;</span><br><span class="line">&#125; ntyException; </span><br><span class="line"></span><br><span class="line">ntyException SQLException = &#123;&quot;SQLException&quot;&#125;;</span><br><span class="line">ntyException TimeoutException = &#123;&quot;TimeoutException&quot;&#125;;</span><br><span class="line"></span><br><span class="line">ntyThreadData ExceptionStack;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">typedef struct _ntyExceptionFrame &#123;</span><br><span class="line">jmp_buf env;</span><br><span class="line"></span><br><span class="line">int line;</span><br><span class="line">const char *func;</span><br><span class="line">const char *file;</span><br><span class="line"></span><br><span class="line">ntyException *exception;</span><br><span class="line">struct _ntyExceptionFrame *prev;</span><br><span class="line"></span><br><span class="line">char message[EXCEPTIN_MESSAGE_LENGTH+1];</span><br><span class="line"></span><br><span class="line">&#125; ntyExceptionFrame;</span><br><span class="line"></span><br><span class="line">#define ntyExceptionPopStack\</span><br><span class="line">ntyThreadDataSet(ExceptionStack, ((ntyExceptionFrame*)ntyThreadDataGet(ExceptionStack))-&gt;prev)</span><br><span class="line"></span><br><span class="line">#define ReThrowntyExceptionThrow(frame.exception, frame.func, frame.file, frame.line, NULL)</span><br><span class="line">#define Throw(e, cause, ...) ntyExceptionThrow(&amp;(e), __func__, __FILE__, __LINE__, cause, ##__VA_ARGS__, NULL)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">enum &#123;</span><br><span class="line">ExceptionEntered = 0,</span><br><span class="line">ExceptionThrown,</span><br><span class="line">ExceptionHandled,</span><br><span class="line">ExceptionFinalized</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#define Try do &#123;\</span><br><span class="line">volatile int Exception_flag;\</span><br><span class="line">ntyExceptionFrame frame;\</span><br><span class="line">frame.message[0] = 0;\</span><br><span class="line">frame.prev = (ntyExceptionFrame*)ntyThreadDataGet(ExceptionStack);\</span><br><span class="line">ntyThreadDataSet(ExceptionStack, &amp;frame);\</span><br><span class="line">Exception_flag = setjmp(frame.env);\</span><br><span class="line">if (Exception_flag == ExceptionEntered) &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#define Catch(e) \</span><br><span class="line">if (Exception_flag == ExceptionEntered) ntyExceptionPopStack; \</span><br><span class="line">&#125; else if (frame.exception == &amp;(e)) &#123; \</span><br><span class="line">Exception_flag = ExceptionHandled;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#define Finally \</span><br><span class="line">if (Exception_flag == ExceptionEntered) ntyExceptionPopStack; \</span><br><span class="line">&#125; &#123; \</span><br><span class="line">if (Exception_flag == ExceptionEntered)\</span><br><span class="line">Exception_flag = ExceptionFinalized; </span><br><span class="line"></span><br><span class="line">#define EndTry \</span><br><span class="line">if (Exception_flag == ExceptionEntered) ntyExceptionPopStack; \</span><br><span class="line">&#125; if (Exception_flag == ExceptionThrown) ReThrow; \</span><br><span class="line">        &#125; while (0)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">static pthread_once_t once_control = PTHREAD_ONCE_INIT;</span><br><span class="line"></span><br><span class="line">static void init_once(void) &#123; </span><br><span class="line">ntyThreadDataCreate(ExceptionStack); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">void ntyExceptionInit(void) &#123;</span><br><span class="line">pthread_once(&amp;once_control, init_once);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">void ntyExceptionThrow(ntyException *excep, const char *func, const char *file, int line, const char *cause, ...) &#123;</span><br><span class="line"></span><br><span class="line">va_list ap;</span><br><span class="line">ntyExceptionFrame *frame = (ntyExceptionFrame*)ntyThreadDataGet(ExceptionStack);</span><br><span class="line"></span><br><span class="line">if (frame) &#123;</span><br><span class="line"></span><br><span class="line">frame-&gt;exception = excep;</span><br><span class="line">frame-&gt;func = func;</span><br><span class="line">frame-&gt;file = file;</span><br><span class="line">frame-&gt;line = line;</span><br><span class="line"></span><br><span class="line">if (cause) &#123;</span><br><span class="line">va_start(ap, cause);</span><br><span class="line">vsnprintf(frame-&gt;message, EXCEPTIN_MESSAGE_LENGTH, cause, ap);</span><br><span class="line">va_end(ap);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ntyExceptionPopStack;</span><br><span class="line"></span><br><span class="line">longjmp(frame-&gt;env, ExceptionThrown);</span><br><span class="line"></span><br><span class="line">&#125; else if (cause) &#123;</span><br><span class="line"></span><br><span class="line">char message[EXCEPTIN_MESSAGE_LENGTH+1];</span><br><span class="line"></span><br><span class="line">va_start(ap, cause);</span><br><span class="line">vsnprintf(message, EXCEPTIN_MESSAGE_LENGTH, cause, ap);</span><br><span class="line">va_end(ap);</span><br><span class="line"></span><br><span class="line">printf(&quot;%s: %s\n raised in %s at %s:%d\n&quot;, excep-&gt;name, message, func ? func : &quot;?&quot;, file ? file : &quot;?&quot;, line);</span><br><span class="line"></span><br><span class="line">&#125; else &#123;</span><br><span class="line"></span><br><span class="line">printf(&quot;%s: %p\n raised in %s at %s:%d\n&quot;, excep-&gt;name, excep, func ? func : &quot;?&quot;, file ? file : &quot;?&quot;, line);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">/* ** **** ******** **************** debug **************** ******** **** ** */</span><br><span class="line"></span><br><span class="line">ntyException A = &#123;&quot;AException&quot;&#125;;</span><br><span class="line">ntyException B = &#123;&quot;BException&quot;&#125;;</span><br><span class="line">ntyException C = &#123;&quot;CException&quot;&#125;;</span><br><span class="line">ntyException D = &#123;&quot;DException&quot;&#125;;</span><br><span class="line"></span><br><span class="line">void *thread(void *args) &#123;</span><br><span class="line"></span><br><span class="line">pthread_t selfid = pthread_self();</span><br><span class="line"></span><br><span class="line">Try &#123;</span><br><span class="line"></span><br><span class="line">Throw(A, &quot;A&quot;);</span><br><span class="line"></span><br><span class="line">&#125; Catch (A) &#123;</span><br><span class="line"></span><br><span class="line">printf(&quot;catch A : %ld\n&quot;, selfid);</span><br><span class="line"></span><br><span class="line">&#125; EndTry;</span><br><span class="line"></span><br><span class="line">Try &#123;</span><br><span class="line"></span><br><span class="line">Throw(B, &quot;B&quot;);</span><br><span class="line"></span><br><span class="line">&#125; Catch (B) &#123;</span><br><span class="line"></span><br><span class="line">printf(&quot;catch B : %ld\n&quot;, selfid);</span><br><span class="line"></span><br><span class="line">&#125; EndTry;</span><br><span class="line"></span><br><span class="line">Try &#123;</span><br><span class="line"></span><br><span class="line">Throw(C, &quot;C&quot;);</span><br><span class="line"></span><br><span class="line">&#125; Catch (C) &#123;</span><br><span class="line"></span><br><span class="line">printf(&quot;catch C : %ld\n&quot;, selfid);</span><br><span class="line"></span><br><span class="line">&#125; EndTry;</span><br><span class="line"></span><br><span class="line">Try &#123;</span><br><span class="line"></span><br><span class="line">Throw(D, &quot;D&quot;);</span><br><span class="line"></span><br><span class="line">&#125; Catch (D) &#123;</span><br><span class="line"></span><br><span class="line">printf(&quot;catch D : %ld\n&quot;, selfid);</span><br><span class="line"></span><br><span class="line">&#125; EndTry;</span><br><span class="line"></span><br><span class="line">Try &#123;</span><br><span class="line"></span><br><span class="line">Throw(A, &quot;A Again&quot;);</span><br><span class="line">Throw(B, &quot;B Again&quot;);</span><br><span class="line">Throw(C, &quot;C Again&quot;);</span><br><span class="line">Throw(D, &quot;D Again&quot;);</span><br><span class="line"></span><br><span class="line">&#125; Catch (A) &#123;</span><br><span class="line"></span><br><span class="line">printf(&quot;catch A again : %ld\n&quot;, selfid);</span><br><span class="line"></span><br><span class="line">&#125; Catch (B) &#123;</span><br><span class="line"></span><br><span class="line">printf(&quot;catch B again : %ld\n&quot;, selfid);</span><br><span class="line"></span><br><span class="line">&#125; Catch (C) &#123;</span><br><span class="line"></span><br><span class="line">printf(&quot;catch C again : %ld\n&quot;, selfid);</span><br><span class="line"></span><br><span class="line">&#125; Catch (D) &#123;</span><br><span class="line"></span><br><span class="line">printf(&quot;catch B again : %ld\n&quot;, selfid);</span><br><span class="line"></span><br><span class="line">&#125; EndTry;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#define THREADS50</span><br><span class="line"></span><br><span class="line">int main(void) &#123;</span><br><span class="line"></span><br><span class="line">ntyExceptionInit();</span><br><span class="line"></span><br><span class="line">Throw(D, NULL);</span><br><span class="line"></span><br><span class="line">Throw(C, &quot;null C&quot;);</span><br><span class="line"></span><br><span class="line">printf(&quot;\n\n=&gt; Test1: Try-Catch\n&quot;);</span><br><span class="line"></span><br><span class="line">Try &#123;</span><br><span class="line"></span><br><span class="line">Try &#123;</span><br><span class="line">Throw(B, &quot;recall B&quot;);</span><br><span class="line">&#125; Catch (B) &#123;</span><br><span class="line">printf(&quot;recall B \n&quot;);</span><br><span class="line">&#125; EndTry;</span><br><span class="line"></span><br><span class="line">Throw(A, NULL);</span><br><span class="line"></span><br><span class="line">&#125; Catch(A) &#123;</span><br><span class="line"></span><br><span class="line">printf(&quot;\tResult: Ok\n&quot;);</span><br><span class="line"></span><br><span class="line">&#125; EndTry;</span><br><span class="line"></span><br><span class="line">printf(&quot;=&gt; Test1: Ok\n\n&quot;);</span><br><span class="line"></span><br><span class="line">printf(&quot;=&gt; Test2: Test Thread-safeness\n&quot;);</span><br><span class="line">#if 1</span><br><span class="line">int i = 0;</span><br><span class="line">pthread_t threads[THREADS];</span><br><span class="line"></span><br><span class="line">for (i = 0;i &lt; THREADS;i ++) &#123;</span><br><span class="line">pthread_create(&amp;threads[i], NULL, thread, NULL);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">for (i = 0;i &lt; THREADS;i ++) &#123;</span><br><span class="line">pthread_join(threads[i], NULL);</span><br><span class="line">&#125;</span><br><span class="line">#endif</span><br><span class="line">printf(&quot;=&gt; Test2: Ok\n\n&quot;);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;大体是通过setjmp，longjmp 跨越函数的跳动。&lt;/p&gt;
&lt;p&gt;原理类似if else，但要解决try catch嵌套问题，引入栈空间。&lt;/p&gt;
&lt;p&gt;每个结点存有上一个结点的地址，用链表串起来。&lt;/p&gt;
&lt;p&gt;通过pthread_setspecific，pthre
      
    
    </summary>
    
      <category term="基础" scheme="http://twh233.github.io/categories/%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="基础" scheme="http://twh233.github.io/tags/%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>rpc应用和原理</title>
    <link href="http://twh233.github.io/2020/11/23/rpc%E5%BA%94%E7%94%A8%E5%92%8C%E5%8E%9F%E7%90%86/"/>
    <id>http://twh233.github.io/2020/11/23/rpc应用和原理/</id>
    <published>2020-11-23T15:21:37.000Z</published>
    <updated>2020-11-23T15:29:49.778Z</updated>
    
    <content type="html"><![CDATA[<img src="/2020/11/23/rpc应用和原理/1.png"><p>rpc是实现图中RPC协议部分。</p><img src="/2020/11/23/rpc应用和原理/2.png"><p>等于是把接口写在存根里，然后通过同步或者异步的方式去调用对端的接口。这样做等于封装了框架，业务逻辑不用再管协议层，通过rpc来解决协议对接问题。</p><p>服务寻址可以使用 Call ID 映射，在 RPC 中，所有的函数都必须有自己的一个 ID 。<br>因为在本地调用中，函数体是直接通过函数指针来指定的，但是在远程调用中，函数指针是不<br>行的，因为两个进程的地址空间是完全不一样的。</p><p>客户端在做远程过程调用时，必须附上这个 ID。然后我们还需要在客户端和服务端分别维护一<br>个函数和Call ID的对应表。<br>当客户端需要进行远程调用时，它就查一下这个表，找出相应的 Call ID，然后把它传给服务端，<br>服务端也通过查表，来确定客户端需要调用的函数，然后执行相应函数的代码。</p><h2 id="使用rpc还有哪些问题要解决"><a href="#使用rpc还有哪些问题要解决" class="headerlink" title="使用rpc还有哪些问题要解决"></a>使用rpc还有哪些问题要解决</h2><ol><li><p>调用超时处理</p></li><li><p>单向调用（只send）</p></li><li><p>幂等问题</p><p> 一端数据丢失，给另一端多次发送请求。另一端只处理一次</p></li><li><p>反向调用（Nat穿越）</p> <img src="/2020/11/23/rpc应用和原理/3.png"><p> (1 客户机A1、B1顺利通过各自网关访问服务器C ，均没有问题（类似于登录）<br> (2 服务器C保存了 A1、B1各自在其网关的信息（1.2.3.4:62000、1.2.3.5:31000）没有问题。并可将该信息告知A1、B2。<br> (3 此时A1发送给B1网关的1.2.3.5:31000是否会被B1收到？答案是基本上不行（除非Y1设置为完全圆锥型，但这种设置非常少），因为Y1上检测到其存活的会话中没有一个的目的IP或端口与1.2.3.4:62000有关而将数据包全部丢弃！<br> (4 此时要实现A1、B1通过X1、Y1来互访，需要服务器C告诉它们各自在自己的网关上建立“UDP隧道”，即命令A1发送一个 192.168.0.8:4000——1.2.3.5:31000的数据报，B1发送一个192.168.1.8:4000——1.2.3.4:62000的数据报，UDP形式，这样X1、Y1上均存在了IP端口相同的两个不同会话（很显然，这要求网关为Cone NAT型–地址限制锥型或端口限制锥型），否则，对称型Symmetric NAT设置网关将导致对不同会话开启了不同端口，而该端口无法为服务器和对方所知，也就没有意义）。<br> (5 此时A1发给Y1，或者B1发给X1的数据报将不会被丢弃且正确的被对方收到.</p><p> 综合P2P可实现的条件需要：</p><p> 1、 中间服务器保存信息、并能发出建立UDP隧道的命令</p><p> 2、 网关均要求为Cone NAT类型。Symmetric NAT不适合。</p><p> 3、 完全圆锥型网关可以无需建立udp隧道，但这种情况非常少，要求双方均为这种类型网关的更少。</p><p> 4、 假如X1网关为Symmetric NAT， Y1为Address Restricted Cone NAT 或Full Cone NAT型网关，各自建立隧道后，A1可通过X1发送数据报给Y1到B1(因为Y1最多只进行IP级别的甄别)，但B1发送给X1的将会被丢弃（因为发送来的数据报中端口与X1上存在会话的端口不一致，虽然IP地址一致），所以同样没有什么意义。</p><p> 5、 假如双方均为Symmetric NAT的情形，新开了端口，对方可以在不知道的情况下尝试猜解，也可以达到目的，但这种情形成功率很低，且带来额外的系统开支，不是个好的解决办法。</p><p> 6、 不同网关型设置的差异在于，对内会采用替换IP的方式、使用不同端口不同会话的方式，使用相同端口不同会话的方式；对外会采用什么都不限制、限制IP地址、限制IP地址及端口。</p></li><li><p>MQ异步</p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;img src=&quot;/2020/11/23/rpc应用和原理/1.png&quot;&gt;
&lt;p&gt;rpc是实现图中RPC协议部分。&lt;/p&gt;
&lt;img src=&quot;/2020/11/23/rpc应用和原理/2.png&quot;&gt;
&lt;p&gt;等于是把接口写在存根里，然后通过同步或者异步的方式去调用对端的接口。这
      
    
    </summary>
    
      <category term="协议层" scheme="http://twh233.github.io/categories/%E5%8D%8F%E8%AE%AE%E5%B1%82/"/>
    
    
      <category term="rpc" scheme="http://twh233.github.io/tags/rpc/"/>
    
  </entry>
  
  <entry>
    <title>Redis/Mysql 连接池</title>
    <link href="http://twh233.github.io/2020/11/22/Redis-Mysql-%E8%BF%9E%E6%8E%A5%E6%B1%A0/"/>
    <id>http://twh233.github.io/2020/11/22/Redis-Mysql-连接池/</id>
    <published>2020-11-22T10:01:35.000Z</published>
    <updated>2020-11-22T11:54:12.797Z</updated>
    
    <content type="html"><![CDATA[<h2 id="为什么需要数据库连接池"><a href="#为什么需要数据库连接池" class="headerlink" title="为什么需要数据库连接池"></a>为什么需要数据库连接池</h2><img src="/2020/11/22/Redis-Mysql-连接池/1.png"><img src="/2020/11/22/Redis-Mysql-连接池/2.png"><h2 id="好处"><a href="#好处" class="headerlink" title="好处"></a>好处</h2><img src="/2020/11/22/Redis-Mysql-连接池/3.png"><p>做法，参考线程池</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;为什么需要数据库连接池&quot;&gt;&lt;a href=&quot;#为什么需要数据库连接池&quot; class=&quot;headerlink&quot; title=&quot;为什么需要数据库连接池&quot;&gt;&lt;/a&gt;为什么需要数据库连接池&lt;/h2&gt;&lt;img src=&quot;/2020/11/22/Redis-Mysql-连接池
      
    
    </summary>
    
      <category term="基础" scheme="http://twh233.github.io/categories/%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="连接池" scheme="http://twh233.github.io/tags/%E8%BF%9E%E6%8E%A5%E6%B1%A0/"/>
    
  </entry>
  
  <entry>
    <title>协程设计原理与实现</title>
    <link href="http://twh233.github.io/2020/11/22/%E5%8D%8F%E7%A8%8B%E8%AE%BE%E8%AE%A1%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E7%8E%B0/"/>
    <id>http://twh233.github.io/2020/11/22/协程设计原理与实现/</id>
    <published>2020-11-22T08:01:16.000Z</published>
    <updated>2020-11-22T09:48:41.984Z</updated>
    
    <content type="html"><![CDATA[<h2 id="同步-异步与协程有什么关系？"><a href="#同步-异步与协程有什么关系？" class="headerlink" title="同步/异步与协程有什么关系？"></a>同步/异步与协程有什么关系？</h2><p>同步编程方式，更加的直观。但性能不高。</p><p>目的就是以同步的编程方式，有异步的性能。</p><h2 id="如何实现？"><a href="#如何实现？" class="headerlink" title="如何实现？"></a>如何实现？</h2><p>当我们需要异步调用的时候，我们会创建一个协程。比如 accept 返回一个新的sockfd，创建一个客户端处理的子过程。再比如需要监听多个端口的时候，创建一个 server的子过程，这样多个端口同时工作的，是符合微服务的架构的。</p><h3 id="实现IO异步操作"><a href="#实现IO异步操作" class="headerlink" title="实现IO异步操作"></a>实现IO异步操作</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">while (1) &#123;</span><br><span class="line"> int nready = epoll_wait(epfd, events, EVENT_SIZE, -1);</span><br><span class="line"> for (i = 0;i &lt; nready;i ++) &#123;</span><br><span class="line"> int sockfd = events[i].data.fd;</span><br><span class="line"> if (sockfd == listenfd) &#123;</span><br><span class="line"> int connfd = accept(listenfd, xxx, xxxx);</span><br><span class="line"></span><br><span class="line"> setnonblock(connfd);</span><br><span class="line"> ev.events = EPOLLIN | EPOLLET;</span><br><span class="line"> ev.data.fd = connfd;</span><br><span class="line"> epoll_ctl(epfd, EPOLL_CTL_ADD, connfd, &amp;ev);</span><br><span class="line">  &#125; else &#123;</span><br><span class="line"></span><br><span class="line"> epoll_ctl(epfd, EPOLL_CTL_DEL, sockfd, NULL);</span><br><span class="line"> recv(sockfd, buffer, length, 0);</span><br><span class="line"> //parser_proto(buffer, length);</span><br><span class="line"> send(sockfd, buffer, length, 0);</span><br><span class="line"> epoll_ctl(epfd, EPOLL_CTL_ADD, sockfd, NULL);</span><br><span class="line"> &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>能够保证 sockfd 只在一个上下文中能够操作 IO 的。不会出现在多个上下文同时对一个 IO 进行操作的。协程的 IO 异步操作正式是采用此模式进行的。</p><img src="/2020/11/22/协程设计原理与实现/1.png"><h3 id="切换"><a href="#切换" class="headerlink" title="切换"></a>切换</h3><p>上下文通过保存CPU寄存器状态，并切换到下个CPU寄存器状态来实现。</p><img src="/2020/11/22/协程设计原理与实现/2.png"><p>底层是汇编代码</p><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><ol><li>运行体 R：包含运行状态{就绪，睡眠，等待}，运行体回调函数，<br>回调参数，栈指针，栈大小，当前运行体</li><li>调度器 S：包含执行集合{就绪，睡眠，等待}</li></ol><p>本身在使用协程的时候是创建协程，但内部是创建了一个R，需要上层S调度。</p><p>协程定义:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">typedef struct _nty_coroutine &#123;</span><br><span class="line">nty_cpu_ctx ctx;</span><br><span class="line">proc_coroutine func;</span><br><span class="line">void *arg;</span><br><span class="line">size_t stack_size;</span><br><span class="line">nty_coroutine_status status;</span><br><span class="line">nty_schedule *sched;</span><br><span class="line">uint64_t birth;</span><br><span class="line">uint64_t id;</span><br><span class="line">void *stack;</span><br><span class="line">RB_ENTRY(_nty_coroutine) sleep_node;</span><br><span class="line">RB_ENTRY(_nty_coroutine) wait_node;</span><br><span class="line">TAILQ_ENTRY(_nty_coroutine) ready_next;</span><br><span class="line">TAILQ_ENTRY(_nty_coroutine) defer_next;</span><br><span class="line">&#125; nty_coroutine;</span><br></pre></td></tr></table></figure></p><p>调度器定义:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">typedef struct _nty_coroutine_queue nty_coroutine_queue;</span><br><span class="line">typedef struct _nty_coroutine_rbtree_sleep nty_coroutine_rbtree_sleep;</span><br><span class="line">typedef struct _nty_coroutine_rbtree_wait nty_coroutine_rbtree_wait;</span><br><span class="line">typedef struct _nty_schedule &#123;</span><br><span class="line">uint64_t birth;</span><br><span class="line">nty_cpu_ctx ctx;</span><br><span class="line">struct _nty_coroutine *curr_thread;</span><br><span class="line">int page_size;</span><br><span class="line">int poller_fd;</span><br><span class="line">int eventfd;</span><br><span class="line">struct epoll_event eventlist[NTY_CO_MAX_EVENTS];</span><br><span class="line">int nevents;</span><br><span class="line">int num_new_events;</span><br><span class="line">nty_coroutine_queue ready;</span><br><span class="line">nty_coroutine_rbtree_sleep sleeping;</span><br><span class="line">nty_coroutine_rbtree_wait waiting;</span><br><span class="line">&#125; nty_schedule;</span><br></pre></td></tr></table></figure></p><h3 id="调度器"><a href="#调度器" class="headerlink" title="调度器"></a>调度器</h3><ol><li>生产者消费者模式</li></ol><img src="/2020/11/22/协程设计原理与实现/3.png"><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">while (1) &#123;</span><br><span class="line">//遍历睡眠集合，将满足条件的加入到 ready</span><br><span class="line"> nty_coroutine *expired = NULL;</span><br><span class="line"> while ((expired = sleep_tree_expired(sched)) != ) &#123;</span><br><span class="line">TAILQ_ADD(&amp;sched-&gt;ready, expired);</span><br><span class="line"> &#125;</span><br><span class="line"> //遍历等待集合，将满足添加的加入到 ready</span><br><span class="line"> nty_coroutine *wait = NULL;</span><br><span class="line"> int nready = epoll_wait(sched-&gt;epfd, events, EVENT_MAX, 1);</span><br><span class="line"> for (i = 0;i &lt; nready;i ++) &#123;</span><br><span class="line"> wait = wait_tree_search(events[i].data.fd);</span><br><span class="line"> TAILQ_ADD(&amp;sched-&gt;ready, wait);</span><br><span class="line"> &#125;</span><br><span class="line"> // 使用 resume 回复 ready 的协程运行权</span><br><span class="line"> while (!TAILQ_EMPTY(&amp;sched-&gt;ready)) &#123;</span><br><span class="line"> nty_coroutine *ready = TAILQ_POP(sched-&gt;ready);</span><br><span class="line"> resume(ready);</span><br><span class="line"> &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>多状态运行模式 </li></ol><img src="/2020/11/22/协程设计原理与实现/4.png"><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">while (1) &#123;</span><br><span class="line"> //遍历睡眠集合，使用 resume 恢复 expired 的协程运行权</span><br><span class="line"> nty_coroutine *expired = NULL;</span><br><span class="line"> while ((expired = sleep_tree_expired(sched)) != ) &#123;</span><br><span class="line">resume(expired);</span><br><span class="line"> &#125;</span><br><span class="line"> //遍历等待集合，使用 resume 恢复 wait 的协程运行权</span><br><span class="line"> nty_coroutine *wait = NULL;</span><br><span class="line"> int nready = epoll_wait(sched-&gt;epfd, events, EVENT_MAX, 1);</span><br><span class="line"> for (i = 0;i &lt; nready;i ++) &#123;</span><br><span class="line"> wait = wait_tree_search(events[i].data.fd);</span><br><span class="line">resume(wait);</span><br><span class="line"> &#125;</span><br><span class="line"> // 使用 resume 恢复 ready 的协程运行权</span><br><span class="line"> while (!TAILQ_EMPTY(sched-&gt;ready)) &#123;</span><br><span class="line"> nty_coroutine *ready = TAILQ_POP(sched-&gt;ready);</span><br><span class="line"> resume(ready);</span><br><span class="line"> &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>如果没有一个协程，调度器没有任何意义，空转。</p><p>如果只有一个协程，会在init的时候把这个状态直接改成就绪。</p><h2 id="多核开发"><a href="#多核开发" class="headerlink" title="多核开发"></a>多核开发</h2><ol><li><p>借助线程</p><p> 所有线程公用一个调度器的话，会出现线程之间互跳。最好是每个线程单独一个调度器 </p></li><li><p>借助进程<br> 每个进程一个调度器</p><p> 每个CPU都有自己的ID，把调度器的进程通过系统调用挂在CPU上。<br> 那么CPU不会切换调度队列。    </p></li><li><p>汇编</p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;同步-异步与协程有什么关系？&quot;&gt;&lt;a href=&quot;#同步-异步与协程有什么关系？&quot; class=&quot;headerlink&quot; title=&quot;同步/异步与协程有什么关系？&quot;&gt;&lt;/a&gt;同步/异步与协程有什么关系？&lt;/h2&gt;&lt;p&gt;同步编程方式，更加的直观。但性能不高。&lt;/p
      
    
    </summary>
    
      <category term="基础" scheme="http://twh233.github.io/categories/%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="协程" scheme="http://twh233.github.io/tags/%E5%8D%8F%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>内核spinlock的说明和使用</title>
    <link href="http://twh233.github.io/2020/11/19/%E5%86%85%E6%A0%B8spinlock%E7%9A%84%E8%AF%B4%E6%98%8E%E5%92%8C%E4%BD%BF%E7%94%A8/"/>
    <id>http://twh233.github.io/2020/11/19/内核spinlock的说明和使用/</id>
    <published>2020-11-19T15:47:16.000Z</published>
    <updated>2020-11-19T16:05:40.584Z</updated>
    
    <content type="html"><![CDATA[<img src="/2020/11/19/内核spinlock的说明和使用/1.png"><p>进程与进程之间同步，临界区代码要睡眠的话，一定不要使用自旋锁，<br>用信号量。</p><p>获取自旋锁合适的方法：  int spin_trylock(spinlock_t *lock)</p><h2 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h2><img src="/2020/11/19/内核spinlock的说明和使用/2.png"><img src="/2020/11/19/内核spinlock的说明和使用/3.png"><p>owner表示持有这个数字的thread可以获取自旋锁</p><p>next表示如果后续再有thread请求获取这个自旋锁，就给它分配这个数字</p><img src="/2020/11/19/内核spinlock的说明和使用/4.png"><p>汇编，把next位加一进入while循环。如果成了，那么进入临界区smp_mb()；如果没有，那么wfe()睡眠，然后从内存ACCESS_ONCE读数据到内地lockval变量。所以说其他线程没拿到锁都会锁在这里忙等。</p><img src="/2020/11/19/内核spinlock的说明和使用/5.png">]]></content>
    
    <summary type="html">
    
      
      
        &lt;img src=&quot;/2020/11/19/内核spinlock的说明和使用/1.png&quot;&gt;
&lt;p&gt;进程与进程之间同步，临界区代码要睡眠的话，一定不要使用自旋锁，&lt;br&gt;用信号量。&lt;/p&gt;
&lt;p&gt;获取自旋锁合适的方法：  int spin_trylock(spinlock_t *
      
    
    </summary>
    
      <category term="linux" scheme="http://twh233.github.io/categories/linux/"/>
    
    
      <category term="linux" scheme="http://twh233.github.io/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>skynet源码</title>
    <link href="http://twh233.github.io/2020/11/19/skynet%E6%BA%90%E7%A0%81/"/>
    <id>http://twh233.github.io/2020/11/19/skynet源码/</id>
    <published>2020-11-19T15:38:56.000Z</published>
    <updated>2020-11-19T15:44:54.207Z</updated>
    
    <content type="html"><![CDATA[<h1 id="定时器skynet-timer-c"><a href="#定时器skynet-timer-c" class="headerlink" title="定时器skynet_timer.c"></a>定时器skynet_timer.c</h1><p>skynet自带定时器功能skynet-src/skynet_timer.c，在skynet启动时会创建一个线程专门跑定时器。每帧(0.0025秒/帧)调用skynet_updatetime()</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">// skynet-src/skynet_start.c</span><br><span class="line"></span><br><span class="line">create_thread(&amp;pid[1], thread_timer, m);</span><br><span class="line"></span><br><span class="line">static void *</span><br><span class="line">thread_timer(void *p) &#123;</span><br><span class="line">    struct monitor * m = p;</span><br><span class="line">    skynet_initthread(THREAD_TIMER);</span><br><span class="line">    for (;;) &#123;</span><br><span class="line">        skynet_updatetime();</span><br><span class="line">        CHECK_ABORT</span><br><span class="line">        wakeup(m,m-&gt;count-1);</span><br><span class="line">        usleep(2500);  //2500微妙=0.0025秒</span><br><span class="line">        if (SIG) &#123;</span><br><span class="line">            signal_hup();</span><br><span class="line">            SIG = 0;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="设计思想"><a href="#设计思想" class="headerlink" title="设计思想"></a>设计思想</h2><p>在skynet里，时间精度是0.01秒，这对于游戏服务器来说已经足够了，定义1滴答=0.01秒，1秒=100滴答。其核心思想是：每个定时器设置一个到期的滴答数，与当前系统的滴答数(启动时是0，然后1滴答1滴答往后跳)比较差值，如果差值interval比较小（0&lt;=interval&lt;=2^8-1），表示定时器即将到来，需要严格关注，把它们保存在2^8个定时器链表里；如果interval越大，表示定时器越远，可以不用太关注，划分成4个等级，2^8&lt;=interval&lt;=2^(8+6)-1，2^(8+6)&lt;=interval&lt;=2^(8+6+6)，…，每个等级只需要2^6个定时器链表保存，比如对于2^8&lt;=interval&lt;=2^(8+6)-1的定时器，将interval&gt;&gt;8相同的值idx保存在第一个等级位置为idx的链表里。</p><p>这样做的优势是：不用为每一个interval创建一个链表，而只需要2^8+4*(2^6)个链表，大大节省了内存。</p><p>之后，在不同情况下，分配不同等级的定时器，等级越高，表示越遥远，需要重新分配的次数越少。</p><h2 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h2><p>数据结构：timer-&gt;near，保存2^8个即将到来的定时器链表；timer-&gt;t，保存4个分级数组，数组的每一项是一个链表；timer-&gt;time保存从skynet启动到现在走过的滴答数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">// skynet-src/skynet_timer.c</span><br><span class="line">struct timer_event &#123;</span><br><span class="line">    uint32_t handle;</span><br><span class="line">    int session;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">struct timer_node &#123; //单个定时器节点</span><br><span class="line">    struct timer_node *next;</span><br><span class="line">    uint32_t expire; //到期滴答数</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">struct link_list &#123; //定时器链表</span><br><span class="line">    struct timer_node head;</span><br><span class="line">    struct timer_node *tail;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">struct timer &#123;</span><br><span class="line">    struct link_list near[TIME_NEAR];</span><br><span class="line">    struct link_list t[4][TIME_LEVEL];</span><br><span class="line">    struct spinlock lock;</span><br><span class="line">    uint32_t time; //启动到现在走过的滴答数，等同于current</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">// skynet-src/skynet_timer.c</span><br><span class="line">int</span><br><span class="line">skynet_timeout(uint32_t handle, int time, int session) &#123;</span><br><span class="line">    ...</span><br><span class="line">    struct timer_event event;</span><br><span class="line">    event.handle = handle;</span><br><span class="line">    event.session = session;</span><br><span class="line">    timer_add(TI, &amp;event, sizeof(event), time);</span><br><span class="line">/*</span><br><span class="line">timer_node指针分配空间</span><br><span class="line">*/</span><br><span class="line">    return session;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static void</span><br><span class="line">timer_add(struct timer *T,void *arg,size_t sz,int time) &#123;</span><br><span class="line">    struct timer_node *node = (struct timer_node *)skynet_malloc(sizeof(*node)+sz);</span><br><span class="line">/*</span><br><span class="line">timer_node结构里并没有timer_event字段，除了分配node自身大小外，额外再分配timer_event大小的空间用来存放event，之后通过node+1的位置可以获取到timer_event数据</span><br><span class="line">*/</span><br><span class="line">    memcpy(node+1,arg,sz);</span><br><span class="line"></span><br><span class="line">    SPIN_LOCK(T);</span><br><span class="line"></span><br><span class="line">    node-&gt;expire=time+T-&gt;time;</span><br><span class="line">    /*</span><br><span class="line">添加到定时器链表里，如果定时器的到期滴答数跟当前比较近(&lt;2^8)，表示即将触发定时器添加到T-&gt;near数组里，否则根据差值大小添加到对应的T-&gt;T[i]中</span><br><span class="line">*/</span><br><span class="line">add_node(T,node);</span><br><span class="line"></span><br><span class="line">    SPIN_UNLOCK(T);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static void</span><br><span class="line">add_node(struct timer *T,struct timer_node *node) &#123;</span><br><span class="line">    uint32_t time=node-&gt;expire;</span><br><span class="line">    uint32_t current_time=T-&gt;time;</span><br><span class="line"></span><br><span class="line">    if ((time|TIME_NEAR_MASK)==(current_time|TIME_NEAR_MASK)) &#123;</span><br><span class="line">        link(&amp;T-&gt;near[time&amp;TIME_NEAR_MASK],node);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        int i;</span><br><span class="line">        uint32_t mask=TIME_NEAR &lt;&lt; TIME_LEVEL_SHIFT;</span><br><span class="line">        for (i=0;i&lt;3;i++) &#123;</span><br><span class="line">            if ((time|(mask-1))==(current_time|(mask-1))) &#123;</span><br><span class="line">                 break;</span><br><span class="line">            &#125;</span><br><span class="line">            mask &lt;&lt;= TIME_LEVEL_SHIFT;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        link(&amp;T-&gt;t[i][((time&gt;&gt;(TIME_NEAR_SHIFT + i*TIME_LEVEL_SHIFT)) &amp; TIME_LEVEL_MASK)],node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">// skynet-src/skynet_timer.c</span><br><span class="line">static inline void</span><br><span class="line">timer_execute(struct timer *T) &#123;</span><br><span class="line">    int idx = T-&gt;time &amp; TIME_NEAR_MASK;</span><br><span class="line">/*</span><br><span class="line">每帧从T-&gt;near中触发到期的定时器链表，near数组里每一项的链表中的所有节点的到期滴答数是相同的</span><br><span class="line">*/</span><br><span class="line">    while (T-&gt;near[idx].head.next) &#123;</span><br><span class="line">        struct timer_node *current = link_clear(&amp;T-&gt;near[idx]);</span><br><span class="line">        SPIN_UNLOCK(T);</span><br><span class="line">        // dispatch_list don&apos;t need lock T</span><br><span class="line">        dispatch_list(current);</span><br><span class="line">        SPIN_LOCK(T);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static inline void</span><br><span class="line">dispatch_list(struct timer_node *current) &#123;</span><br><span class="line">    do &#123;</span><br><span class="line">/*</span><br><span class="line">调用dispatch_list进行分发，通过current+1获取timer_event数据</span><br><span class="line">*/</span><br><span class="line">        struct timer_event * event = (struct timer_event *)(current+1);</span><br><span class="line">        struct skynet_message message;</span><br><span class="line">        message.source = 0;</span><br><span class="line">        message.session = event-&gt;session;</span><br><span class="line">        message.data = NULL;</span><br><span class="line">        message.sz = (size_t)PTYPE_RESPONSE &lt;&lt; MESSAGE_TYPE_SHIFT;</span><br><span class="line">/*</span><br><span class="line">然后给event-&gt;handle push一条消息表示触发定时器</span><br><span class="line">*/</span><br><span class="line">       skynet_context_push(event-&gt;handle, &amp;message);</span><br><span class="line"></span><br><span class="line">       struct timer_node * temp = current;</span><br><span class="line">       current=current-&gt;next;</span><br><span class="line">       skynet_free(temp);</span><br><span class="line">    &#125; while (current);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>每帧除了触发定时器外，还需重新分配定时器所在区间(timer_shift)，因为T-&gt;near里保存即将触发的定时器，所以每TIME_NEAR-1（2^8-1）个滴答数才有可能需要分配（第22行）。否则，分配T-&gt;t中某个等级即可。</p><p>当T-&gt;time的低8位不全为0时，不需要分配，所以每2^8个滴答数才有需要分配一次；</p><p>当T-&gt;time的第9-14位不全为0时，重新分配T[0]等级，每2^8个滴答数分配一次，idx从1开始，每次分配+1；</p><p>当T-&gt;time的第15-20位不全为0时，重新分配T[1]等级，每2^(8+6)个滴答数分配一次，idx从1开始，每次分配+1；</p><p>当T-&gt;time的第21-26位不全为0时，重新分配T[2]等级，每2^(8+6+6)个滴答数分配一次，idx从1开始，每次分配+1；</p><p>当T-&gt;time的第27-32位不全为0时，重新分配T[3]等级，每2^(8+6+6+6)个滴答数分配一次，idx从1开始，每次分配+1；</p><p>即等级越大的定时器越遥远，越不关注，需要重新分配的次数也就越少。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">// skynet-src/skynet_timer.c</span><br><span class="line">static void</span><br><span class="line">move_list(struct timer *T, int level, int idx) &#123;</span><br><span class="line">    struct timer_node *current = link_clear(&amp;T-&gt;t[level][idx]);</span><br><span class="line">    while (current) &#123;</span><br><span class="line">        struct timer_node *temp=current-&gt;next;</span><br><span class="line">        add_node(T,current);</span><br><span class="line">        current=temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static void</span><br><span class="line">timer_shift(struct timer *T) &#123;</span><br><span class="line">    int mask = TIME_NEAR;</span><br><span class="line">    uint32_t ct = ++T-&gt;time;</span><br><span class="line">    if (ct == 0) &#123;</span><br><span class="line">        move_list(T, 3, 0);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        uint32_t time = ct &gt;&gt; TIME_NEAR_SHIFT;</span><br><span class="line">        int i=0;</span><br><span class="line"></span><br><span class="line">        while ((ct &amp; (mask-1))==0) &#123;</span><br><span class="line">            int idx=time &amp; TIME_LEVEL_MASK;</span><br><span class="line">            if (idx!=0) &#123;</span><br><span class="line">                move_list(T, i, idx);</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">            mask &lt;&lt;= TIME_LEVEL_SHIFT;</span><br><span class="line">            time &gt;&gt;= TIME_LEVEL_SHIFT;</span><br><span class="line">            ++i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;定时器skynet-timer-c&quot;&gt;&lt;a href=&quot;#定时器skynet-timer-c&quot; class=&quot;headerlink&quot; title=&quot;定时器skynet_timer.c&quot;&gt;&lt;/a&gt;定时器skynet_timer.c&lt;/h1&gt;&lt;p&gt;skynet自带定时
      
    
    </summary>
    
      <category term="skynet" scheme="http://twh233.github.io/categories/skynet/"/>
    
    
      <category term="skynet" scheme="http://twh233.github.io/tags/skynet/"/>
    
  </entry>
  
  <entry>
    <title>分布式锁实现</title>
    <link href="http://twh233.github.io/2020/11/18/%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E5%AE%9E%E7%8E%B0/"/>
    <id>http://twh233.github.io/2020/11/18/分布式锁实现/</id>
    <published>2020-11-18T15:44:36.000Z</published>
    <updated>2020-11-30T15:28:27.568Z</updated>
    
    <content type="html"><![CDATA[<h2 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h2><ol><li>线程锁<br>lock(mutex)<br>资源操作<br>unlock(mutex)</li><li>进程锁（nginx 中 accept 锁-共享内存+信号量）</li><li>分布式锁 在不同机器的进程的锁</li></ol><h2 id="分布式锁特征"><a href="#分布式锁特征" class="headerlink" title="分布式锁特征"></a>分布式锁特征</h2><p>a) 互斥性<br>b) 可重入性 一个进程允许递归获取锁（需要递归释放锁）<br>c) 锁超时（进程 crash 掉，需要考虑释放分布式锁）<br>d) 高效、高可用（redis，zk）（最后一样，一直一样）<br>e) 公平锁和非公平锁 按获取锁顺序执行，反之就是随机执行  </p><h2 id="redis实现"><a href="#redis实现" class="headerlink" title="redis实现"></a>redis实现</h2><p>redis 数据请求的方式： 请求回应+监听发布</p><p>按请求顺序来执行命令，同样的返回按照执行顺序</p><h3 id="方案1"><a href="#方案1" class="headerlink" title="方案1"></a>方案1</h3><p>获取锁：setnx(key, val) 只有在 key 不存在的时候，才能设置成功。成功收到+ok，失败收到nil。使用 setnx(key, val)需要使用额外命令设置超时 expire(key)，在这里需要使用 redis 事务lua。<br>释放锁：del(key)。</p><h3 id="方案2"><a href="#方案2" class="headerlink" title="方案2"></a>方案2</h3><p>获取锁：将 setnx 和 expire 合并为 set(“lock”, 四元组, “NX”, “EX”, 30);<br>四元组解决只由该进程释放锁，需要添加线程给操作续时间（因为可能执行逻辑超过 30 秒）。<br>释放锁：先 get(key)比较四元组，再 delete；在这里需要添加 redis 事务 lua。<br>if (get(key) == 四元组)<br>delete(key);<br>另外，当 A 释放锁，B,C,D 如何竞争锁；第一种，B,C,D 定时查询；第二种使用监听机制<br>（<a href="http://www.redis.cn/topics/pubsub.html），释放的时候发布" target="_blank" rel="noopener">http://www.redis.cn/topics/pubsub.html），释放的时候发布</a> key 删除事件，同时要监听 key<br>的超时（<a href="http://www.redis.cn/topics/notifications.html）；一般采用第一种。" target="_blank" rel="noopener">http://www.redis.cn/topics/notifications.html）；一般采用第一种。</a>  </p><img src="/2020/11/18/分布式锁实现/1.png"><h2 id="zookeeper实现"><a href="#zookeeper实现" class="headerlink" title="zookeeper实现"></a>zookeeper实现</h2><p>数据模型 + 监听机制来驱动所有的功能 事务</p><ol><li>数据模型 类似文件系统存储方式<br>持久的 持久化<br>短暂的 连接相关，连接断开后，连接创建的节点自动删除<br>顺序的  持久顺序节点<br>（持久节点，短暂顺序节点，短暂节点）</li><li>监听机制 可监听节点的变化 （创建，删除，值的变化，子节点的变化（创建或者删除））</li></ol><p>互斥锁的实现：<br>获取锁：创建同名短暂的节点 只有一个能创建成功<br>释放锁：delete 节点或者断开连接自动删除 锁超时  </p><img src="/2020/11/18/分布式锁实现/2.png"><p>公平锁的实现：  </p><ol><li>每个进程创建 lock 节点（短暂顺序节点）；  </li><li>每个进程都有独自的一个序号；假设序号为 0，说明它获取锁，那么序号不为 0， 只需要监听序号排序中前一位（可能序号小一，可能序号小更多，因为前一个节点可能自动删除了）就行了。  </li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#include &lt;time.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#include &quot;include/zookeeper.h&quot;</span><br><span class="line">#include &quot;include/zookeeper_log.h&quot;</span><br><span class="line"></span><br><span class="line">typedef struct zk_mutex_s &#123;</span><br><span class="line">    int seq_me; // 序号</span><br><span class="line">    int seq_watch; // 监听的序号</span><br><span class="line">    char watch[64]; // 监听的节点名</span><br><span class="line">&#125; zk_mutex_t;</span><br><span class="line">static zk_mutex_t zmt = &#123;0&#125;;</span><br><span class="line">static int quit = 0;</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">typedef void (*void_completion_t)(int rc, const void *data);</span><br><span class="line">*/</span><br><span class="line">void zk_delete_lock_res1_children(int rc, const void *data) &#123;</span><br><span class="line">    printf(&quot;zk_delete_lock_res1_children rc = %d\n&quot;, rc);</span><br><span class="line">    quit = 1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">typedef void (*stat_completion_t)(int rc, const struct Stat *stat,</span><br><span class="line">        const void *data);</span><br><span class="line">*/</span><br><span class="line">void zk_watch_children(int rc, const struct Stat *stat, const void *data) &#123;</span><br><span class="line">    printf(&quot;zk_watch_children_disappear rc = %d\n&quot;, rc);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">typedef void (*strings_completion_t)(int rc,</span><br><span class="line">        const struct String_vector *strings, const void *data);</span><br><span class="line">*/</span><br><span class="line">void zk_get_children_lock_res1(int rc, const struct String_vector *strings, const void *data) &#123;</span><br><span class="line">    printf(&quot;zk_get_children_lock_res1 rc = %d\n&quot;, rc);</span><br><span class="line">    if (rc == 0) &#123;</span><br><span class="line">        int i,v,n;</span><br><span class="line">        n = 0;</span><br><span class="line">        char * value_self = NULL;</span><br><span class="line">        char * value_other = NULL;</span><br><span class="line">        zhandle_t* zk_hdl = (zhandle_t*)data;</span><br><span class="line">        for (i = 0; i &lt; strings-&gt;count; i++) &#123;</span><br><span class="line">            sscanf(strings-&gt;data[i], &quot;%d&quot;, &amp;v);</span><br><span class="line">            if (v &lt; zmt.seq_me) &#123;</span><br><span class="line">                if (n == 0) &#123;</span><br><span class="line">                    zmt.seq_watch = v;</span><br><span class="line">                    value_other = strings-&gt;data[i];</span><br><span class="line">                    n++;</span><br><span class="line">                &#125; else if (n &gt; 0 &amp;&amp; v &gt; zmt.seq_watch) &#123;</span><br><span class="line">                    zmt.seq_watch = v;</span><br><span class="line">                    value_other = strings-&gt;data[i];</span><br><span class="line">                    n++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; else if (v == zmt.seq_me) &#123;</span><br><span class="line">                value_self = strings-&gt;data[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (n == 0) &#123;</span><br><span class="line">            // 说明自己已经最小的了</span><br><span class="line">            char temp[64] = &#123;0&#125;;</span><br><span class="line">            sprintf(temp, &quot;/lock/res1/%s&quot;, value_self);</span><br><span class="line">            printf(&quot;%s 获取锁, 获取执行权, 释放锁\n&quot;, temp);</span><br><span class="line">            zoo_adelete(zk_hdl, temp, -1, zk_delete_lock_res1_children, zk_hdl);</span><br><span class="line">        &#125; else if (n &gt; 0) &#123; // 找到可以监听的对象</span><br><span class="line">            memset(zmt.watch, 0, 64*sizeof(char));</span><br><span class="line">            sprintf(zmt.watch, &quot;/lock/res1/%s&quot;, value_other);</span><br><span class="line">            zoo_aexists(zk_hdl, zmt.watch, 1, zk_watch_children, zk_hdl);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">typedef void</span><br><span class="line">        (*string_completion_t)(int rc, const char *value, const void *data);</span><br><span class="line">*/</span><br><span class="line">void zk_create_lock_res1_es(int rc, const char *value, const void *data) &#123;</span><br><span class="line">    printf(&quot;zk_create_lock_res1_es rc = %d\n&quot;, rc);</span><br><span class="line">    if (rc == 0) &#123;</span><br><span class="line">        zhandle_t* zk_hdl = (zhandle_t*)data;</span><br><span class="line">        int seq;</span><br><span class="line">        sscanf(value, &quot;/lock/res1/%d&quot;, &amp;seq);</span><br><span class="line">        printf(&quot;\tname = %s seq = %d\n&quot;, value, seq);</span><br><span class="line">        zmt.seq_me = seq;</span><br><span class="line">        if (seq &gt; 0) &#123;</span><br><span class="line">            int ret;</span><br><span class="line">            ret = zoo_aget_children(zk_hdl, &quot;/lock/res1&quot;, 0, zk_get_children_lock_res1, data);</span><br><span class="line">            if (ret) &#123;</span><br><span class="line">                printf(&quot;error: zk_create_lock_res1_es:zoo_aget_children\n&quot;);</span><br><span class="line">                exit(EXIT_FAILURE);</span><br><span class="line">            &#125;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        printf(&quot;%s 获取锁, 获取执行权, 释放锁\n&quot;, value);</span><br><span class="line">        zoo_adelete(zk_hdl, value, -1, zk_delete_lock_res1_children, &quot;&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">typedef void (*watcher_fn)(zhandle_t *zh, int type,</span><br><span class="line">        int state, const char *path,void *watcherCtx);</span><br><span class="line">*/</span><br><span class="line">void zk_watcher_disconnect(zhandle_t *zh, int type, int state, const char *path, void *ctx) &#123;</span><br><span class="line">    if (0 == strcmp(zmt.watch, path)) &#123;</span><br><span class="line">        int ret = zoo_aget_children(zh, &quot;/lock/res1&quot;, 0, zk_get_children_lock_res1, zh);</span><br><span class="line">        if (ret) &#123;</span><br><span class="line">            printf(&quot;error: zk_watcher_disconnect:zoo_aget_children\n&quot;);</span><br><span class="line">            exit(EXIT_FAILURE);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main(int argc, const char *argv[]) &#123;</span><br><span class="line">    zoo_set_debug_level(ZOO_LOG_LEVEL_WARN);</span><br><span class="line">    zoo_set_log_stream(stdout);</span><br><span class="line"></span><br><span class="line">    /* 初始化 zk */</span><br><span class="line">    zhandle_t* zk_hdl = zookeeper_init(&quot;127.0.0.1:2181&quot;,</span><br><span class="line">            zk_watcher_disconnect, 30000, 0, &quot;zookeeper for distribute mutex.&quot;, 0);</span><br><span class="line">    if (!zk_hdl) &#123;</span><br><span class="line">        printf(&quot;error: connecting to zookeeper server...\n&quot;);</span><br><span class="line">        exit(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int ret;</span><br><span class="line">    /* 创建 /lock/res1/ 短暂顺序节点*/</span><br><span class="line">    ret = zoo_acreate(zk_hdl, &quot;/lock/res1/&quot;, &quot;mark&quot;, 5, &amp;ZOO_OPEN_ACL_UNSAFE,</span><br><span class="line">        ZOO_EPHEMERAL_SEQUENTIAL, zk_create_lock_res1_es, zk_hdl);</span><br><span class="line">    if (ret) &#123;</span><br><span class="line">        printf(&quot;error: create /lock/res1 EPHEMERAL SEQUENTIAL\n&quot;);</span><br><span class="line">        exit(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line">    ret = 0;</span><br><span class="line"></span><br><span class="line">    for (;;) &#123;</span><br><span class="line">        if (quit) break;</span><br><span class="line">        usleep(2500);</span><br><span class="line">    &#125;</span><br><span class="line">    zookeeper_close(zk_hdl);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;锁&quot;&gt;&lt;a href=&quot;#锁&quot; class=&quot;headerlink&quot; title=&quot;锁&quot;&gt;&lt;/a&gt;锁&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;线程锁&lt;br&gt;lock(mutex)&lt;br&gt;资源操作&lt;br&gt;unlock(mutex)&lt;/li&gt;
&lt;li&gt;进程锁（nginx 中 acc
      
    
    </summary>
    
      <category term="基础" scheme="http://twh233.github.io/categories/%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="分布式" scheme="http://twh233.github.io/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>定时器方案的实现</title>
    <link href="http://twh233.github.io/2020/11/17/%E5%AE%9A%E6%97%B6%E5%99%A8%E6%96%B9%E6%A1%88%E7%9A%84%E5%AE%9E%E7%8E%B0/"/>
    <id>http://twh233.github.io/2020/11/17/定时器方案的实现/</id>
    <published>2020-11-17T14:37:37.000Z</published>
    <updated>2020-11-19T14:20:49.112Z</updated>
    
    <content type="html"><![CDATA[<p>定时器需要满足的需求：</p><p>1.能快速找到第一个时间快到的结点</p><p>2.插入删除 o(logn)</p><h2 id="跳表"><a href="#跳表" class="headerlink" title="跳表"></a>跳表</h2><p>利用跳表来实现，那么跳表最左下角的结点就是第一个结点。<br>查找的效率o(1)</p><p>插入的效率趋近o(logn)</p><h2 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h2><p>查找、插入的效率(logn)</p><p>查第一个结点的时候<br>需要不断递归左子树</p><h2 id="时间轮"><a href="#时间轮" class="headerlink" title="时间轮"></a>时间轮</h2><img src="/2020/11/17/定时器方案的实现/1.png"><p>如图是skynet的定时器设计，就像手表，层数越低代表时间越近。</p><p>层数越低就像秒针。<br>第二层就像分针。<br>第三层像时针。</p><p>等60秒转完，那么分针的数据push进秒针里。分针往后移一格。<br>时针同理，所以称作时间轮。</p><p>缺点：<br>1.移动的，不好删除 + 引用计数  处理比较麻烦<br>2.像时钟一样运行，确保每10ms运行一次</p><h3 id="如何取消呢？"><a href="#如何取消呢？" class="headerlink" title="如何取消呢？"></a>如何取消呢？</h3><p>如果加入定时器，还没触发之前又要删掉。</p><p>只能在业务层处理屏蔽。因为时间轮这种方式是找不到对应的结点位置的。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;定时器需要满足的需求：&lt;/p&gt;
&lt;p&gt;1.能快速找到第一个时间快到的结点&lt;/p&gt;
&lt;p&gt;2.插入删除 o(logn)&lt;/p&gt;
&lt;h2 id=&quot;跳表&quot;&gt;&lt;a href=&quot;#跳表&quot; class=&quot;headerlink&quot; title=&quot;跳表&quot;&gt;&lt;/a&gt;跳表&lt;/h2&gt;&lt;p&gt;利用跳表
      
    
    </summary>
    
      <category term="基础" scheme="http://twh233.github.io/categories/%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="定时器" scheme="http://twh233.github.io/tags/%E5%AE%9A%E6%97%B6%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>内核原子变量的说明和使用</title>
    <link href="http://twh233.github.io/2020/11/17/%E5%86%85%E6%A0%B8%E5%8E%9F%E5%AD%90%E5%8F%98%E9%87%8F%E7%9A%84%E8%AF%B4%E6%98%8E%E5%92%8C%E4%BD%BF%E7%94%A8/"/>
    <id>http://twh233.github.io/2020/11/17/内核原子变量的说明和使用/</id>
    <published>2020-11-17T13:11:15.000Z</published>
    <updated>2020-11-17T13:22:11.222Z</updated>
    
    <content type="html"><![CDATA[<img src="/2020/11/17/内核原子变量的说明和使用/1.png"><p>static atomic_t can_open = ATOMIC_INIT(1);</p><p>atomic_dec_and_test 先减一，如果结果是0返回true，否则返回false。</p><p>第一次可以打开，第二次进入if。</p><p>atomic_inc 再加一，不会被打断。 原子的加法分三步，最底层调用汇编代码。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;img src=&quot;/2020/11/17/内核原子变量的说明和使用/1.png&quot;&gt;
&lt;p&gt;static atomic_t can_open = ATOMIC_INIT(1);&lt;/p&gt;
&lt;p&gt;atomic_dec_and_test 先减一，如果结果是0返回true，否则返回fal
      
    
    </summary>
    
      <category term="linux" scheme="http://twh233.github.io/categories/linux/"/>
    
    
      <category term="linux" scheme="http://twh233.github.io/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>semaphore内核源码的实现</title>
    <link href="http://twh233.github.io/2020/11/15/semaphore%E5%86%85%E6%A0%B8%E6%BA%90%E7%A0%81%E7%9A%84%E5%AE%9E%E7%8E%B0/"/>
    <id>http://twh233.github.io/2020/11/15/semaphore内核源码的实现/</id>
    <published>2020-11-15T10:11:26.000Z</published>
    <updated>2020-11-15T10:21:55.067Z</updated>
    
    <content type="html"><![CDATA[<img src="/2020/11/15/semaphore内核源码的实现/5.png"><p>首先down 是获取锁，如果获取到可以独占临界区资源执行下面语句，如果获取不到不断轮询去获取。</p><img src="/2020/11/15/semaphore内核源码的实现/2.png"><p>第一个进程只是把count–，而第二个进程才会去__down函数里</p><img src="/2020/11/15/semaphore内核源码的实现/1.png"><p>current 当前进程，把等待在信号量上的task加入waiter结构体里。</p><p>(如果有信号打断goto interrupted)</p><p>自旋锁的开销非常大，尽可能尽量少的代码在自旋锁的粒度里，所以才会有外面加锁，里面解锁又加锁。schedule_timeout会睡眠，所以没办法放进自旋锁的保护区里，当到进程二唤醒的时候接着加锁，waiter.up == true 返回 </p><img src="/2020/11/15/semaphore内核源码的实现/3.png"><p>同理。进程count++，如果wait_list空，那么调用__up函数</p><img src="/2020/11/15/semaphore内核源码的实现/4.png"><p>从刚才的容器里拿出来waiter， waiter-&gt;up = true</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;img src=&quot;/2020/11/15/semaphore内核源码的实现/5.png&quot;&gt;
&lt;p&gt;首先down 是获取锁，如果获取到可以独占临界区资源执行下面语句，如果获取不到不断轮询去获取。&lt;/p&gt;
&lt;img src=&quot;/2020/11/15/semaphore内核源码的实现
      
    
    </summary>
    
      <category term="linux" scheme="http://twh233.github.io/categories/linux/"/>
    
    
      <category term="linux" scheme="http://twh233.github.io/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>用户态协议栈TCPIP</title>
    <link href="http://twh233.github.io/2020/11/15/%E7%94%A8%E6%88%B7%E6%80%81%E5%8D%8F%E8%AE%AE%E6%A0%88TCPIP/"/>
    <id>http://twh233.github.io/2020/11/15/用户态协议栈TCPIP/</id>
    <published>2020-11-15T09:18:06.000Z</published>
    <updated>2020-11-17T13:09:27.269Z</updated>
    
    <content type="html"><![CDATA[<h2 id="网卡是属于协议栈哪一层"><a href="#网卡是属于协议栈哪一层" class="headerlink" title="网卡是属于协议栈哪一层"></a>网卡是属于协议栈哪一层</h2><p>网卡不属于任何一层。<br>物理层传输的是：光电信号<br>数据链路层对应：数字信号</p><p>网卡作用：将光电信号转化成数字信号，数字信号转化为光电信号。</p><h2 id="利用-netmap-实现协议栈"><a href="#利用-netmap-实现协议栈" class="headerlink" title="利用 netmap 实现协议栈"></a>利用 netmap 实现协议栈</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;sys/poll.h&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#define NETMAP_WITH_LIBS</span><br><span class="line"></span><br><span class="line">#include &lt;net/netmap_user.h&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#pragma pack(1)</span><br><span class="line"></span><br><span class="line">#define PROTO_IP 0x0800</span><br><span class="line">#define PROTO_UDP17</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#define ETH_LEN6</span><br><span class="line"></span><br><span class="line">struct ethhdr &#123;</span><br><span class="line"></span><br><span class="line">unsigned char h_dest[ETH_LEN]; //mac</span><br><span class="line">unsigned char h_src[ETH_LEN];</span><br><span class="line">unsigned short h_proto;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line">// sizeof(struct ethhdr) == 14</span><br><span class="line"></span><br><span class="line">struct iphdr &#123;</span><br><span class="line"></span><br><span class="line">unsigned char version:4,</span><br><span class="line">  hdrlen:4;</span><br><span class="line"></span><br><span class="line">unsigned char tos; //</span><br><span class="line">unsigned short length;</span><br><span class="line"></span><br><span class="line">unsigned short id;</span><br><span class="line"></span><br><span class="line">unsigned short flag:3,</span><br><span class="line">   offset:13;</span><br><span class="line"></span><br><span class="line">unsigned char ttl;</span><br><span class="line">unsigned char proto;</span><br><span class="line"></span><br><span class="line">unsigned short check;</span><br><span class="line"></span><br><span class="line">unsigned int sip;</span><br><span class="line">unsigned int dip;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// sizeof(struct ip) == 20</span><br><span class="line"></span><br><span class="line">struct udphdr &#123;</span><br><span class="line"></span><br><span class="line">unsigned short sport;</span><br><span class="line">unsigned short dport;</span><br><span class="line">unsigned short length;</span><br><span class="line">unsigned short check;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// sizeof(udphdr)  8</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">struct udppkt &#123;</span><br><span class="line"></span><br><span class="line">struct ethhdr eh; // 14</span><br><span class="line">struct iphdr ip;  // 20</span><br><span class="line">struct udphdr udp; // 8</span><br><span class="line"></span><br><span class="line">unsigned char body[0]; // sizeof(body)=0;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// sizeof(udppkt) = 44</span><br><span class="line">// sizeof()</span><br><span class="line"></span><br><span class="line">// f-stack</span><br><span class="line">// dpdk + bsd </span><br><span class="line"></span><br><span class="line">// netmap , dpdk, raw_socket</span><br><span class="line"></span><br><span class="line">// netmap:eth0</span><br><span class="line">// eth0</span><br><span class="line">int main() &#123;</span><br><span class="line"></span><br><span class="line">// eth0  --&gt; ens33</span><br><span class="line">struct nm_desc *nmr = nm_open(&quot;netmap:eth0&quot;, NULL, 0, NULL);</span><br><span class="line">if (nmr == NULL) &#123;</span><br><span class="line">return -1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">struct pollfd pfd = &#123;0&#125;;</span><br><span class="line">pfd.fd = nmr-&gt;fd; //</span><br><span class="line">pfd.events = POLLIN;</span><br><span class="line">// select/poll  or epoll</span><br><span class="line">// poll --&gt; select</span><br><span class="line">while (1) &#123;</span><br><span class="line"></span><br><span class="line">int ret = poll(&amp;pfd, 1, -1);</span><br><span class="line">if (ret &lt; 0) continue;</span><br><span class="line"></span><br><span class="line">if (pfd.revents &amp; POLLIN) &#123;</span><br><span class="line">struct nm_pkthdr h;</span><br><span class="line">unsigned char *stream = nm_nextpkt(nmr, &amp;h); // read</span><br><span class="line"></span><br><span class="line">struct ethhdr *eh = (struct ethhdr*)stream;</span><br><span class="line"></span><br><span class="line">// 0x0800</span><br><span class="line">if (ntohs(eh-&gt;h_proto) == PROTO_IP) &#123;</span><br><span class="line"></span><br><span class="line">struct udppkt *udp = (struct udppkt *)stream;</span><br><span class="line"></span><br><span class="line">if (udp-&gt;ip.proto == PROTO_UDP) &#123;</span><br><span class="line"></span><br><span class="line">//</span><br><span class="line">int udp_length = ntohs(udp-&gt;udp.length);</span><br><span class="line"></span><br><span class="line">udp-&gt;body[udp_length-8] = &apos;\0&apos;;</span><br><span class="line"></span><br><span class="line">printf(&quot;udp --&gt; %s\n&quot;, udp-&gt;body);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="为什么一会儿就不能接受发送到这个端口的数据了"><a href="#为什么一会儿就不能接受发送到这个端口的数据了" class="headerlink" title="为什么一会儿就不能接受发送到这个端口的数据了"></a>为什么一会儿就不能接受发送到这个端口的数据了</h3><p>因为arp过期了，icmp 会ping 对端，但是这个程序没有一直ping对端，导致arp过期。 不能再找到主机的MAC地址，所以发送不过去了。</p><h2 id="fd端口只有65535，为什么并发能做到上百万"><a href="#fd端口只有65535，为什么并发能做到上百万" class="headerlink" title="fd端口只有65535，为什么并发能做到上百万"></a>fd端口只有65535，为什么并发能做到上百万</h2><p>fd –&gt;  五元组(sip,dip,sport,dport,proto)</p><p>send(fd)的时候，fd 通过五元组判断客户端的唯一性</p><h2 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a>三次握手</h2><img src="/2020/11/15/用户态协议栈TCPIP/1.png"><p>syn 队列 accept队列满时，会造成真正要连接的fd阻塞。只能加外网防火墙拦截。</p><h2 id="滑动窗口"><a href="#滑动窗口" class="headerlink" title="滑动窗口"></a>滑动窗口</h2><img src="/2020/11/15/用户态协议栈TCPIP/2.png"><p>如果接收到ACK，那么说明从这个包之前的包都已经成功接受到，可以往后滑动，发送新的包。<br>对端ACK应答把窗口大小带上。</p><h2 id="快速重传"><a href="#快速重传" class="headerlink" title="快速重传"></a>快速重传</h2><p>当接收端收到比期望序号大的报文段时，便会重复发送最近一次确认的报文段的确认信号，我们称之为冗余ACK。<br>报文段1成功接收并被确认ACK 2，接收端的期待序号为2，当报文段2丢失，报文段3失序到来，与接收端的期望不匹配，接收端重复发送冗余ACK 2。</p><img src="/2020/11/15/用户态协议栈TCPIP/3.png"><h2 id="拥塞控制"><a href="#拥塞控制" class="headerlink" title="拥塞控制"></a>拥塞控制</h2><p>滑动窗口可以是动态控制大小的。跟rtt有关系。</p><p>rtt = 0.9 <em> oldrtt + 0.1 </em> newrtt</p><p>而cwnd 由慢启动 cwnd = cwnd * 2 再到拥塞控制 1/2这个过程逐步趋于一个平稳值。</p><h2 id="为什么会用udp做可靠传输"><a href="#为什么会用udp做可靠传输" class="headerlink" title="为什么会用udp做可靠传输"></a>为什么会用udp做可靠传输</h2><img src="/2020/11/15/用户态协议栈TCPIP/4.png"><p>下载的时候，TCP可以限制包数量，但是UDP不行。  </p><p>游戏打团得实时，TCP要保持有序，卡了怎么办，所以可以牺牲效率保证实时。</p><h2 id="四次挥手"><a href="#四次挥手" class="headerlink" title="四次挥手"></a>四次挥手</h2><img src="/2020/11/15/用户态协议栈TCPIP/5.png"><h3 id="为什么四次挥手是四次"><a href="#为什么四次挥手是四次" class="headerlink" title="为什么四次挥手是四次"></a>为什么四次挥手是四次</h3><p>因为对端都需要对方的确认，就像男女朋友，A提出分手，B先接受这个消息，表示我知道你要分手了。但是还需要一点时间消化，同意了再告诉A，我同意了。而且A提出分手的时候，B还有一些数据还在传，传完了之后再告诉A断开联系。所以必须是四次</p><h3 id="为什么还有fin-wait2状态"><a href="#为什么还有fin-wait2状态" class="headerlink" title="为什么还有fin_wait2状态"></a>为什么还有fin_wait2状态</h3><p>因为还要收B的数据 </p><h3 id="time-wait作用"><a href="#time-wait作用" class="headerlink" title="time_wait作用"></a>time_wait作用</h3><p>害怕最后一次ACK丢失，发送fin的时候有定时器，如果最后一次ACK可能丢失，如果在LAST_ACK状态的B收不到这个ACK的确认。B会超时重传FIN，所以time_wait是2MSL.A就能在这个时间内再次发送ACK确认，重新启动2MSL的计时器。并且有效防止了旧ACK的出现影响连接。下一个新的连接不会再出现这种旧的连接请求报文段。</p><h3 id="出现大量close-wait状态"><a href="#出现大量close-wait状态" class="headerlink" title="出现大量close_wait状态"></a>出现大量close_wait状态</h3><p>因为B端 recv() 没有调用close() 或者时机不对 </p><h3 id="如图，ACK丢失会怎样"><a href="#如图，ACK丢失会怎样" class="headerlink" title="如图，ACK丢失会怎样"></a>如图，ACK丢失会怎样</h3><p>A先收到FIN就出现closing状态，再收到ACK变为time_wait状态。</p><h3 id="中间ACK和FIN同时调用"><a href="#中间ACK和FIN同时调用" class="headerlink" title="中间ACK和FIN同时调用"></a>中间ACK和FIN同时调用</h3><p>出现A也发送关闭FIN，B也同时发送FIN，那么两边都会成为closing状态，各自收到ACK变成time_wait状态，四次挥手就变成了三次</p><h3 id="time-wait状态太多"><a href="#time-wait状态太多" class="headerlink" title="time_wait状态太多"></a>time_wait状态太多</h3><p>等待时间过长</p><h2 id="tcp与epoll的触发"><a href="#tcp与epoll的触发" class="headerlink" title="tcp与epoll的触发"></a>tcp与epoll的触发</h2><img src="/2020/11/15/用户态协议栈TCPIP/6.png">]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;网卡是属于协议栈哪一层&quot;&gt;&lt;a href=&quot;#网卡是属于协议栈哪一层&quot; class=&quot;headerlink&quot; title=&quot;网卡是属于协议栈哪一层&quot;&gt;&lt;/a&gt;网卡是属于协议栈哪一层&lt;/h2&gt;&lt;p&gt;网卡不属于任何一层。&lt;br&gt;物理层传输的是：光电信号&lt;br&gt;数据链路
      
    
    </summary>
    
      <category term="基础" scheme="http://twh233.github.io/categories/%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="TCP/IP" scheme="http://twh233.github.io/tags/TCP-IP/"/>
    
  </entry>
  
  <entry>
    <title>redis理解</title>
    <link href="http://twh233.github.io/2020/11/11/redis%E7%90%86%E8%A7%A3/"/>
    <id>http://twh233.github.io/2020/11/11/redis理解/</id>
    <published>2020-11-11T15:02:18.000Z</published>
    <updated>2020-11-14T10:00:48.980Z</updated>
    
    <content type="html"><![CDATA[<h2 id="redis的Hash如何解决冲突"><a href="#redis的Hash如何解决冲突" class="headerlink" title="redis的Hash如何解决冲突"></a>redis的Hash如何解决冲突</h2><p>链表法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">typedef struct dictht &#123;</span><br><span class="line">dictEntry **table;</span><br><span class="line">unsigned long size;</span><br><span class="line"> unsigned long sizemask;</span><br><span class="line"> unsigned long used;</span><br><span class="line">&#125; dictht;</span><br></pre></td></tr></table></figure><p>table 属性是⼀个数组，数组中的每个元素都是⼀个指向 dict.h/dictEntry 结构的指针，每个dictEntry 结构保存着⼀个键值对；<br>size 属性记录了哈希表的⼤⼩,也即是 table 数组的⼤⼩，⽽ used 属性则记录了哈希表⽬前已有节点（键值对）的数量；<br>sizemask 属性的值总是等于 size - 1 ，这个属性和哈希值⼀起决定⼀个键应该被放到 table 数组的哪个索引上⾯；used属性，表示hash表⾥已有的数量。如下图展示了⼀个空的hash表：</p><img src="/2020/11/11/redis理解/1.png"><p>hash表的节点哈希表节点使⽤ dictEntry 结构表示， 每个 dictEntry 结构都保存着⼀个键值对</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">typedef struct dictEntry &#123;</span><br><span class="line">    // 键</span><br><span class="line">    void *key;  </span><br><span class="line">    </span><br><span class="line">    // 值</span><br><span class="line">union &#123;</span><br><span class="line">void *val;</span><br><span class="line">uint64_t u64;</span><br><span class="line">int64_t s64;</span><br><span class="line">double d;</span><br><span class="line">&#125; v; </span><br><span class="line">    </span><br><span class="line">// 指向下个哈希表节点，形成链表</span><br><span class="line">struct dictEntry *next;</span><br><span class="line">&#125; dictEntry;</span><br></pre></td></tr></table></figure><p>举个例⼦，下图就展示了如何通过 next 指针，将两个索引值相同的键 k1 和 k0 连接在⼀起。</p><img src="/2020/11/11/redis理解/2.png"><p>hash表是随着K-V数量的增⼤⽽逐步增⼤的，并不直接以key的hash值为下标去取值得，⽽是以hash &amp; sizemask去获取hash表的对应节点的；hash表的节点实际上是⼀个链表，如果hash &amp;sizemask有冲突，则也把冲突key放在hash表的链表上，取值得时候还得遍历hash表⾥的链表。</p><h2 id="rehash"><a href="#rehash" class="headerlink" title="rehash"></a>rehash</h2><p>随着操作的不断执⾏，哈希表保存的键值对会逐渐地增多或者减少，为了让哈希表的负载因⼦（ratio）维持在⼀个合理的范围之内，当哈希表保存的键值对数量太多或者太少时，程序需要对哈希表的⼤⼩进⾏相应的扩展或者收缩。</p><p>扩容的步骤如下：<br>1、为字典ht[1]哈希表分配合适的空间；<br>2、将ht[0]中所有的键值对rehash到ht[1]：rehash 指的是重新计算键的哈希值和索引值，然后将键值对放置到 ht[1] 哈希表的指定位置上；<br>3、当 ht[0] 包含的所有键值对都迁移到了 ht[1] 之后（ht[0] 变为空表） 释放 ht[0] ，将 ht[1] 设置为 ht[0] ，并在 ht[1] 新创建⼀个空⽩哈希表，为下⼀次 rehash 做准备。  </p><p>当然rehash指渐进式hash，如果在服务器运作直接扩容，那么会影响服务器性能。以下是哈希表渐进式 rehash 的详细步骤：  </p><ol><li>为 ht[1] 分配空间，让字典同时持有 ht[0] 和 ht[1] 两个哈希表。</li><li>在字典中维持⼀个索引计数器变量 rehashidx ，并将它的值设置0 ， 表示 rehash ⼯作正式开始。  </li><li>在 rehash 进⾏期间，每次对字典执⾏添加、删除、查找或者更新操作时，程序除了执⾏指定的操作以外，还会顺带将 ht[0] 哈希表rehashidx 索引上的所有键值对 rehash 到 ht[1] ，当 rehash ⼯作完成之后，程序将 rehashidx 属性的值增⼀。</li><li>随着字典操作的不断执⾏，最终在某个时间点上 ht[0] 的所有键对都会被 rehash ⾄ ht[1] ，这时程序将 rehashidx 属性的值设为 -1 ， 表示 rehash 操作已完成。</li></ol><p>插曲：</p><p>keys hkeys 枚举形式，是通过高位加1的方式进行next，这样的好处是让每次扩缩容，前面的for不用再进行遍历。</p><h2 id="跳表"><a href="#跳表" class="headerlink" title="跳表"></a>跳表</h2><p>跳表与红黑树区别：<br>1) 结构的区别： 多层有序链表，二叉树<br>2）搜索的区别： 大概率的o(logn)<br>3) 功能性的区别： o(logn) zrange logn * o(logn)</p><img src="/2020/11/11/redis理解/3.png"><h2 id="主从复制"><a href="#主从复制" class="headerlink" title="主从复制"></a>主从复制</h2><h3 id="2-8版本以前的方案：全量同步"><a href="#2-8版本以前的方案：全量同步" class="headerlink" title="2.8版本以前的方案：全量同步"></a>2.8版本以前的方案：全量同步</h3><p>1.master 持久化，之后的命令写入缓冲区，发送rdb<br>2.slave接受rdb，加载至内存<br>3.master 发送缓冲区的命令，slave依次处理  </p><p>下面三种情况如何保证效率问题：<br>a.新加入从结点 b.主从连接故障  c.从结点重启 </p><p>其实如果是b情况，只需要将少量写操作同步给从数据库就行了<br>于是引入2.8版本 </p><h3 id="2-8版本"><a href="#2-8版本" class="headerlink" title="2.8版本"></a>2.8版本</h3><p>1.记录偏移量 psync<br>2.主master运行id </p><h3 id="之后版本"><a href="#之后版本" class="headerlink" title="之后版本"></a>之后版本</h3><p>rdb保存运行id以及offset<br>主切换 从需要记录之前运行id以及偏移量</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;redis的Hash如何解决冲突&quot;&gt;&lt;a href=&quot;#redis的Hash如何解决冲突&quot; class=&quot;headerlink&quot; title=&quot;redis的Hash如何解决冲突&quot;&gt;&lt;/a&gt;redis的Hash如何解决冲突&lt;/h2&gt;&lt;p&gt;链表法&lt;/p&gt;
&lt;figur
      
    
    </summary>
    
      <category term="redis" scheme="http://twh233.github.io/categories/redis/"/>
    
    
      <category term="redis" scheme="http://twh233.github.io/tags/redis/"/>
    
  </entry>
  
  <entry>
    <title>x86段页式内存管理和页表映射机制</title>
    <link href="http://twh233.github.io/2020/11/11/x86%E6%AE%B5%E9%A1%B5%E5%BC%8F%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E5%92%8C%E9%A1%B5%E8%A1%A8%E6%98%A0%E5%B0%84%E6%9C%BA%E5%88%B6/"/>
    <id>http://twh233.github.io/2020/11/11/x86段页式内存管理和页表映射机制/</id>
    <published>2020-11-11T14:51:04.000Z</published>
    <updated>2020-11-11T15:01:37.572Z</updated>
    
    <content type="html"><![CDATA[<h2 id="页表映射"><a href="#页表映射" class="headerlink" title="页表映射"></a>页表映射</h2><p>如图二级页表：</p><img src="/2020/11/11/x86段页式内存管理和页表映射机制/1.png"><p>简单来说CPU在页表映射的时候，Dir 代表页目录表的索引，Offset是偏移，Table是页表的索引。</p><p>先定位页表地址，通过Table定位到物理块地址，再加上offset得到真正的物理地址。</p><p>内核用一个页目录表，但不同进程有各自的页目录表。</p><h2 id="逻辑地址到物理地址的转换"><a href="#逻辑地址到物理地址的转换" class="headerlink" title="逻辑地址到物理地址的转换"></a>逻辑地址到物理地址的转换</h2><p>从虚拟地址段页式的转化转化成线性地址，再线性地址页表映射转化成物理地址。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;页表映射&quot;&gt;&lt;a href=&quot;#页表映射&quot; class=&quot;headerlink&quot; title=&quot;页表映射&quot;&gt;&lt;/a&gt;页表映射&lt;/h2&gt;&lt;p&gt;如图二级页表：&lt;/p&gt;
&lt;img src=&quot;/2020/11/11/x86段页式内存管理和页表映射机制/1.png&quot;&gt;
&lt;p
      
    
    </summary>
    
      <category term="linux" scheme="http://twh233.github.io/categories/linux/"/>
    
    
      <category term="linux" scheme="http://twh233.github.io/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>内核空间和用户空间</title>
    <link href="http://twh233.github.io/2020/11/10/%E5%86%85%E6%A0%B8%E7%A9%BA%E9%97%B4%E5%92%8C%E7%94%A8%E6%88%B7%E7%A9%BA%E9%97%B4/"/>
    <id>http://twh233.github.io/2020/11/10/内核空间和用户空间/</id>
    <published>2020-11-10T13:17:02.000Z</published>
    <updated>2020-11-10T13:22:22.296Z</updated>
    
    <content type="html"><![CDATA[<img src="/2020/11/10/内核空间和用户空间/1.png"><p>内核空间与用户空间拷贝的时候，需要在用户空间找到物理地址，再拷贝到内核空间的物理地址中。如果物理地址刚好在一张页上，那么可以一次完成拷贝；但如果物理地址跨页，那么会进行跨页的拷贝，性能有所降低；再者，如果在内存中没有找到，那么会引发缺页中断，去对应磁盘地址上拷贝，性能会更低。</p><img src="/2020/11/10/内核空间和用户空间/2.png"><img src="/2020/11/10/内核空间和用户空间/3.png">]]></content>
    
    <summary type="html">
    
      
      
        &lt;img src=&quot;/2020/11/10/内核空间和用户空间/1.png&quot;&gt;
&lt;p&gt;内核空间与用户空间拷贝的时候，需要在用户空间找到物理地址，再拷贝到内核空间的物理地址中。如果物理地址刚好在一张页上，那么可以一次完成拷贝；但如果物理地址跨页，那么会进行跨页的拷贝，性能有所降低；
      
    
    </summary>
    
      <category term="linux" scheme="http://twh233.github.io/categories/linux/"/>
    
    
      <category term="linux" scheme="http://twh233.github.io/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>skynet</title>
    <link href="http://twh233.github.io/2020/11/08/skynet/"/>
    <id>http://twh233.github.io/2020/11/08/skynet/</id>
    <published>2020-11-08T11:35:34.000Z</published>
    <updated>2020-11-08T12:25:31.920Z</updated>
    
    <content type="html"><![CDATA[<h2 id="多核开发与actor模型"><a href="#多核开发与actor模型" class="headerlink" title="多核开发与actor模型"></a>多核开发与actor模型</h2><ol><li><p>多进程<br> a) 消息队列  </p><pre><code>i. 协议问题  ii. 断线重连  iii. 进程启动顺序问题  iv. 负载均衡问题  v. 数据同步问题  </code></pre><p> b) RPC  </p><pre><code>i. 两个系统保持同步问题   </code></pre><p> c) zk    </p><pre><code>i. 配置项管理问题  ii. 集群管理   iii. 统一命名问题  iv. 状态同步问题  v. 分布式锁问题    </code></pre><p> d) 拆分  </p><pre><code>i. 功能拆分  ii. 热点拆分  </code></pre></li><li><p>多线程  </p></li><li>并发模型：CSP 模型 与 actor 模型  </li><li>结论：多进程并发实体是进程，多线程并发实体是线程，go 并发实体是 goroutine（协程），actor 并发实体是 actor（语言层面抽象出来的“进程”）。它们都是在隔离性（运行环境）与统一性（数据统一）之间作取舍平衡，而 actor 模型在语言层面做运行环境的隔离，数据同步依然需要通过消息来同步。actor 模型是加强版的多进程解决方案，进程间通信由<br>socket 转为指针的传递，从而通信变得更加可靠，同时多进程解决方案中，公共开源组件（消息队列，rpc，zookeeper）解决的问题，在 actor 模型中处理起来更方便。  </li><li>actor 定义：<br> a) 用于并行计算<br> b) actor 是最基本的计算单元<br> c) 基于消息计算<br> d) actor 之间通过消息沟通并且相互隔离  </li></ol><h2 id="skynet中的actor模型"><a href="#skynet中的actor模型" class="headerlink" title="skynet中的actor模型"></a>skynet中的actor模型</h2><ol><li>结构组成<br> a) 隔离的环境（内存块或 lua 虚拟机）<br> b) 消息队列<br> c) 回调函数  </li><li>实现<br> a) logger 服务 service-src/service_logger.c<br> b) lua 服务启动器 service-src/service_snlua.c  </li></ol><h2 id="actor运行以及消息调度"><a href="#actor运行以及消息调度" class="headerlink" title="actor运行以及消息调度"></a>actor运行以及消息调度</h2><img src="/2020/11/08/skynet/1.png"><ol><li>消息队列<br> a) 全局消息队列<br> b) actor 消息队列   </li><li>skynet 中锁的使用<br> a) 互斥锁  <pre><code>{% asset_img 2.png %}  </code></pre> b) 自旋锁  <pre><code>worker 轮询消息队列  {% asset_img 3.png %} </code></pre> c) 读写锁  <pre><code>handle_storage  </code></pre> d) 条件变量  <pre><code>worker 线程的休眠  </code></pre></li><li>skynet 中线程<br> a) timer<br> b) socket<br> c) worker<pre><code>i. “权重”来定制消费消息的数量（-1 消费一个，0 全部消费，1 消费一半）  ii. 休眠（条件变量）与唤醒（timer 和 socket）</code></pre> d) monitor  <pre><code>i. 检查服务消息过载</code></pre></li></ol><img src="/2020/11/08/skynet/5.png">  <img src="/2020/11/08/skynet/6.png"><h2 id="skynet网络层"><a href="#skynet网络层" class="headerlink" title="skynet网络层"></a>skynet网络层</h2><h3 id="actor-需要网络事件绑定？"><a href="#actor-需要网络事件绑定？" class="headerlink" title="actor 需要网络事件绑定？"></a>actor 需要网络事件绑定？</h3><p>1.connetfd 跟 redis  接受redis的数据<br>2.clientfd<br>3.listenfd clientfd = accept(); skynet作为客户端连接其他服务fd<br>4.管道fd 管道读端  work 线程往管道写端写数据  socket线程在管道读端读数据</p><p>worker在发送数据的时候 try_spinlock() 拿到锁，直接在worker线程将数据发送出去，其他情况在socket线程</p><img src="/2020/11/08/skynet/4.jpg"> <h3 id="阻塞IO与非阻塞IO的区别"><a href="#阻塞IO与非阻塞IO的区别" class="headerlink" title="阻塞IO与非阻塞IO的区别"></a>阻塞IO与非阻塞IO的区别</h3><ol><li>阻塞网络线程</li><li>在于没有数据到达的时候是否立刻返回</li><li>fnctl fd noblock(recv/send  read/write)决定了IO是否阻塞</li></ol><p>read(fd,buf,sz)<br>recv(fd,buf,sz,0)</p><h2 id="lua-与-c-接口编程"><a href="#lua-与-c-接口编程" class="headerlink" title="lua 与 c 接口编程"></a>lua 与 c 接口编程</h2><ol><li>元表<br> a) 定制行为 <strong>index, </strong>newindex<br> b) 只有 table 和 userdata 对象有独自的元表，其他类型只有类型元表<br> c) 只有 table 可以在 lua 中修改设置元表<br> d) userdata 只能在 c 中修改设置元表，lua 中不能修改 userdata 元表  </li><li>协程<br> a) 一段独立的执行线程<br> b) 一个 lua 虚拟机中同时只能有一个协程在运行<br> c) 目的：写的时候是同步的书写方式，而实际内部是异步非阻塞的实现   <img src="/2020/11/08/skynet/8.png"> </li><li>闭包<br> a) 表现  <pre><code>i. 函数内部可以访问函数外部的变量  ii. lua 文件是一个匿名函数  </code></pre> b) 实现  <pre><code>i. c 函数以及绑定在 c 函数上的 upvalues(上值)  </code></pre> c) 用 lua_pushcclosure 用来创建 c 闭包<br> d) 通过 lua_upvalueindex 伪索引来获取上值  </li><li>虚拟栈<br> 通过虚拟栈实现两者的读写数据操作   <img src="/2020/11/08/skynet/7.png"> </li><li>注册表<br> a) 预定义的表，用来保存任何 c 代码想保存的 lua 值<br> b) 使用 LUA_REGISTRYINDEX 来索引  </li></ol><h2 id="actor-通信"><a href="#actor-通信" class="headerlink" title="actor 通信"></a>actor 通信</h2><ol><li>skynet.send/skynet.call  </li><li>skynet.redirect  </li><li>skynet.response  </li><li>skynet.ret  </li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;多核开发与actor模型&quot;&gt;&lt;a href=&quot;#多核开发与actor模型&quot; class=&quot;headerlink&quot; title=&quot;多核开发与actor模型&quot;&gt;&lt;/a&gt;多核开发与actor模型&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;多进程&lt;br&gt; a) 消息队列  &lt;/p&gt;
      
    
    </summary>
    
      <category term="skynet" scheme="http://twh233.github.io/categories/skynet/"/>
    
    
      <category term="skynet" scheme="http://twh233.github.io/tags/skynet/"/>
    
  </entry>
  
  <entry>
    <title>工作中遇到的问题</title>
    <link href="http://twh233.github.io/2020/11/04/%E5%B7%A5%E4%BD%9C%E4%B8%AD%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98/"/>
    <id>http://twh233.github.io/2020/11/04/工作中遇到的问题/</id>
    <published>2020-11-04T14:15:10.000Z</published>
    <updated>2020-11-05T13:40:24.176Z</updated>
    
    <content type="html"><![CDATA[<p>1.result 等字段可重用的可以考虑重用节约内存<br>2.不要在客户端请求的时候处理数据，提前处理好，客户端请求直接返回<br>3.从数据库拿出来的数据都是数组，需要取ret[1]<br>4.可以从过参数传递函数，做定时器处理<br>5.数据库日志分得越详细越好，不同功能的表尽量分开<br>6.节点与节点间尽量一次性调用，避免绕圈调用<br>7.逻辑不与客户端同步，尽量保持单请求也能有反馈<br>8.在agent的监听，下线记得清除或者在task_msg_center.lua去统一<br>9.lua是协程，有的情况也得考虑下锁的问题<br>10.mysql中，<br>varchar 存储变长的字符串，但需要1个或2个额外字节记录字符串长度；<br>char 存储定长的字符串。<br>DataTime 8字节，TimeStamp 4字节。<br>能用TinyInt的话不要用Int。<br>索引在where条件查询和group by查询的时候特别有效。<br>11.查询优化：<br>(1 避免查找无关列<br>(2 分解关联查询，减少锁竞争<br>(3 用=不用&lt;&gt;，”=” 增加了索引使用几率<br>(4 UNION ALL 不去重，效率高于UNION<br>(5 数据行长度不要超过8020字节，超过这个长度会占用两行<br>(6 能用数字类型的字段尽量选择数字类型而不用字符串类型（电话号码），这会降低查询和连接性能，并会增加存储开销<br>(7 对于不可变char和可变varchar，char查询快，但是耗空间，varchar慢一些，但是节省存储空间<br>(8 避免在where子句进行null判断或者用or来连接条件<br>select id from t where num = 10 or num = 20;<br>select id from t where num = 10 union all select id from t where num = 20;<br>(9 in 和 not in 慎用。对于连续的数值能用between就不要用in<br>select id from t where num in (1,2,3);<br>select id from t where num between 1 and 3;<br>(10 避免在where子句中对字段进行操作<br>select id from t where substring(name,1,3) = ‘abc’;<br>select <em> from T1 where F1 = 100 </em> 2;<br>12.DATA.match_config.signup_data_config.signup_dur 变量过长用简写local变量代替<br>13.数据结构先行，不能到后面再来补数据结构<br>14.有些数据可以考虑不写数据库<br>15.lua for k,v in pairs(table)  如果v是普通类型，直接修改v不会导致table的数据变化，如果v也是table 修改v同时会修改table<br>16.用local变量等于一张表的时候，对local变量修改之后，最后把变量重新赋值给表  </p><pre><code>local s = _table or {}s.v = 1  _table = s  </code></pre><p>17.设计功能时，考虑多方面情况，例如托管节点崩溃，上一场的崩溃是否影响下一场，避免这种情况<br>18.脑里构建模块化，无论是函数还是功能，可以分函数，分文件来写<br>19.做完功能，设计好处理崩溃的函数，例如查询在比赛里的人或者PUBLIC.exit()  </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;1.result 等字段可重用的可以考虑重用节约内存&lt;br&gt;2.不要在客户端请求的时候处理数据，提前处理好，客户端请求直接返回&lt;br&gt;3.从数据库拿出来的数据都是数组，需要取ret[1]&lt;br&gt;4.可以从过参数传递函数，做定时器处理&lt;br&gt;5.数据库日志分得越详细越好，不同
      
    
    </summary>
    
      <category term="基础" scheme="http://twh233.github.io/categories/%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="基础" scheme="http://twh233.github.io/tags/%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>Nginx添加Handle模块</title>
    <link href="http://twh233.github.io/2020/11/03/Nginx%E6%B7%BB%E5%8A%A0Handle%E6%A8%A1%E5%9D%97/"/>
    <id>http://twh233.github.io/2020/11/03/Nginx添加Handle模块/</id>
    <published>2020-11-03T15:01:42.000Z</published>
    <updated>2020-11-03T15:17:12.408Z</updated>
    
    <content type="html"><![CDATA[<p>nginx 三种类型</p><p>1.upstream 负载均衡，只转发不返回<br>2.handle 接受请求，直接可以处理<br>3.filter 服务器reponse 验证  </p><p>ngx_http_pagecount_module.c</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">#include &lt;ngx_http.h&gt;</span><br><span class="line">#include &lt;ngx_config.h&gt;</span><br><span class="line">#include &lt;ngx_core.h&gt;</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">#include &lt;arpa/inet.h&gt;</span><br><span class="line">#include &lt;netinet/in.h&gt;</span><br><span class="line">*/</span><br><span class="line">#define ENABLE_RBTREE1</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">static char *ngx_http_count_module_set(ngx_conf_t *cf, ngx_command_t *cmd, void *conf);</span><br><span class="line">static ngx_int_t ngx_http_count_module_handler(ngx_http_request_t *r);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">static ngx_command_t count_commands[] = &#123;</span><br><span class="line">&#123;</span><br><span class="line">ngx_string(&quot;count&quot;),</span><br><span class="line">NGX_HTTP_LOC_CONF | NGX_CONF_NOARGS,</span><br><span class="line">ngx_http_count_module_set,</span><br><span class="line">NGX_HTTP_LOC_CONF_OFFSET,</span><br><span class="line">0, NULL</span><br><span class="line">&#125;,</span><br><span class="line">ngx_null_command</span><br><span class="line">&#125;;</span><br><span class="line">// 8个NULL</span><br><span class="line">static ngx_http_module_t count_ctx = &#123;</span><br><span class="line">NULL,</span><br><span class="line">NULL,</span><br><span class="line"></span><br><span class="line">NULL,</span><br><span class="line">NULL,</span><br><span class="line"></span><br><span class="line">NULL,</span><br><span class="line">NULL,</span><br><span class="line"></span><br><span class="line">NULL,</span><br><span class="line">NULL,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">//ngx_http_count_module </span><br><span class="line">ngx_module_t ngx_http_count_module = &#123;</span><br><span class="line">NGX_MODULE_V1,</span><br><span class="line">&amp;count_ctx,</span><br><span class="line">count_commands,</span><br><span class="line">NGX_HTTP_MODULE,</span><br><span class="line">NULL,</span><br><span class="line">NULL,</span><br><span class="line">NULL,</span><br><span class="line">NULL,</span><br><span class="line">NULL,</span><br><span class="line">NULL,</span><br><span class="line">NULL,</span><br><span class="line">NGX_MODULE_V1_PADDING</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">typedef struct &#123;</span><br><span class="line">int count; //count</span><br><span class="line">struct in_addr addr; //ip</span><br><span class="line">&#125; ngx_pv_table;</span><br><span class="line"></span><br><span class="line">ngx_pv_table pv_table[256];</span><br><span class="line"></span><br><span class="line">#if ENABLE_RBTREE</span><br><span class="line">ngx_rbtree_t ngx_pv_tree; // 红黑树</span><br><span class="line">ngx_rbtree_node_t sentinel; // 哨兵结点</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">static void</span><br><span class="line">ngx_pagecount_rbtree_insert_value(ngx_rbtree_node_t *temp,</span><br><span class="line">    ngx_rbtree_node_t *node, ngx_rbtree_node_t *sentinel)</span><br><span class="line">&#123;</span><br><span class="line">    ngx_rbtree_node_t    **p;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    for ( ;; ) &#123;</span><br><span class="line"></span><br><span class="line">        if (node-&gt;key &lt; temp-&gt;key) &#123;</span><br><span class="line"></span><br><span class="line">            p = &amp;temp-&gt;left;</span><br><span class="line"></span><br><span class="line">        &#125; else if (node-&gt;key &gt; temp-&gt;key) &#123;</span><br><span class="line"></span><br><span class="line">            p = &amp;temp-&gt;right;</span><br><span class="line"></span><br><span class="line">        &#125; else &#123; /* node-&gt;key == temp-&gt;key */</span><br><span class="line"></span><br><span class="line">           return ;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (*p == sentinel) &#123;</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        temp = *p;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    *p = node;</span><br><span class="line">    node-&gt;parent = temp;</span><br><span class="line">    node-&gt;left = sentinel;</span><br><span class="line">    node-&gt;right = sentinel;</span><br><span class="line">    ngx_rbt_red(node);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">static char *ngx_http_count_module_set(ngx_conf_t *cf, ngx_command_t *cmd, void *conf) &#123;</span><br><span class="line">#if ENABLE_RBTREE</span><br><span class="line">ngx_rbtree_init(&amp;ngx_pv_tree, &amp;sentinel, ngx_pagecount_rbtree_insert_value); //初始化红黑树</span><br><span class="line">#endif</span><br><span class="line">ngx_http_core_loc_conf_t *corecf = ngx_http_conf_get_module_loc_conf(cf, ngx_http_core_module);</span><br><span class="line">corecf-&gt;handler = ngx_http_count_module_handler; //注册handler</span><br><span class="line"></span><br><span class="line">return NGX_CONF_OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#if ENABLE_RBTREE</span><br><span class="line"></span><br><span class="line">//char content[1024];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//回调html组装函数</span><br><span class="line">void ngx_http_count_rbtree_iterator(ngx_rbtree_node_t *node, char *html) &#123;</span><br><span class="line"></span><br><span class="line">char buffer[128] = &#123;0&#125;;</span><br><span class="line"></span><br><span class="line">struct in_addr addr = &#123;0&#125;;</span><br><span class="line">memcpy(&amp;addr, &amp;node-&gt;key, sizeof(struct in_addr));</span><br><span class="line"></span><br><span class="line">sprintf(buffer, &quot;req from : %s, count: %d &lt;br/&gt;&quot;,</span><br><span class="line">inet_ntoa(addr), node-&gt;value);</span><br><span class="line"></span><br><span class="line">strcat(html, buffer);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">static int ngx_encode_http_page_rb(char *html) &#123;</span><br><span class="line"></span><br><span class="line">sprintf(html, &quot;&lt;h1&gt;Source Insight &lt;/h1&gt;&quot;);</span><br><span class="line">strcat(html, &quot;&lt;h2&gt;&quot;);</span><br><span class="line"></span><br><span class="line">ngx_rbtree_traversal(&amp;ngx_pv_tree, ngx_pv_tree.root, ngx_http_count_rbtree_iterator, html);</span><br><span class="line"></span><br><span class="line">strcat(html, &quot;&lt;/h2&gt;&quot;);</span><br><span class="line"></span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#else</span><br><span class="line"></span><br><span class="line">#if 1</span><br><span class="line">static int ngx_encode_http_page(char *html) &#123;</span><br><span class="line">sprintf(html, &quot;&lt;h1&gt;Source Insight &lt;/h1&gt;&quot;);</span><br><span class="line">strcat(html, &quot;&lt;h2&gt;&quot;);</span><br><span class="line"></span><br><span class="line">int i = 0;</span><br><span class="line">for (i = 0;i &lt; 256;i ++) &#123;</span><br><span class="line">if (pv_table[i].count != 0) &#123;</span><br><span class="line"></span><br><span class="line">char str[INET_ADDRSTRLEN] = &#123;0&#125;;</span><br><span class="line">char buffer[128] = &#123;0&#125;;</span><br><span class="line"></span><br><span class="line">sprintf(buffer, &quot;req from : %s, count: %d &lt;br/&gt;&quot;,</span><br><span class="line">inet_ntop(AF_INET, &amp;pv_table[i].addr, str, sizeof(str)), pv_table[i].count);</span><br><span class="line"></span><br><span class="line">strcat(html, buffer);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">strcat(html, &quot;&lt;/h2&gt;&quot;);</span><br><span class="line"></span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">static ngx_int_t ngx_http_count_module_handler(ngx_http_request_t *r) &#123;</span><br><span class="line">#if 0</span><br><span class="line">u_char html[1024] = &quot;&lt;h1&gt; bailang, Reese, feifei, qizhewoniuqukandahai, huihuisasa, magic, jianyuebujiandan, yuan &lt;/h1&gt;&quot;;</span><br><span class="line">int len = sizeof(html);</span><br><span class="line">#elif 1</span><br><span class="line"></span><br><span class="line">u_char html[1024] = &#123;0&#125;;</span><br><span class="line">int len = sizeof(html);</span><br><span class="line"></span><br><span class="line">#if ENABLE_RBTREE</span><br><span class="line">ngx_rbtree_node_t *node = NULL;</span><br><span class="line">ngx_rbtree_key_t key = 0;</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">struct sockaddr_in *client_addr =  (struct sockaddr_in*)r-&gt;connection-&gt;sockaddr;</span><br><span class="line">//rbtree &lt;key, value&gt;  --&gt; &lt;addr, count&gt;</span><br><span class="line"></span><br><span class="line">int idx = client_addr-&gt;sin_addr.s_addr &gt;&gt; 24;</span><br><span class="line"></span><br><span class="line">//rbtree --&gt; (key, value)</span><br><span class="line">pv_table[idx].count ++;</span><br><span class="line">memcpy(&amp;pv_table[idx].addr, &amp;client_addr-&gt;sin_addr, sizeof(client_addr-&gt;sin_addr));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#if ENABLE_RBTREE</span><br><span class="line"></span><br><span class="line">key = (ngx_rbtree_key_t)client_addr-&gt;sin_addr.s_addr;</span><br><span class="line">ngx_log_error(NGX_LOG_EMERG, r-&gt;connection-&gt;log, ngx_errno, &quot; ngx_http_count_module_handler --&gt; %x\n&quot;, key);</span><br><span class="line">node = ngx_rbtree_search(&amp;ngx_pv_tree, key); // 从红黑树中找</span><br><span class="line">ngx_log_error(NGX_LOG_EMERG, r-&gt;connection-&gt;log, ngx_errno, &quot; 11111 --&gt; %x\n&quot;, key);</span><br><span class="line"></span><br><span class="line">// 处理红黑树存储结点</span><br><span class="line">if (node == &amp;sentinel) &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">ngx_log_error(NGX_LOG_EMERG, r-&gt;connection-&gt;log, ngx_errno, &quot; new node insert rbtree\n&quot;, key);</span><br><span class="line">node = ngx_pcalloc(r-&gt;pool, sizeof(ngx_rbtree_node_t));</span><br><span class="line">node-&gt;key = (ngx_rbtree_key_t)client_addr-&gt;sin_addr.s_addr;</span><br><span class="line">node-&gt;value = 1;</span><br><span class="line"></span><br><span class="line">ngx_rbtree_insert(&amp;ngx_pv_tree, node);</span><br><span class="line">&#125; else &#123;</span><br><span class="line">node-&gt;value ++;</span><br><span class="line"></span><br><span class="line">ngx_log_error(NGX_LOG_EMERG, r-&gt;connection-&gt;log, ngx_errno, &quot; node is exist, value:%d\n&quot;, node-&gt;value);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//memset(content, 0, 1024);</span><br><span class="line"></span><br><span class="line">ngx_encode_http_page_rb((char*)html);</span><br><span class="line"></span><br><span class="line">ngx_log_error(NGX_LOG_EMERG, r-&gt;connection-&gt;log, ngx_errno, &quot; html: %s\n&quot;, html);</span><br><span class="line"></span><br><span class="line">//memcpy(html, content, len);</span><br><span class="line">#else</span><br><span class="line"></span><br><span class="line">ngx_encode_http_page((char*)html);</span><br><span class="line"></span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">#else</span><br><span class="line"></span><br><span class="line">// ---------------------------- 下面组装 http response -------------------------</span><br><span class="line"></span><br><span class="line">struct sockaddr_in *client_addr =  (struct sockaddr_in*)r-&gt;connection-&gt;sockaddr;</span><br><span class="line">ngx_rbtree_node_t *node = ngx_pcalloc(r-&gt;pool,  sizeof(ngx_rbtree_node_t));</span><br><span class="line"></span><br><span class="line">memcpy(&amp;node-&gt;key, &amp;client_addr-&gt;sin_addr.s_addr, sizeof(node-&gt;key));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#endif</span><br><span class="line">//header</span><br><span class="line">r-&gt;headers_out.status = 200;</span><br><span class="line">ngx_str_set(&amp;r-&gt;headers_out.content_type, &quot;text/html&quot;);</span><br><span class="line">ngx_http_send_header(r);</span><br><span class="line"></span><br><span class="line">//body</span><br><span class="line">ngx_buf_t *b = ngx_pcalloc(r-&gt;pool,  sizeof(ngx_buf_t)); // 从内存池中malloc</span><br><span class="line"></span><br><span class="line">ngx_chain_t out;</span><br><span class="line">out.buf = b;</span><br><span class="line">out.next = NULL;</span><br><span class="line"></span><br><span class="line">b-&gt;pos = html;</span><br><span class="line">b-&gt;last = html+len;</span><br><span class="line">b-&gt;memory = 1;</span><br><span class="line">b-&gt;last_buf = 1;</span><br><span class="line"></span><br><span class="line">return ngx_http_output_filter(r, &amp;out); //http response</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>config </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ngx_addon_name=ngx_http_pagecount_module</span><br><span class="line">HTTP_MODULES=&quot;$HTTP_MODULES ngx_http_pagecount_module&quot;</span><br><span class="line">NGX_ADDON_SRCS=&quot;$NGX_ADDON_SRCS $ngx_addon_dir/pagecount_module.c&quot;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;nginx 三种类型&lt;/p&gt;
&lt;p&gt;1.upstream 负载均衡，只转发不返回&lt;br&gt;2.handle 接受请求，直接可以处理&lt;br&gt;3.filter 服务器reponse 验证  &lt;/p&gt;
&lt;p&gt;ngx_http_pagecount_module.c&lt;/p&gt;
&lt;figu
      
    
    </summary>
    
      <category term="nginx" scheme="http://twh233.github.io/categories/nginx/"/>
    
    
      <category term="nginx" scheme="http://twh233.github.io/tags/nginx/"/>
    
  </entry>
  
  <entry>
    <title>mysql面试前看</title>
    <link href="http://twh233.github.io/2020/11/02/mysql%E9%9D%A2%E8%AF%95%E5%89%8D%E7%9C%8B/"/>
    <id>http://twh233.github.io/2020/11/02/mysql面试前看/</id>
    <published>2020-11-02T15:42:49.000Z</published>
    <updated>2020-11-02T15:43:13.585Z</updated>
    
    <content type="html"><![CDATA[<h2 id="InnoDB-MyISAM-区别"><a href="#InnoDB-MyISAM-区别" class="headerlink" title="InnoDB MyISAM 区别"></a>InnoDB MyISAM 区别</h2><p>InnoDB 支持崩溃后安全恢复，MyISAM 不支持崩溃后安全恢复；<br>InnoDB 支持行级锁，MyISAM 不支持行级锁，只支持到表锁；<br>InnoDB 支持外键，MyISAM 不支持外键；<br>MyISAM 性能比 InnoDB 高；<br>MyISAM 支持 FULLTEXT 类型的全文索引，InnoDB 不支持 FULLTEXT 类型的全文索引，但是 InnoDB 可以使用 sphinx 插件支持全文索引，并且效果更好；<br>InnoDB 主键查询性能高于 MyISAM。</p><h3 id="InnoDB"><a href="#InnoDB" class="headerlink" title="InnoDB"></a>InnoDB</h3><p>1）插入缓冲<br>2）两次写<br>两次写给 InnoDB 带来的是可靠性，主要用来解决部分写失败</p><p>3）自适应哈希索引</p><p>InnoDB 自增主键持久化 Mysql重启后在redo log日志中恢复<br>InnoDB 使用事务实现，而事务的设计使用了多版本并发控制，不能把总条数记录下来。</p><p>在 InnoDB 引擎中 count(<em>)、count(1)、count(主键)、count(字段) 哪个性能最高？<br>count(字段)&lt;count(主键 id)&lt;count(1)≈count(</em>) 题目解析：</p><p>对于 count(主键 id) 来说，InnoDB 引擎会遍历整张表，把每一行的 id 值都取出来，返回给 server 层。server 层拿到 id 后，判断是不可能为空的，就按行累加。<br>对于 count(1) 来说，InnoDB 引擎遍历整张表，但不取值。server 层对于返回的每一行，放一个数字“1”进去，判断是不可能为空的，按行累加。<br>对于 count(字段) 来说，如果这个“字段”是定义为 not null 的话，一行行地从记录里面读出这个字段，判断不能为 null，按行累加；如果这个“字段”定义允许为 null，那么执行的时候，判断到有可能是 null，还要把值取出来再判断一下，不是 null 才累加。<br>对于 count(*) 来说，并不会把全部字段取出来，而是专门做了优化，不取值，直接按行累加。  </p><h2 id="重建表的执行流程"><a href="#重建表的执行流程" class="headerlink" title="重建表的执行流程"></a>重建表的执行流程</h2><p>建立一个临时文件，扫描表 t 主键的所有数据页；<br>用数据页中表 t 的记录生成 B+ 树，存储到临时文件中；<br>生成临时文件的过程中，将所有对 t 的操作记录在一个日志文件（row log）中；<br>临时文件生成后，将日志文件中的操作应用到临时文件，得到一个逻辑数据上与表 t相同的数据文件；<br>用临时文件替换表 t 的数据文件。  </p><h2 id="并发事务带来哪些问题"><a href="#并发事务带来哪些问题" class="headerlink" title="并发事务带来哪些问题"></a>并发事务带来哪些问题</h2><p>脏读 修改丢失 不可重复读 幻读</p><h3 id="什么是脏读和幻读？"><a href="#什么是脏读和幻读？" class="headerlink" title="什么是脏读和幻读？"></a>什么是脏读和幻读？</h3><p>脏读是一个事务在处理过程中读取了另外一个事务未提交的数据；幻读是指同一个事务内多次查询返回的结果集不一样（比如增加了或者减少了行记录）。</p><h3 id="如何避免幻读"><a href="#如何避免幻读" class="headerlink" title="如何避免幻读"></a>如何避免幻读</h3><p>使用间隙锁的方式来避免出现幻读。间隙锁，是专门用于解决幻读这种问题的锁，它锁的了行与行之间的间隙，能够阻塞新插入的操作 间隙锁的引入也带来了一些新的问题，比如：降低并发度，可能导致死锁。</p><h2 id="delete-和-truncate-区别"><a href="#delete-和-truncate-区别" class="headerlink" title="delete 和 truncate 区别"></a>delete 和 truncate 区别</h2><p>delete 可以添加 where 条件删除部分数据，truncate 不能添加 where 条件只能删除整张表；<br>delete 的删除信息会在 MySQL 的日志中记录，而 truncate 的删除信息不被记录在 MySQL 的日志中，因此 detele 的信息可以被找回而 truncate 的信息无法被找回；<br>truncate 因为不记录日志所以执行效率比 delete 快。  </p><h2 id="视图"><a href="#视图" class="headerlink" title="视图"></a>视图</h2><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><p>获取数据更容易，相对于多表查询来说；<br>视图能够对机密数据提供安全保护；<br>视图的修改不会影响基本表，提供了独立的操作单元，比较轻量。  </p><h2 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h2><h3 id="唯一索引和普通索引哪个性能更好？"><a href="#唯一索引和普通索引哪个性能更好？" class="headerlink" title="唯一索引和普通索引哪个性能更好？"></a>唯一索引和普通索引哪个性能更好？</h3><p>对于查询操作来说：普通索引和唯一索引的性能相近，都是从索引树中进行查询；<br>对于更新操作来说：唯一索引要比普通索引执行的慢，因为唯一索引需要先将数据读取到内存中，再在内存中进行数据的唯一效验，所以执行起来要比普通索引更慢。  </p><h3 id="如何优化身份证的索引？"><a href="#如何优化身份证的索引？" class="headerlink" title="如何优化身份证的索引？"></a>如何优化身份证的索引？</h3><p>在中国因为前 6 位代表的是地区，所以很多人的前六位都是相同的，如果我们使用前缀索引为 6 位的话，性能提升也并不是很明显，但如果设置的位数过长，那么占用的磁盘空间也越大，数据页能放下的索引值就越少，搜索效率也越低。针对这种情况优化方案有以下两种：  </p><p>使用身份证倒序存储，这样设置前六位的意义就很大了；<br>使用 hash 值，新创建一个字段用于存储身份证的 hash 值。  </p><h2 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h2><p>原子性（Atomic）：要么全部执行，要么全部不执行；<br>一致性（Consistency）：事务的执行使得数据库从一种正确状态转化为另一种正确状态；<br>隔离性（Isolation）：在事务正确提交之前，不允许把该事务对数据的任何改变提供给其他事务；<br>持久性（Durability）：事务提交后，其结果永久保存在数据库中。  </p><h3 id="四种事务隔离级别"><a href="#四种事务隔离级别" class="headerlink" title="四种事务隔离级别"></a>四种事务隔离级别</h3><p>read uncommited：未提交读，读到未提交数据；<br>read committed：读已提交，也叫不可重复读，两次读取到的数据不一致；<br>repetable read：可重复读；<br>serializable：串行化，读写数据都会锁住整张表，数据操作不会出错，但并发性能极低，开发中很少用到。  </p><h3 id="MVCC"><a href="#MVCC" class="headerlink" title="MVCC"></a>MVCC</h3><p>MVCC 全称是多版本并发控制系统，InnoDB 和 Falcon 存储引擎通过多版本并发控制（MVCC，Multiversion Concurrency Control）机制解决幻读问题。</p><p>InnoDB 的 MVCC 是通过在每行记录后面保存两个隐藏的列来实现，这两个列一个保存了行的创建时间，一个保存行的过期时间（删除时间）。当然存储的并不是真实的时间而是系统版本号（system version number）。每开始一个新的事务，系统版本号都会自动新增，事务开始时刻的系统版本号会作为事务的版本号，用来查询到每行记录的版本号进行比较。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;InnoDB-MyISAM-区别&quot;&gt;&lt;a href=&quot;#InnoDB-MyISAM-区别&quot; class=&quot;headerlink&quot; title=&quot;InnoDB MyISAM 区别&quot;&gt;&lt;/a&gt;InnoDB MyISAM 区别&lt;/h2&gt;&lt;p&gt;InnoDB 支持崩溃后安全
      
    
    </summary>
    
      <category term="mysql" scheme="http://twh233.github.io/categories/mysql/"/>
    
    
      <category term="mysql" scheme="http://twh233.github.io/tags/mysql/"/>
    
  </entry>
  
</feed>
