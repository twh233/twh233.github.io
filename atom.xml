<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Twh233&#39;s Blog</title>
  
  <subtitle>Love Coding,Enjoy Life</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://twh233.github.io/"/>
  <updated>2020-12-28T12:12:01.216Z</updated>
  <id>http://twh233.github.io/</id>
  
  <author>
    <name>Twh233</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>mysql集群与性能优化</title>
    <link href="http://twh233.github.io/2020/12/28/Mysql%E9%9B%86%E7%BE%A4%E4%B8%8E%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    <id>http://twh233.github.io/2020/12/28/Mysql集群与性能优化/</id>
    <published>2020-12-28T11:50:00.000Z</published>
    <updated>2020-12-28T12:12:01.216Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Mysql与Redis数据同步"><a href="#Mysql与Redis数据同步" class="headerlink" title="Mysql与Redis数据同步"></a>Mysql与Redis数据同步</h2><p>1.func() {<br>    write to mysql;<br>    write to redis;<br>}<br>2.mysql 触发器 调用存储redis，只能处理小数据<br>3.主从同步  mysql binlog -&gt; redis  (Canal)</p><img src="/2020/12/28/Mysql集群与性能优化/2.png"><p>parser -&gt; slave<br>slave -&gt; redis client<br>store -&gt; 避免数据丢失</p><h2 id="MySQL-Replication"><a href="#MySQL-Replication" class="headerlink" title="MySQL Replication"></a>MySQL Replication</h2><p>主从复制是通过重放 binlog 实现主库数据的<br>异步复制。即当主库执行了一条 sql 命令，那么在从库同样的执行一遍，从而达到主从复制的效果。在这个过程中，master 对数据的写操作记入二进制日志文件中(binlog)，生成一个 log dump 线程，用来给从库的 i/o 线程传 binlog。而从库的 i/o 线程去请求主库的binlog，并将得到的 binlog 日志写到中继日志（relaylog）中，从库的 sql 线程，会读<br>取 relaylog 文件中的日志，并解析成具体操作，通过主从的操作一致，而达到最终数据一致。</p><p>其优势为：</p><ol><li>主从复制是 mysql 自带的，无需借助第三方。  </li><li>数据被删除，可以从 binlog 日志中恢复。  </li><li>配置较为简单方便。<br>其劣势为：</li><li>从库要从 binlog 获取数据并重放，这肯定与主库写入数据存在时间延迟，因此从库的数据总是要滞后主库。  </li><li>对主库与从库之间的网络延迟要求较高，若网络延迟太高，将加重上述的滞后，造成最终数据的不一致。  </li><li>单一的主节点挂了，将不能对外提供写服务。  </li></ol><h2 id="MySQL-Fabirc"><a href="#MySQL-Fabirc" class="headerlink" title="MySQL Fabirc"></a>MySQL Fabirc</h2><p>这是在 MySQL Replication 的基础上，增加了故障检测<br>与转移，自动数据分片功能。不过依旧是一主多从的结构，MySQL Fabirc 只有一个主节点，<br>区别是当该主节点挂了以后，会从从节点中选择一个来当主节点。</p><p>相比Replication，主节点挂了会重新拉一个从节点做主节点。<br>节点故障恢复 30 秒或更长（采用 InnoDB 存储引擎的都这样）。</p><h2 id="MySQL-Cluster"><a href="#MySQL-Cluster" class="headerlink" title="MySQL Cluster"></a>MySQL Cluster</h2><p>MySQL Cluster 是多主多从结构的<br>就各个集群方案来说，其优势为：</p><ol><li>mysql 官方提供的工具，无需第三方插件。  </li><li>高可用性优秀，99.999%的可用性，可以自动切分数据，能跨节点冗余数据（其数据集并不是存储某个特定的 MySQL 实例上，而是被分布在多个 Data Nodes 中，即一个 table 的数据可能被分散在多个物理节点上，任何数据都会在多个 Data Nodes 上冗余备份。任何一个数据变更操作，都将在一组 Data Nodes 上同步，以保证数据的一致性）。  </li><li>可伸缩性优秀，能自动切分数据，方便数据库的水平拓展。  </li><li>负载均衡优秀，可同时用于读操作、写操作都都密集的应用，也可以使用 SQL 和 NOSQL接口访问数据。  </li><li>多个主节点，没有单点故障的问题，节点故障恢复通常小于 1 秒。<br>其劣势为：</li><li>架构模式和原理很复杂。  </li><li>只能使用存储引擎 NDB ，与平常使用的 InnoDB 有很多明显的差距。比如在事务（其事务隔离级别只支持 Read Committed，即一个事务在提交前，查询不到在事务内所做的修改），外键（虽然最新的 NDB 存储引擎已经支持外键，但性能有问题，因为外键所关联的记录可能在别的分片节点），表限制上的不同，可能会导致日常开发出现意外。  </li><li>作为分布式的数据库系统，各个节点之间存在大量的数据通讯，比如所有访问都是需要经过超过一个节点（至少有一个 SQL Node 和一个 NDB Node）才能完成，因此对节点之间的内部互联网络带宽要求高。  </li><li>Data Node 数据会被尽量放在内存中，对内存要求大，而且重启的时候，数据节点将数据 load 到内存需要很长时间。  </li></ol><h2 id="MMM"><a href="#MMM" class="headerlink" title="MMM"></a>MMM</h2><p>双主多从结构，MMM 是在 MySQL Replication的基础上，对其进行优化。</p><img src="/2020/12/28/Mysql集群与性能优化/1.png"><p>这里的双主节点，虽然叫做双主复制，但是业务上同一时刻只允许对一个主进行写入，<br>另一台备选主上提供部分读服务，以加速在主主切换时刻备选主的预热。<br>就各个集群方案来说，其优势为：</p><ol><li>自动的主主 Failover 切换，一般 3s 以内切换备机。  </li><li>多个从节点读的负载均衡。<br>其劣势为：</li><li>无法完全保证数据的一致性。如主 1 挂了，MMM monitor 已经切换到主 2 上来了，而若此时双主复制中，主 2 数据落后于主 1（即还未完全复制完毕），那么此时的主 2 已经成为主节点，对外提供写服务，从而导致数据不一。  </li><li>由于是使用虚拟 IP 浮动技术，类似 Keepalived，故 RIP（真实 IP）要和 VIP（虚拟 IP）在同一网段。如果是在不同网段也可以，需要用到虚拟路由技术。但是绝对要在同一个 IDC机房，不可跨 IDC 机房组建集群。</li></ol><h2 id="Galera-Cluster"><a href="#Galera-Cluster" class="headerlink" title="Galera Cluster"></a>Galera Cluster</h2><p>Galera Cluster 是由 Codership 开发的 MySQL 多主结构集群，这些主节点互为其它节点的从节点。不同于 MySQL 原生的主从异步复制，Galera 采用的是多主同步复制，并针对同步复制过程中，会大概率出现的事务冲突和死锁进行优化，就是复制不基于官方 binlog 而是 Galera<br>复制插件，重写了 wsrep api。异步复制中，主库将数据更新传播给从库后立即提交事务，而不论从库是否成功读取或重放数据变化。这种情况下，在主库事务提交后短时间内，主从库数据并不一致。同步复制时，主库的单个更新事务需要在所有从库上同步 更新。换句话说，当主库提交事务时，集群中所有节点的数据保持一致。<br>对于读操作，从每个节点读取到的数据都是相同的。对于写操作，当数据写入某一节点后，集群会将其同步到其它节点。</p><p>能做到数据的强一致性，毫无疑问，也是以牺牲性能为代价。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Mysql与Redis数据同步&quot;&gt;&lt;a href=&quot;#Mysql与Redis数据同步&quot; class=&quot;headerlink&quot; title=&quot;Mysql与Redis数据同步&quot;&gt;&lt;/a&gt;Mysql与Redis数据同步&lt;/h2&gt;&lt;p&gt;1.func() {&lt;br&gt;    
      
    
    </summary>
    
      <category term="基础" scheme="http://twh233.github.io/categories/%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="分布式" scheme="http://twh233.github.io/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
      <category term="mysql" scheme="http://twh233.github.io/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>Kafaka与Zookeeper</title>
    <link href="http://twh233.github.io/2020/12/03/Kafaka%E4%B8%8EZookeeper/"/>
    <id>http://twh233.github.io/2020/12/03/Kafaka与Zookeeper/</id>
    <published>2020-12-03T15:11:34.000Z</published>
    <updated>2020-12-03T15:13:20.471Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Kafaka-总体架构"><a href="#Kafaka-总体架构" class="headerlink" title="Kafaka 总体架构"></a>Kafaka 总体架构</h2><img src="/2020/12/03/Kafaka与Zookeeper/1.png"><img src="/2020/12/03/Kafaka与Zookeeper/2.png"><p>Producer： 生产者，即消息发送者，Push 消息到 Kafka 集群的 Broker（就是 Server）中；<br>Broker： Kafka 集群由多个 Kafka 实例（Server）组成，每个实例构成一个 Broker，其实就是服务器；<br>Topic： Producer 向 Kafka 集群 Push 的消息会被归于某一类别，即 Topic。本质上，这只是一个逻辑概念，面向的对象是 Producer 和 Consumer，Producer 只需关注将消息 Push 到哪一个 Topic 中，而 Consumer 只需关心自己订阅了哪个 Topic；<br>Partition： 每个 Topic 又被分为多个 Partition，即物理分区。出于负载均衡的考虑，同一个 Topic 的 Partition 分别存储于 Kafka 集群的多个 Broker 上。而为了提高可靠性，这些 Partition 可以由 Kafka 机制中的 Replicas 来设置备份的数量。如上面框架图所示，每个 Partition 都存在两个备份；<br>Consumer： 消费者，从 Kafka 集群的 Broker 中 Pull 消息、消费消息；<br>Consumer Group： High-Level Consumer API 中，每个 Consumer 都属于一个 Consumer Group，每条消息只能被 Consumer Group 中的一个 Consumer 消费，但可以被多个 Consumer Group 消费；<br>Replicas： Partition 的副本，保障 Partition 的高可用；<br>Leader： Replicas 中的一个角色， Producer 和 Consumer 只与 Leader 交互；<br>Follower： Replicas 中的一个角色，从 Leader 中复制数据，作为它的副本，同时一旦某 Leader 挂掉，便会从它的所有 Follower 中选举出一个新的 Leader 继续提供服务；<br>Controller： Kafka 集群中的一个服务器，用来进行 Leader Election 以及各种 Fail Over；<br>Zookeeper： Kafka 通过 ZooKeeper 存储集群的 Meta 信息等，文中将详述。  </p><h2 id="Kafka-为什么要将-Topic-分区？"><a href="#Kafka-为什么要将-Topic-分区？" class="headerlink" title="Kafka 为什么要将 Topic 分区？"></a>Kafka 为什么要将 Topic 分区？</h2><p>Topic 只是逻辑概念，面向的是 Producer 和 Consumer，而 Partition 则是物理概念。可以想象，如果 Topic 不进行分区，而将 Topic 内的消息存储于一个 Broker，那么该 Topic 的所有读写请求都将由这个 Broker 处理，吞吐量很容易陷入瓶颈，这显然不适合高吞吐量应用场景。</p><p>有了 Partition 概念，假设一个 Topic 被分为 10 个 Partition，Kafka 会根据一定的算法将 10 个 Partition 尽可能均匀地分布到不同的 Broker（服务器）上。</p><h2 id="Kafka-文件存储机制"><a href="#Kafka-文件存储机制" class="headerlink" title="Kafka 文件存储机制"></a>Kafka 文件存储机制</h2><p>Partition 并不是最终的存储粒度，Partition 还可以进一步细分为 Segment。</p><h2 id="为什么不能以-Partition-作为存储单位？"><a href="#为什么不能以-Partition-作为存储单位？" class="headerlink" title="为什么不能以 Partition 作为存储单位？"></a>为什么不能以 Partition 作为存储单位？</h2><p>任何一个 Topic 中的 Partition 数量受限于 Kafka Broker 的数量。为了保证可靠性，每个 Partition 都应有若干个副本（Replica），其中一个 Replica 为 Leader，其它都为 Follower。Leader 负责处理 Partition 的所有读写请求，Follower 则负责被动地复制 Leader 上的数据。<br>基于 Segment 机制，可以很方便地清理那些陈旧的消息（已被消费的消息），从而提高磁盘的利用率。</p><h2 id="Segment-的工作原理是什么？"><a href="#Segment-的工作原理是什么？" class="headerlink" title="Segment 的工作原理是什么？"></a>Segment 的工作原理是什么？</h2><p>Partition 全局的第一个 Segment 从 0 开始，后续每个 Segment 文件名为上一个 Segment 文件最后一条消息的偏移量（Offset）值</p><img src="/2020/12/03/Kafaka与Zookeeper/3.png"><h2 id="复制原理和同步方式"><a href="#复制原理和同步方式" class="headerlink" title="复制原理和同步方式"></a>复制原理和同步方式</h2><p>Leader 副本：响应 Client 端读写请求的副本，Producer 和 Consumer 只跟 Leader 交互；<br>Follower 副本：被动地备份 Leader 副本中的数据，不能响应 Client 端读写请求。一旦 Leader 挂掉，会从它的 Follower 中选举出一个新的 Leader 继续提供服务；<br>ISR 副本：包含了 Leader 副本和所有与 Leader 副本保持同步的 Follower 副本。如何判定是否与 Leader 同步，后面详述。  </p><p>Leader 将负责维护和跟踪一个 ISR（In-Sync Replicas）列表，即同步副本队列，这个列表里面的副本与 Leader 保持同步，状态一致。</p><h3 id="ISR"><a href="#ISR" class="headerlink" title="ISR"></a>ISR</h3><p>Follower 从 Leader 那里同步数据会有一些延迟（由参数 replica.lag.time.max.ms 设置超时阈值），超过阈值的 Follower 将被剔除出 ISR， 存入 OSR（Outof-Sync Replicas）列表，新加入的 Follower 也会先存放在 OSR 中，即有关系式 AR=ISR+OSR  </p><h3 id="LEO-amp-HW"><a href="#LEO-amp-HW" class="headerlink" title="LEO &amp; HW"></a>LEO &amp; HW</h3><p>LEO=10、HW=7，则表示该副本保存了 10 条消息，而后面 3 条处于 Uncommitted 状态。</p><p>每个 Replica （包含 Leader 和 Follower）都有 HW，它们各自负责更新自己的 HW 的状态。</p><img src="/2020/12/03/Kafaka与Zookeeper/4.png"><h2 id="可靠性"><a href="#可靠性" class="headerlink" title="可靠性"></a>可靠性</h2><p>在客户端，可以通过 request.required.acks 参数来设置数据可靠性的级别<br>（1）request.required.acks = 1 Producer 发送数据到 Leader，只要 Leader 成功写入本地日志，即成功返回客户端，不要求 ISR 中的其它副本与 Leader 保持同步<br>（2）request.required.acks = 0 Producer 不停向 Leader 发送数据，而不需要 Leader 反馈成功消息<br>（3）request.required.acks = -1（all） 消息的强制备份数量为 ISR 列表中副本的数量，Leader收到消息后才向生产者返回成功</p><p>Kafka 提供了这样一个参数：min.insync.replicas，该参数用于设定 ISR 中的最小副本数，默认值为 1，当且仅当 request.required.acks 参数设置为 -1 时，此参数才生效。</p><h3 id="参数-batch-size"><a href="#参数-batch-size" class="headerlink" title="参数 batch.size"></a>参数 batch.size</h3><p>当多条消息的目标 Partition 相同时，Producer 会尝试将它们组装成一个批量消息，以便减少请求的数量，有助于提升客户端和服务器的性能。批量消息的大小由参数 batch.size 控制。</p><h3 id="参数-linger-ms"><a href="#参数-linger-ms" class="headerlink" title="参数 linger.ms"></a>参数 linger.ms</h3><p>如果消息到达的速度比后台线程发送到 Partition 的速度快，则会出现消息堆积的问题。不过，在某些情况下，客户端可能通过添加人工延迟来减少请求数量。</p><h3 id="参数-buffer-memory-和-max-block-ms"><a href="#参数-buffer-memory-和-max-block-ms" class="headerlink" title="参数 buffer.memory 和 max.block.ms"></a>参数 buffer.memory 和 max.block.ms</h3><p>Producer 可以用来缓冲等待发送给服务器的消息的总字节数。如果消息的发送速度快于传送到服务器的速度，那么缓冲区将被占满，之后 Producer 将阻塞 max.block.ms，随后将抛出异常。buffer.memory 的大小大致与 Producer 可使用的总内存相对应</p><p>在 buffer.memory 指定的缓存被占满后，Producer 相关的方法可阻塞的最大时间由 max.block.ms 控制，之后将抛出异常。</p><h3 id="参数-retries"><a href="#参数-retries" class="headerlink" title="参数 retries"></a>参数 retries</h3><p>发送消息具有“重试机制”，由参数 retries 控制</p><h3 id="避免消息重排序"><a href="#避免消息重排序" class="headerlink" title="避免消息重排序"></a>避免消息重排序</h3><p>先T1、T2，T1失败，T2成功，T1重试</p><p>max.in.flight.requests.per.connection，通过它，客户端可以设置在单个连接上发送的未确认请求的最大数目。如果设置大于 1，并且发送失败，则存在由于重试（如果启用了重试机制）而导致消息重新排序的风险。</p><h3 id="消息接收的可靠性"><a href="#消息接收的可靠性" class="headerlink" title="消息接收的可靠性"></a>消息接收的可靠性</h3><p>为了保证消息接收的可靠性，通常将参数 enable.auto.commit 设置为 False，防止程序自动提交。</p><h3 id="消息存储的可靠性"><a href="#消息存储的可靠性" class="headerlink" title="消息存储的可靠性"></a>消息存储的可靠性</h3><p>Kafka 通过持久化消息到磁盘来保障消息存储的可靠性，但存在矛盾点：由于磁盘的 IO 瓶颈，过于频繁的“刷盘”会降低 Kafka 的性能。但是，“刷盘” 的时间间隔过长又存在消息丢失的风险，降低可靠性</p><p>log.flush.interval.ms 用于控制日志刷盘的时间间隔，即每隔多长时间将消息刷到磁盘上</p><p>log.flush.interval.messages 用于控制日志刷盘的消息量，即每积累多少条消息后将消息刷到磁盘上</p><h2 id="Kafka-选举-Leader-的策略是怎样的？"><a href="#Kafka-选举-Leader-的策略是怎样的？" class="headerlink" title="Kafka 选举 Leader 的策略是怎样的？"></a>Kafka 选举 Leader 的策略是怎样的？</h2><p>Kafka 通过 ZooKeeper 为每一个 Partition 动态维护了一个 ISR 列表。对于任意一条消息，只有它被 ISR 中的所有 Follower 都从 Leader 复制过去才会被认为 Committed，并返回信息给 Producer，从而保证可靠性。但与“少数服从多数”策略不同的是，Kafka ISR 列表中副本的数量不需要超过副本总数的一半，即不需要满足“多数派”原则，通常，ISR 列表副本数大于等于 2 即可，如此，便在可靠性和吞吐量方面取得平衡。</p><h2 id="Kafka-架构中-ZooKeeper-以怎样的形式存在？"><a href="#Kafka-架构中-ZooKeeper-以怎样的形式存在？" class="headerlink" title="Kafka 架构中 ZooKeeper 以怎样的形式存在？"></a>Kafka 架构中 ZooKeeper 以怎样的形式存在？</h2><p>在基于 Kafka 的分布式消息队列中，ZooKeeper 的作用有 Broker 注册、Topic 注册、Producer 和 Consumer 负载均衡、维护 Partition 与 Consumer 的关系、记录消息消费的进度以及 Consumer 注册等。</p><p>当 Producer Push 的消息写入 Partition（分区）时，作为 Leader 的 Broker（Kafka 节点）会将消息写入自己的分区，同时还会将此消息复制到各个 Follower，实现同步。如果某个 Follower 挂掉，Leader 会再找一个替代并同步消息；如果 Leader 挂了，Follower 们会选举出一个新的 Leader 替代，继续业务，这些都是由 ZooKeeper 完成的。</p><h3 id="Consumer-在-ZooKeeper-中的注册"><a href="#Consumer-在-ZooKeeper-中的注册" class="headerlink" title="Consumer 在 ZooKeeper 中的注册"></a>Consumer 在 ZooKeeper 中的注册</h3><p>在 ZooKeeper 中，/consumers/{group_id} 虽然被称为节点，但本质上是一个目录。</p><p>ids：Consumer Group 中有多个 Consumer，ids 用于记录这些 Consumer；<br>owners：记录该 Consumer Group 可消费的 Topic 信息；<br>offsets：记录 owners 中每个 Topic 的所有 Partition 的 Offset。  </p><h3 id="Producers-负载均衡"><a href="#Producers-负载均衡" class="headerlink" title="Producers 负载均衡"></a>Producers 负载均衡</h3><p>Producers 会通过 Watcher 机制监听 Brokers 注册节点的变化。一旦 Brokers 发生变化，如增加、减少，Producers 可以收到通知并更新自己记录的 Broker 列表 。此外，基于 ZooKeeper 提供的 Watcher 机制，还可以监听其它在 ZooKeeper 上注册的节点，如 Topic、Consumer 等。</p><h3 id="Consumer-负载均衡"><a href="#Consumer-负载均衡" class="headerlink" title="Consumer 负载均衡"></a>Consumer 负载均衡</h3><p>为 Consumer Group 中的各个 Consumer 分别指定不同的 Partition，只要保证该过程“相对公平”即可。</p><h3 id="借助-ZooKeeper-实现负载均衡"><a href="#借助-ZooKeeper-实现负载均衡" class="headerlink" title="借助 ZooKeeper 实现负载均衡"></a>借助 ZooKeeper 实现负载均衡</h3><ol><li>对任意一个 Topic 中所有的 Partirtion 进行排序，用数组 PT 记录；</li><li>某一 Consumer Group 订阅了上述 Topic，对它的所有 Consumer 排序，用数组 CG 记录，第 i 个 Consumer 记为 CG[i]；</li><li>比例系数为 F=size(PT)/size(CG)，向上取整；</li><li>解除 CG[i] 对原来分配的 Partition 的消费权（i 从 0 开始，最大值为 size(CG)-1）;</li><li>将第 i<em>F 到 (i+1)</em>F-1 个 Partition 分配给 CG[i]。</li></ol><h3 id="记录消费进度-Offset"><a href="#记录消费进度-Offset" class="headerlink" title="记录消费进度 Offset"></a>记录消费进度 Offset</h3><p>Offset 在 ZooKeeper 中，有一个专属的节点（目录）用于记录 Offset</p><p>节点内容就是Offset的值。<br>/consumers/[group_id]/offsets/[topic]/[broker_id-partition_id]</p><h2 id="全程解析"><a href="#全程解析" class="headerlink" title="全程解析"></a>全程解析</h2><h3 id="Producer-发布消息"><a href="#Producer-发布消息" class="headerlink" title="Producer 发布消息"></a>Producer 发布消息</h3><p>Producer 采用 Push 模式将消息发布到 Kafka Broker，根据负载均衡算法（如轮询、Hash 等），这些消息将均衡写入到相应 Topic 对应的各个 Partition 中。在存储层面，采用顺序写磁盘（即 Append）模式写入。</p><ol><li>Producer Push 消息，基于负载均衡算法获得目标 Partition 后，Producer 先从 ZooKeeper 的 /brokers/…/state 节点找到该Partition 的 Leader；</li><li>Producer 将消息发送给该 Leader；</li><li>Leader 将消息写入本地 Log；</li><li>所有 Follower 主动从 Leader Pull 消息，写入本地 Log 后向 Leader 发送 ACK；</li><li>Leader 收到所有 ISR 中所有 Replica 的 ACK 后，更新 HW（High Watermark，最后 Commit 的 Offset），并向 Producer 发送 ACK；</li><li>Producer 接到 ACK，确认发送成功。</li></ol><h3 id="Broker-存储消息"><a href="#Broker-存储消息" class="headerlink" title="Broker 存储消息"></a>Broker 存储消息</h3><p>Topic 是逻辑概念，而 Topic 对应的 Partition 则是物理概念，每个 Partition 在存储层面都对应一个文件夹（目录）。由于 Partition 并不是最终的存储粒度，该文件夹下还有多个 Segment（消息索引和数据文件，它们是真正的存储文件）。</p><h3 id="Consumer-消费消息"><a href="#Consumer-消费消息" class="headerlink" title="Consumer 消费消息"></a>Consumer 消费消息</h3><p>目前采用的高级 API，Consumer 在消费消息时，只需指定 Topic 即可，API 内部实现负载均衡，并将 Offset 记录到 ZooKeeper 上。<br>Consumer 采用 Pull 模式从 Broker 中读取数据，这是一种异步消费模式，与 Producer 采用的 Push 模式全然不同。Push 模式追求速度，越快越好，当然它取决于 Broker 的性能，而 Pull 模式则是追求自适应能力，Consumer 根据自己的消费能力消费。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Kafaka-总体架构&quot;&gt;&lt;a href=&quot;#Kafaka-总体架构&quot; class=&quot;headerlink&quot; title=&quot;Kafaka 总体架构&quot;&gt;&lt;/a&gt;Kafaka 总体架构&lt;/h2&gt;&lt;img src=&quot;/2020/12/03/Kafaka与Zookeepe
      
    
    </summary>
    
      <category term="基础" scheme="http://twh233.github.io/categories/%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="分布式" scheme="http://twh233.github.io/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
      <category term="Kafaka" scheme="http://twh233.github.io/tags/Kafaka/"/>
    
  </entry>
  
  <entry>
    <title>分布式一致性算法Raft和Etcd</title>
    <link href="http://twh233.github.io/2020/11/30/%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%80%E8%87%B4%E6%80%A7%E7%AE%97%E6%B3%95Raft%E5%92%8CEtcd/"/>
    <id>http://twh233.github.io/2020/11/30/分布式一致性算法Raft和Etcd/</id>
    <published>2020-11-30T15:19:34.000Z</published>
    <updated>2020-11-30T15:47:14.568Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Raft"><a href="#Raft" class="headerlink" title="Raft"></a>Raft</h1><h2 id="Raft角色"><a href="#Raft角色" class="headerlink" title="Raft角色"></a>Raft角色</h2><p>Leader（领导者）：负责日志的同步管理，处理来自客户端的请求，与Follower保持heartBeat的联系；<br>Follower（追随者）：响应 Leader 的日志同步请求，响应Candidate的邀票请求，以及把客户端请求到Follower的事务转发（重定向）给Leader；<br>Candidate（候选者）：负责选举投票，集群刚启动或者Leader宕机时，状态为Follower的节点将转为Candidate并发起选举，选举胜出（获得超过半数节点的投票）后，从Candidate转为Leader状态。  </p><h2 id="Raft-三个子问题"><a href="#Raft-三个子问题" class="headerlink" title="Raft 三个子问题"></a>Raft 三个子问题</h2><p>选举（Leader Election）：当 Leader 宕机或者集群初创时，一个新的 Leader 需要被选举出来；<br>日志复制（Log Replication）：Leader 接收来自客户端的请求并将其以日志条目的形式复制到集群中的其它节点，并且强制要求其它节点的日志和自己保持一致；<br>安全性（Safety）：如果有任何的服务器节点已经应用了一个确定的日志条目到它的状态机中，那么其它服务器节点不能在同一个日志索引位置应用一个不同的指令。  </p><h2 id="Raft-算法之-Leader-Election-原理"><a href="#Raft-算法之-Leader-Election-原理" class="headerlink" title="Raft 算法之 Leader Election 原理"></a>Raft 算法之 Leader Election 原理</h2><p>第一阶段：所有节点都是 Follower。<br>第二阶段：Follower 转为 Candidate 并发起投票。<br>第三阶段：投票策略。  </p><p>节点收到投票请求后会根据以下情况决定是否接受投票请求：</p><p>请求节点的 Term 大于自己的 Term，且自己尚未投票给其它节点，则接受请求，把票投给它；<br>请求节点的 Term 小于自己的 Term，且自己尚未投票，则拒绝请求，将票投给自己。</p><p>第四阶段：Candidate 转为 Leader。</p><h2 id="Raft-算法之-Log-Replication-原理"><a href="#Raft-算法之-Log-Replication-原理" class="headerlink" title="Raft 算法之 Log Replication 原理"></a>Raft 算法之 Log Replication 原理</h2><p>第一阶段：客户端请求提交到 Leader。</p><p>Follower 将会把请求重定向到 Leader。Leader 在收到请求后，会将它作为日志条目（Entry）写入本地日志中。需要注意的是，此时该 Entry 的状态是未提交（Uncommitted），Leader 并不会更新本地数据，因此它是不可读的。</p><p>第二阶段：Leader 将 Entry 发送到其它 Follower</p><p>在发送追加日志条目的时候，Leader 会把新的日志条目紧接着之前条目的索引位置（prevLogIndex）， Leader 任期号（Term）也包含在其中。如果 Follower 在它的日志中找不到包含相同索引位置和任期号的条目，那么它就会拒绝接收新的日志条目，因为出现这种情况说明 Follower 和 Leader 不一致。</p><p>要使 Follower 的日志与 Leader 恢复一致，Leader 必须找到最后两者达成一致的地方（说白了就是回溯，找到两者最近的一致点），然后删除从那个点之后的所有日志条目，发送自己的日志给 Follower。所有的这些操作都在进行附加日志的一致性检查时完成。</p><p>如果一个 Follower 的日志和 Leader 不一致，那么在下一次附加日志时一致性检查就会失败。在被 Follower 拒绝之后，Leader 就会减小该 Follower 对应的 nextIndex 值并进行重试。最终 nextIndex 会在某个位置使得 Leader 和 Follower 的日志达成一致。</p><p>第三阶段：Leader 等待 Followers 回应。</p><p>第四阶段：Leader 回应客户端。</p><p>第五阶段，Leader 通知 Followers Entry 已提交</p><p>Leader 回应客户端后，将随着下一个心跳通知 Followers，Followers 收到通知后也会将 Entry 标记为提交状态。至此，Raft 集群超过半数节点已经达到一致状态，可以确保强一致性。</p><h2 id="Raft-算法之安全性"><a href="#Raft-算法之安全性" class="headerlink" title="Raft 算法之安全性"></a>Raft 算法之安全性</h2><p>保证任何的 Leader 对于给定的任期号（Term），都拥有之前任期的所有被提交的日志条目</p><h3 id="选举限制"><a href="#选举限制" class="headerlink" title="选举限制"></a>选举限制</h3><p>日志条目的传送是单向的，只从 Leader 传给 Follower，并且 Leader 从不会覆盖自身本地日志中已经存在的条目。</p><p>比较新的可以赢得大多数投票。</p><h3 id="提交之前任期内的日志条目"><a href="#提交之前任期内的日志条目" class="headerlink" title="提交之前任期内的日志条目"></a>提交之前任期内的日志条目</h3><p>如果一个 Leader 在提交日志条目之前崩溃了，继任的 Leader 会继续尝试复制这条日志记录。但不能保证在Follower上的日志条目提交。</p><p>当 Leader 复制之前任期里的日志时，Raft 会为所有日志保留原始的任期号，这在提交规则上产生了额外的复杂性。但是，这种策略更加容易辨别出日志，即使随着时间和日志的变化，日志仍维护着同一个任期编号。此外，该策略使得新 Leader 只需要发送较少日志条目。</p><h1 id="Etcd"><a href="#Etcd" class="headerlink" title="Etcd"></a>Etcd</h1><p>Etcd 主要分为四个部分：HTTP Server、Store、Raft 以及 WAL。 </p><p>HTTP Server：用于处理客户端发送的 API 请求以及其它 Etcd 节点的同步与心跳信息请求。<br>Store：用于处理 Etcd 支持的各类功能的事务，包括数据索引、节点状态变更、监控与反馈、事件处理与执行等等，是 Etcd 对用户提供的大多数 API 功能的具体实现。<br>Raft：Raft 强一致性算法的具体实现，是 Etcd 的核心。<br>WAL：Write Ahead Log（预写式日志），是 Etcd 的数据存储方式。除了在内存中存有所有数据的状态以及节点的索引，Etcd 还通过 WAL 进行持久化存储。WAL 中，所有的数据提交前都会事先记录日志。Snapshot 是为了防止数据过多而进行的状态快照。Entry 表示存储的具体日志内容。  </p><p>一个用户的请求发送过来，会经由 HTTP Server 转发给 Store 进行具体的事务处理；如果涉及到节点的修改，则交给 Raft 模块进行状态的变更、日志的记录，然后再同步给别的 Etcd 节点以确认数据提交；最后进行数据的提交，再次同步。</p><p>Lease 机制：续约机制<br>Prefix 机制：即前缀机制，也称目录机制<br>Watch 机制：即监听机制，Watch 机制支持监听某个固定的 Key，也支持监听一个范围（前缀机制），当被监听的 Key 或范围发生变化，客户端将收到通知；<br>Revision 机制：每个 Key 带有一个 Revision 号，每进行一次事务便加一，因此它是全局唯一的</p><p>应用场景 1：服务发现<br>应用场景 2：消息发布和订阅<br>应用场景 3：分布式锁<br>Etcd 支持 Revision 机制，那么对于同一个 Lock，即便有多个客户端争夺（本质上就是 put(lockName, value) 操作），Revision 机制可以保证它们的 Revision 编号有序且唯一，那么，客户端只要根据 Revision 的大小顺序就可以确定获得锁的先后顺序，从而很容易实现“公平锁”。<br>应用场景4： 集群监控与 Leader 竞选</p><h2 id="基于-Etcd-的分布式锁业务流程"><a href="#基于-Etcd-的分布式锁业务流程" class="headerlink" title="基于 Etcd 的分布式锁业务流程"></a>基于 Etcd 的分布式锁业务流程</h2><h3 id="步骤1：准备"><a href="#步骤1：准备" class="headerlink" title="步骤1：准备"></a>步骤1：准备</h3><p>客户端连接 Etcd，以 /lock/mylock 为前缀创建全局唯一的 Key，假设第一个客户端对应的 Key=”/lock/mylock/UUID1”，第二个为 Key=”/lock/mylock/UUID2”；客户端分别为自己的 Key 创建租约 Lease，租约的长度根据业务耗时确定，假设为 15s。</p><h3 id="步骤2：创建定时任务作为租约的“心跳”"><a href="#步骤2：创建定时任务作为租约的“心跳”" class="headerlink" title="步骤2：创建定时任务作为租约的“心跳”"></a>步骤2：创建定时任务作为租约的“心跳”</h3><p>在一个客户端持有锁期间，其它客户端只能等待，为了避免等待期间租约失效，客户端需创建一个定时任务作为“心跳”进行续约。此外，如果持有锁期间客户端崩溃，心跳停止，Key 将因租约到期而被删除，从而锁释放，避免死锁。</p><h3 id="步骤3：客户端将自己全局唯一的-Key-写入-Etcd"><a href="#步骤3：客户端将自己全局唯一的-Key-写入-Etcd" class="headerlink" title="步骤3：客户端将自己全局唯一的 Key 写入 Etcd"></a>步骤3：客户端将自己全局唯一的 Key 写入 Etcd</h3><p>进行 Put 操作，将步骤 1 中创建的 Key 绑定租约写入 Etcd，根据 Etcd 的 Revision 机制，假设两个客户端 Put 操作返回的 Revision 分别为1、2，客户端需记录 Revision 用以接下来判断自己是否获得锁。</p><h3 id="步骤4：客户端判断是否获得锁"><a href="#步骤4：客户端判断是否获得锁" class="headerlink" title="步骤4：客户端判断是否获得锁"></a>步骤4：客户端判断是否获得锁</h3><p>客户端以前缀 /lock/mylock 读取 Key-Value 列表（Key-Value 中带有 Key 对应的 Revision），判断自己 Key 的 Revision 是否为当前列表中最小的，如果是则认为获得锁；否则监听列表中前一个 Revision 比自己小的 Key 的删除事件，一旦监听到删除事件或者因租约失效而删除的事件，则自己获得锁。 </p><h3 id="步骤5：执行业务"><a href="#步骤5：执行业务" class="headerlink" title="步骤5：执行业务"></a>步骤5：执行业务</h3><p>获得锁后，操作共享资源，执行业务代码。 </p><h3 id="步骤6：释放锁"><a href="#步骤6：释放锁" class="headerlink" title="步骤6：释放锁"></a>步骤6：释放锁</h3><p>完成业务流程后，删除对应的 Key 释放锁。</p><img src="/2020/11/30/分布式一致性算法Raft和Etcd/1.png">]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Raft&quot;&gt;&lt;a href=&quot;#Raft&quot; class=&quot;headerlink&quot; title=&quot;Raft&quot;&gt;&lt;/a&gt;Raft&lt;/h1&gt;&lt;h2 id=&quot;Raft角色&quot;&gt;&lt;a href=&quot;#Raft角色&quot; class=&quot;headerlink&quot; title=&quot;Raft角
      
    
    </summary>
    
      <category term="基础" scheme="http://twh233.github.io/categories/%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="分布式" scheme="http://twh233.github.io/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>Redis分布式</title>
    <link href="http://twh233.github.io/2020/11/25/Redis%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    <id>http://twh233.github.io/2020/11/25/Redis分布式/</id>
    <published>2020-11-25T13:43:01.000Z</published>
    <updated>2020-11-30T15:28:22.936Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Redis-Cluster特点"><a href="#Redis-Cluster特点" class="headerlink" title="Redis Cluster特点"></a>Redis Cluster特点</h2><p>节点互通：所有的 Redis 节点彼此互联（PING-PONG机制），内部使用二进制协议优化传输速度和带宽；  </p><p>去中心化：Redis Cluster 不存在中心节点，每个节点都记录有集群的状态信息，并且通过 Gossip 协议，使每个节点记录的信息实现最终一致性；</p><p>客户端直连：客户端与 Redis 节点直连，不需要中间 Proxy 层，客户端不需要连接集群所有节点，连接集群中任何一个可用节点即可；</p><p>数据分片：Redis Cluster 的键空间被分割为 16384 个 Slot，这些 Slot 被分别指派给主节点，当存储 Key-Value 时，根据 CRC16(key) Mod 16384的值，决定将一个 Key-Value 放到哪个 Slot 中；</p><p>多数派原则：对于集群中的任何一个节点，需要超过半数的节点检测到它失效（pFail），才会将其判定为失效（Fail）；</p><p>自动 Failover：当集群中某个主节点故障后（Fail），其它主节点会从故障主节点的从节点中选举一个“最佳”从节点升主，替代故障的主节点；</p><p>功能弱化：集群模式下，由于数据分布在多个节点，不支持单机模式下的集合操作，也不支持多数据库功能，集群只能使用默认的0号数据库；</p><p>集群规模：官方推荐的最大节点数量为 1000 个左右，这是因为当集群规模过大时，Gossip 协议的效率会显著下降，通信成本剧增。</p><h2 id="Redis-Cluster路由"><a href="#Redis-Cluster路由" class="headerlink" title="Redis Cluster路由"></a>Redis Cluster路由</h2><img src="/2020/11/25/Redis分布式/1.png"><p>在客户端缓存 Slot 与 Redis 节点的映射关系，当接收到 MOVED 响应时修改缓存中的映射关系。</p><h2 id="Gossip-在-Redis-Cluster-的作用"><a href="#Gossip-在-Redis-Cluster-的作用" class="headerlink" title="Gossip 在 Redis Cluster 的作用"></a>Gossip 在 Redis Cluster 的作用</h2><p>在分布式系统中，需要提供维护节点元数据信息的机制，所谓元数据是指节点负责哪些数据、主从属性、是否出现故障等状态信息。常见的元数据维护方式分为集中式和无中心式。Redis Cluster 采用 Gossip 协议实现了无中心式。</p><p>Meet 消息：用于通知新节点加入。消息发送者通知接收者加入到当前集群，Meet 消息通信正常完成后，接收节点会加入到集群中并进行周期性的 Ping、Pong 消息交换；<br>Ping 消息：集群内交换最频繁的消息，集群内每个节点每秒向多个其它节点发送 Ping 消息，用于检测节点是否在线和交换彼此状态信息。Ping 消息发送封装了自身节点和部分其它节点的状态数据；<br>Pong 消息：当接收到 Ping、Meet 消息时，作为响应消息回复给发送方确认消息正常通信。Pong 消息内部封装了自身状态数据。节点也可以向集群内广播自身的 Pong 消息来通知整个集群对自身状态进行更新；<br>Fail 消息：当节点判定集群内另一个节点下线时，会向集群内广播一个 Fail 消息，其他节点接收到 Fail 消息之后把对应节点更新为下线状态。</p><h2 id="故障转移"><a href="#故障转移" class="headerlink" title="故障转移"></a>故障转移</h2><p>发送Ping Pong消息，转到疑下线状态，再到传播消息，最后做半数以上统计的下线判决。</p><h2 id="投票"><a href="#投票" class="headerlink" title="投票"></a>投票</h2><p>如果一个主节点具有投票权（负责处理 Slot 的主节点)，并且这个主节点尚未投票给其它从节点，那么这个主节点将向请求投票的从节点返回一条回应消息，表示支持该从节点升主。</p><p>在同一轮选举中，只可能有一个从节点收到的票数大于 N/2 + 1。</p><p>接管Master结点后：<br>身份切换、接管职权、广而告之、履行义务</p><h2 id="其他分布式方案"><a href="#其他分布式方案" class="headerlink" title="其他分布式方案"></a>其他分布式方案</h2><h3 id="客户端分片"><a href="#客户端分片" class="headerlink" title="客户端分片"></a>客户端分片</h3><p>如下图所示，客户端与 Redis 节点直连，为了提高可用性，每个主节点挂一个从节点，故障倒换可由“哨兵”系统实现（其它方案也可实现）。客户端对任何一个主节点的读写操作本质上就是单机模式下的读写操作；对于一个 Key-Value，其读写节点完全由客户端决定。</p><p>缺点：1.不支持动态增加节点 2.不支持动态减少节点，原理同上 3.有业务逻辑与数据存储逻辑耦合，可运维性差</p><h3 id="基于代理的分片"><a href="#基于代理的分片" class="headerlink" title="基于代理的分片"></a>基于代理的分片</h3><p>中间层proxy </p><img src="/2020/11/25/Redis分布式/2.png"><h2 id="Redis集群可靠性"><a href="#Redis集群可靠性" class="headerlink" title="Redis集群可靠性"></a>Redis集群可靠性</h2><h3 id="问题一"><a href="#问题一" class="headerlink" title="问题一"></a>问题一</h3><p>三个物理节点，分别部署两个 redis-server，且交叉互为主备，这样做可以提高可靠性：如节点 1 宕机，主节点 A-M 对应的从节点 A-S 将发起投票，作为唯一的备节点，其必然升主成功，与 B-M、C-M 构成新的集群，继续提供服务，如下图所示：</p><img src="/2020/11/25/Redis分布式/3.png"><p>如果宕机的节点 1 经过修复重新上线，根据 Redis 集群原理，节点 1 上的 A-M 将意识到自己已经被替代，将降级为备，形成的集群拓扑结构如下：</p><img src="/2020/11/25/Redis分布式/4.png"><h3 id="问题二"><a href="#问题二" class="headerlink" title="问题二"></a>问题二</h3><p>如果节点 3 宕机，Redis 集群将只有一个主节点 C-M 存活，存活的主节点总数少于集群主节点总数的一半 （1&lt;3/2+1），集群无法自愈，不能继续提供服务。</p><p>为了解决这个问题，我们可以设计一个常驻守护进程对 Redis 集群的状态进行监控，当出现主-备状态不合理的情况（如节点 1 重新上线后的拓扑结构），守护进程主动发起主备倒换（clusterFailover），将节点 1 上的 A-S 升为主，节点 3 上的 A-M 降为备，如此，集群拓扑结构恢复正常，并且能够支持单节点故障。</p><img src="/2020/11/25/Redis分布式/5.png"><h3 id="问题三"><a href="#问题三" class="headerlink" title="问题三"></a>问题三</h3><p>如果节点 1 故障后无法修复，为了保障可靠性，通常会用一个新的节点来替换掉故障的节点——所谓故障替换。拓扑结构如下：</p><img src="/2020/11/25/Redis分布式/6.png"><p>将新节点上的两个 redis-server 纳入现有集群，通过 clusterMeet() 方法可以完成；<br>为新加入集群的两个 redis-server 设置主节点：节点 3 上的两个主 A-M 和 B-M 都没有对应的从节点，因此，可将新加入的两个 redis-server 分别设置为它们的从节点。  </p><img src="/2020/11/25/Redis分布式/7.png"><h2 id="基于-Lettuce-的-Redis-集群运维软件设计及实现"><a href="#基于-Lettuce-的-Redis-集群运维软件设计及实现" class="headerlink" title="基于 Lettuce 的 Redis 集群运维软件设计及实现"></a>基于 Lettuce 的 Redis 集群运维软件设计及实现</h2><img src="/2020/11/25/Redis分布式/8.png"><h2 id="Redis分布式锁实现"><a href="#Redis分布式锁实现" class="headerlink" title="Redis分布式锁实现"></a>Redis分布式锁实现</h2><p>分布式锁需同时满足以下四个约束条件</p><p>互斥性：在任意时刻，只有一个客户端能持有锁；<br>安全性：即不会形成死锁，当一个客户端在持有锁的期间崩溃而没有主动解锁的情况下，其持有的锁也能够被正确释放，并保证后续其它客户端能加锁；<br>可用性：就 Redis 而言，当提供锁服务的 Redis Master 节点发生宕机等不可恢复性故障时，Slave 节点能够升主并继续提供服务，支持客户端加锁和解锁；对基于分布式一致性算法实现的锁服务（如 ETCD）而言，当 Leader 节点宕机时，Follow 节点能够选举出新的 Leader 继续提供锁服务；<br>对称性：对于任意一个锁，其加锁和解锁必须是同一个客户端，即客户端 A 不能把客户端 B 加的锁给解了。  </p><h3 id="预防死锁"><a href="#预防死锁" class="headerlink" title="预防死锁"></a>预防死锁</h3><p>一个客户端获取锁成功，但是在释放锁之前崩溃了，此时该客户端实际上已经失去了对公共资源的操作权，但却没有办法请求解锁（删除 Key-Value 键值对），那么，它就会一直持有这个锁，而其它客户端永远无法获得锁。</p><p>在加锁时为锁设置过期时间</p><h3 id="设置锁自动过期时间以预防死锁存在的隐患"><a href="#设置锁自动过期时间以预防死锁存在的隐患" class="headerlink" title="设置锁自动过期时间以预防死锁存在的隐患"></a>设置锁自动过期时间以预防死锁存在的隐患</h3><p>1.客户端 A 恢复后，可以比较下目前已经持有锁的时间，如果发现已经过期，则放弃对共享资源的操作即可避免互斥性失效的问题。<br>2.既然比较时间不可取，那么，还可以比较 my_random_value，即客户端 A 恢复后，在操作共享资源前应比较目前自身所持有锁的 my_random_value 与 Redis 中存储的 my_random_value 是否一致，如果不相同，说明已经不再持有锁，则放弃对共享资源的操作以避免互斥性失效的问题。</p><h3 id="解锁操作的原子性"><a href="#解锁操作的原子性" class="headerlink" title="解锁操作的原子性"></a>解锁操作的原子性</h3><p>1.使用 Redis 事务功能，使用 Watch 命令监控锁对应的 Key，释放锁则采用事务功能（Multi 命令），如果持有的锁已经因过期而释放（或者过期释放后又被其它客户端持有），则 Key 对应的 Value 将改变，释放锁的事务将不会被执行，从而避免错误的释放锁，示例代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">Jedis jedis = new Jedis(&quot;127.0.0.1&quot;, 6379);</span><br><span class="line"></span><br><span class="line">// “自旋”，等待锁</span><br><span class="line">String result = null;</span><br><span class="line">while (true)</span><br><span class="line">&#123;</span><br><span class="line">    // 申请锁，只有当“lock_name”不存在时才能申请成功，返回“OK&quot;,锁的过期时间设置为5s</span><br><span class="line">    result = jedis.set(&quot;lock_name&quot;, &quot;my_random_value&quot;, SET_IF_NOT_EXIST,</span><br><span class="line">            SET_WITH_EXPIRE_TIME, 5000);</span><br><span class="line">    if (&quot;OK&quot;.equals(result))</span><br><span class="line">    &#123;</span><br><span class="line">        break;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 监控锁对应的 Key，如果其它的客户端对这个 Key 进行了更改，那么本次事务会被取消。</span><br><span class="line">jedis.watch(&quot;lock_name&quot;);</span><br><span class="line">// 成功获取锁，则操作公共资源，自定义流程</span><br><span class="line">// to do something...</span><br><span class="line"></span><br><span class="line">// 释放锁之前，校验是否持有锁</span><br><span class="line">if (jedis.get(&quot;lock_name&quot;).equals(&quot;my_random_value&quot;))</span><br><span class="line">&#123;</span><br><span class="line">    // 开启事务功能，</span><br><span class="line">    Transaction multi = jedis.multi();</span><br><span class="line">    // 模拟客户端阻塞10s，锁超时，自动清除</span><br><span class="line">    try</span><br><span class="line">    &#123;</span><br><span class="line">        Thread.sleep(5000);</span><br><span class="line">    &#125;</span><br><span class="line">    catch (InterruptedException e)</span><br><span class="line">    &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    // 客户端恢复，继续释放锁</span><br><span class="line">    multi.del(&quot;lock_name&quot;);</span><br><span class="line">    // 执行事务（如果其它的客户端对这个Key进行了更改，那么本次事务会被取消,不会执行)</span><br><span class="line">    multi.exec();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 释放资源</span><br><span class="line">jedis.unwatch();</span><br><span class="line">jedis.close();</span><br></pre></td></tr></table></figure><p>2.使用 Lua 脚本实现锁校验与释放，并使用 Redis 的 eval 函数执行 Lua 脚本</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">Jedis jedis = new Jedis(&quot;127.0.0.1&quot;, 6379);</span><br><span class="line"></span><br><span class="line">// “自旋”，等待锁</span><br><span class="line">String result = null;</span><br><span class="line">while (true)</span><br><span class="line">&#123;</span><br><span class="line">    // 申请锁，只有当“lock_name”不存在时才能申请成功，返回“OK&quot;，锁的过期时间设置为 5s</span><br><span class="line">    result = jedis.set(&quot;lock_name&quot;, &quot;my_random_value&quot;, SET_IF_NOT_EXIST,</span><br><span class="line">            SET_WITH_EXPIRE_TIME, 5000);</span><br><span class="line">    if (&quot;OK&quot;.equals(result))</span><br><span class="line">    &#123;</span><br><span class="line">        break;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">// 成功获取锁，则操作公共资源，自定义流程</span><br><span class="line">// to do something...</span><br><span class="line"></span><br><span class="line">// Lua脚本，用于校验并释放锁     </span><br><span class="line">String script = &quot;if redis.call(&apos;get&apos;, KEYS[1]) == ARGV[1] then return redis.call(&apos;del&apos;, KEYS[1]) else return 0 end&quot;;</span><br><span class="line">try</span><br><span class="line">&#123;</span><br><span class="line">    // 模拟客户端阻塞10s，锁超时，自动清除</span><br><span class="line">    Thread.sleep(10000);</span><br><span class="line">&#125;</span><br><span class="line">catch (InterruptedException e)</span><br><span class="line">&#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 执行Lua脚本，校验并释放锁</span><br><span class="line">jedis.eval(script, Collections.singletonList(&quot;lock_name&quot;),</span><br><span class="line">        Collections.singletonList(&quot;my_random_value&quot;));</span><br><span class="line"></span><br><span class="line">jedis.close();</span><br></pre></td></tr></table></figure><h3 id="Redis-节点故障后，主备切换的数据一致性"><a href="#Redis-节点故障后，主备切换的数据一致性" class="headerlink" title="Redis 节点故障后，主备切换的数据一致性"></a>Redis 节点故障后，主备切换的数据一致性</h3><p>客户端 A 从 Master 获取了锁；<br>Master 宕机了，存储锁的 Key 还没有来得及同步到 Slave 上；<br>Slave 升级为 Master；<br>客户端 B 从新的 Master 获取到了对应同一个资源的锁；<br>客户端 A 和客户端 B 同时持有了同一个资源的锁，锁的安全性被打破。</p><p>方案1：还是使用my_random_value</p><p>方案2：RedLock</p><p>运行 Redlock 算法的客户端依次执行以下步骤，来进行加锁的操作：<br>1.获取当前系统时间（毫秒数）。<br>2.按顺序依次向 N 个 Redis 节点执行获取锁的操作。这个获取操作跟前面基于单 Redis 节点获取锁的过程相同，包含随机字符串 my_random_value，也包含过期时间（比如 PX 30000，即锁的有效时间）。为了保证在某个 Redis 节点不可用的时候算法能够继续运行，这个获取锁的操作还有一个超时时间（Time Out），它要远小于锁的有效时间（几十毫秒量级）。客户端在向某个 Redis 节点获取锁失败以后，应该立即尝试下一个 Redis 节点。这里的失败，应该包含任何类型的失败，比如该 Redis 节点不可用。<br>3.计算获取锁的整个过程总共消耗了多长时间，计算方法是用当前时间减去第 1 步记录的时间。如果客户端从大多数 Redis 节点（&gt;=N/2+1）成功获取到了锁，并且获取锁总共消耗的时间没有超过锁的有效时间（Lock Validity Time），那么这时客户端才认为最终获取锁成功；否则，认为最终获取锁失败。<br>4.如果最终获取锁成功了，那么这个锁的有效时间应该重新计算，它等于最初的锁的有效时间减去第 3 步计算出来的获取锁消耗的时间。<br>5.如果最终获取锁失败了（可能由于获取到锁的 Redis 节点个数少于 N/2+1，或者整个获取锁的过程消耗的时间超过了锁的最初有效时间），那么客户端应该立即向所有 Redis 节点发起释放锁的操作（即前面介绍的 Redis Lua 脚本）。  </p><h3 id="典型错误案例"><a href="#典型错误案例" class="headerlink" title="典型错误案例"></a>典型错误案例</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public static void lock(JedisPool jedisPool, String lockName, String myRandomValue, int expireTime) </span><br><span class="line">    &#123;</span><br><span class="line">        Jedis jedis = jedisPool.getResource();</span><br><span class="line">        // 如果锁不存在，则加锁</span><br><span class="line">        Long result = jedis.setnx(lockName, myRandomValue);</span><br><span class="line">        if (result == 1) </span><br><span class="line">        &#123;</span><br><span class="line">            // 为锁设置过期时间，由于加锁和设置过期时间是两步完成的，非原子操作</span><br><span class="line">            jedis.expire(lockName, expireTime);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Redis-Cluster特点&quot;&gt;&lt;a href=&quot;#Redis-Cluster特点&quot; class=&quot;headerlink&quot; title=&quot;Redis Cluster特点&quot;&gt;&lt;/a&gt;Redis Cluster特点&lt;/h2&gt;&lt;p&gt;节点互通：所有的 Redis 节点彼
      
    
    </summary>
    
      <category term="基础" scheme="http://twh233.github.io/categories/%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="分布式" scheme="http://twh233.github.io/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
      <category term="redis" scheme="http://twh233.github.io/tags/redis/"/>
    
  </entry>
  
  <entry>
    <title>try/catch实现</title>
    <link href="http://twh233.github.io/2020/11/24/try-catch%E5%AE%9E%E7%8E%B0/"/>
    <id>http://twh233.github.io/2020/11/24/try-catch实现/</id>
    <published>2020-11-24T14:08:11.000Z</published>
    <updated>2020-11-24T14:15:26.842Z</updated>
    
    <content type="html"><![CDATA[<p>大体是通过setjmp，longjmp 跨越函数的跳动。</p><p>原理类似if else，但要解决try catch嵌套问题，引入栈空间。</p><p>每个结点存有上一个结点的地址，用链表串起来。</p><p>通过pthread_setspecific，pthread_getspecific 保存当前空间私有信息。解决线程同步的问题。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line"></span><br><span class="line">#include &lt;stdarg.h&gt;</span><br><span class="line"></span><br><span class="line">#include &lt;pthread.h&gt;</span><br><span class="line">#include &lt;setjmp.h&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#define ntyThreadDatapthread_key_t</span><br><span class="line">#define ntyThreadDataSet(key, value)pthread_setspecific((key), (value))</span><br><span class="line">#define ntyThreadDataGet(key)pthread_getspecific((key))</span><br><span class="line">#define ntyThreadDataCreate(key)pthread_key_create(&amp;(key), NULL)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#define EXCEPTIN_MESSAGE_LENGTH512</span><br><span class="line"></span><br><span class="line">typedef struct _ntyException &#123;</span><br><span class="line">const char *name;</span><br><span class="line">&#125; ntyException; </span><br><span class="line"></span><br><span class="line">ntyException SQLException = &#123;&quot;SQLException&quot;&#125;;</span><br><span class="line">ntyException TimeoutException = &#123;&quot;TimeoutException&quot;&#125;;</span><br><span class="line"></span><br><span class="line">ntyThreadData ExceptionStack;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">typedef struct _ntyExceptionFrame &#123;</span><br><span class="line">jmp_buf env;</span><br><span class="line"></span><br><span class="line">int line;</span><br><span class="line">const char *func;</span><br><span class="line">const char *file;</span><br><span class="line"></span><br><span class="line">ntyException *exception;</span><br><span class="line">struct _ntyExceptionFrame *prev;</span><br><span class="line"></span><br><span class="line">char message[EXCEPTIN_MESSAGE_LENGTH+1];</span><br><span class="line"></span><br><span class="line">&#125; ntyExceptionFrame;</span><br><span class="line"></span><br><span class="line">#define ntyExceptionPopStack\</span><br><span class="line">ntyThreadDataSet(ExceptionStack, ((ntyExceptionFrame*)ntyThreadDataGet(ExceptionStack))-&gt;prev)</span><br><span class="line"></span><br><span class="line">#define ReThrowntyExceptionThrow(frame.exception, frame.func, frame.file, frame.line, NULL)</span><br><span class="line">#define Throw(e, cause, ...) ntyExceptionThrow(&amp;(e), __func__, __FILE__, __LINE__, cause, ##__VA_ARGS__, NULL)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">enum &#123;</span><br><span class="line">ExceptionEntered = 0,</span><br><span class="line">ExceptionThrown,</span><br><span class="line">ExceptionHandled,</span><br><span class="line">ExceptionFinalized</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#define Try do &#123;\</span><br><span class="line">volatile int Exception_flag;\</span><br><span class="line">ntyExceptionFrame frame;\</span><br><span class="line">frame.message[0] = 0;\</span><br><span class="line">frame.prev = (ntyExceptionFrame*)ntyThreadDataGet(ExceptionStack);\</span><br><span class="line">ntyThreadDataSet(ExceptionStack, &amp;frame);\</span><br><span class="line">Exception_flag = setjmp(frame.env);\</span><br><span class="line">if (Exception_flag == ExceptionEntered) &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#define Catch(e) \</span><br><span class="line">if (Exception_flag == ExceptionEntered) ntyExceptionPopStack; \</span><br><span class="line">&#125; else if (frame.exception == &amp;(e)) &#123; \</span><br><span class="line">Exception_flag = ExceptionHandled;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#define Finally \</span><br><span class="line">if (Exception_flag == ExceptionEntered) ntyExceptionPopStack; \</span><br><span class="line">&#125; &#123; \</span><br><span class="line">if (Exception_flag == ExceptionEntered)\</span><br><span class="line">Exception_flag = ExceptionFinalized; </span><br><span class="line"></span><br><span class="line">#define EndTry \</span><br><span class="line">if (Exception_flag == ExceptionEntered) ntyExceptionPopStack; \</span><br><span class="line">&#125; if (Exception_flag == ExceptionThrown) ReThrow; \</span><br><span class="line">        &#125; while (0)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">static pthread_once_t once_control = PTHREAD_ONCE_INIT;</span><br><span class="line"></span><br><span class="line">static void init_once(void) &#123; </span><br><span class="line">ntyThreadDataCreate(ExceptionStack); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">void ntyExceptionInit(void) &#123;</span><br><span class="line">pthread_once(&amp;once_control, init_once);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">void ntyExceptionThrow(ntyException *excep, const char *func, const char *file, int line, const char *cause, ...) &#123;</span><br><span class="line"></span><br><span class="line">va_list ap;</span><br><span class="line">ntyExceptionFrame *frame = (ntyExceptionFrame*)ntyThreadDataGet(ExceptionStack);</span><br><span class="line"></span><br><span class="line">if (frame) &#123;</span><br><span class="line"></span><br><span class="line">frame-&gt;exception = excep;</span><br><span class="line">frame-&gt;func = func;</span><br><span class="line">frame-&gt;file = file;</span><br><span class="line">frame-&gt;line = line;</span><br><span class="line"></span><br><span class="line">if (cause) &#123;</span><br><span class="line">va_start(ap, cause);</span><br><span class="line">vsnprintf(frame-&gt;message, EXCEPTIN_MESSAGE_LENGTH, cause, ap);</span><br><span class="line">va_end(ap);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ntyExceptionPopStack;</span><br><span class="line"></span><br><span class="line">longjmp(frame-&gt;env, ExceptionThrown);</span><br><span class="line"></span><br><span class="line">&#125; else if (cause) &#123;</span><br><span class="line"></span><br><span class="line">char message[EXCEPTIN_MESSAGE_LENGTH+1];</span><br><span class="line"></span><br><span class="line">va_start(ap, cause);</span><br><span class="line">vsnprintf(message, EXCEPTIN_MESSAGE_LENGTH, cause, ap);</span><br><span class="line">va_end(ap);</span><br><span class="line"></span><br><span class="line">printf(&quot;%s: %s\n raised in %s at %s:%d\n&quot;, excep-&gt;name, message, func ? func : &quot;?&quot;, file ? file : &quot;?&quot;, line);</span><br><span class="line"></span><br><span class="line">&#125; else &#123;</span><br><span class="line"></span><br><span class="line">printf(&quot;%s: %p\n raised in %s at %s:%d\n&quot;, excep-&gt;name, excep, func ? func : &quot;?&quot;, file ? file : &quot;?&quot;, line);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">/* ** **** ******** **************** debug **************** ******** **** ** */</span><br><span class="line"></span><br><span class="line">ntyException A = &#123;&quot;AException&quot;&#125;;</span><br><span class="line">ntyException B = &#123;&quot;BException&quot;&#125;;</span><br><span class="line">ntyException C = &#123;&quot;CException&quot;&#125;;</span><br><span class="line">ntyException D = &#123;&quot;DException&quot;&#125;;</span><br><span class="line"></span><br><span class="line">void *thread(void *args) &#123;</span><br><span class="line"></span><br><span class="line">pthread_t selfid = pthread_self();</span><br><span class="line"></span><br><span class="line">Try &#123;</span><br><span class="line"></span><br><span class="line">Throw(A, &quot;A&quot;);</span><br><span class="line"></span><br><span class="line">&#125; Catch (A) &#123;</span><br><span class="line"></span><br><span class="line">printf(&quot;catch A : %ld\n&quot;, selfid);</span><br><span class="line"></span><br><span class="line">&#125; EndTry;</span><br><span class="line"></span><br><span class="line">Try &#123;</span><br><span class="line"></span><br><span class="line">Throw(B, &quot;B&quot;);</span><br><span class="line"></span><br><span class="line">&#125; Catch (B) &#123;</span><br><span class="line"></span><br><span class="line">printf(&quot;catch B : %ld\n&quot;, selfid);</span><br><span class="line"></span><br><span class="line">&#125; EndTry;</span><br><span class="line"></span><br><span class="line">Try &#123;</span><br><span class="line"></span><br><span class="line">Throw(C, &quot;C&quot;);</span><br><span class="line"></span><br><span class="line">&#125; Catch (C) &#123;</span><br><span class="line"></span><br><span class="line">printf(&quot;catch C : %ld\n&quot;, selfid);</span><br><span class="line"></span><br><span class="line">&#125; EndTry;</span><br><span class="line"></span><br><span class="line">Try &#123;</span><br><span class="line"></span><br><span class="line">Throw(D, &quot;D&quot;);</span><br><span class="line"></span><br><span class="line">&#125; Catch (D) &#123;</span><br><span class="line"></span><br><span class="line">printf(&quot;catch D : %ld\n&quot;, selfid);</span><br><span class="line"></span><br><span class="line">&#125; EndTry;</span><br><span class="line"></span><br><span class="line">Try &#123;</span><br><span class="line"></span><br><span class="line">Throw(A, &quot;A Again&quot;);</span><br><span class="line">Throw(B, &quot;B Again&quot;);</span><br><span class="line">Throw(C, &quot;C Again&quot;);</span><br><span class="line">Throw(D, &quot;D Again&quot;);</span><br><span class="line"></span><br><span class="line">&#125; Catch (A) &#123;</span><br><span class="line"></span><br><span class="line">printf(&quot;catch A again : %ld\n&quot;, selfid);</span><br><span class="line"></span><br><span class="line">&#125; Catch (B) &#123;</span><br><span class="line"></span><br><span class="line">printf(&quot;catch B again : %ld\n&quot;, selfid);</span><br><span class="line"></span><br><span class="line">&#125; Catch (C) &#123;</span><br><span class="line"></span><br><span class="line">printf(&quot;catch C again : %ld\n&quot;, selfid);</span><br><span class="line"></span><br><span class="line">&#125; Catch (D) &#123;</span><br><span class="line"></span><br><span class="line">printf(&quot;catch B again : %ld\n&quot;, selfid);</span><br><span class="line"></span><br><span class="line">&#125; EndTry;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#define THREADS50</span><br><span class="line"></span><br><span class="line">int main(void) &#123;</span><br><span class="line"></span><br><span class="line">ntyExceptionInit();</span><br><span class="line"></span><br><span class="line">Throw(D, NULL);</span><br><span class="line"></span><br><span class="line">Throw(C, &quot;null C&quot;);</span><br><span class="line"></span><br><span class="line">printf(&quot;\n\n=&gt; Test1: Try-Catch\n&quot;);</span><br><span class="line"></span><br><span class="line">Try &#123;</span><br><span class="line"></span><br><span class="line">Try &#123;</span><br><span class="line">Throw(B, &quot;recall B&quot;);</span><br><span class="line">&#125; Catch (B) &#123;</span><br><span class="line">printf(&quot;recall B \n&quot;);</span><br><span class="line">&#125; EndTry;</span><br><span class="line"></span><br><span class="line">Throw(A, NULL);</span><br><span class="line"></span><br><span class="line">&#125; Catch(A) &#123;</span><br><span class="line"></span><br><span class="line">printf(&quot;\tResult: Ok\n&quot;);</span><br><span class="line"></span><br><span class="line">&#125; EndTry;</span><br><span class="line"></span><br><span class="line">printf(&quot;=&gt; Test1: Ok\n\n&quot;);</span><br><span class="line"></span><br><span class="line">printf(&quot;=&gt; Test2: Test Thread-safeness\n&quot;);</span><br><span class="line">#if 1</span><br><span class="line">int i = 0;</span><br><span class="line">pthread_t threads[THREADS];</span><br><span class="line"></span><br><span class="line">for (i = 0;i &lt; THREADS;i ++) &#123;</span><br><span class="line">pthread_create(&amp;threads[i], NULL, thread, NULL);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">for (i = 0;i &lt; THREADS;i ++) &#123;</span><br><span class="line">pthread_join(threads[i], NULL);</span><br><span class="line">&#125;</span><br><span class="line">#endif</span><br><span class="line">printf(&quot;=&gt; Test2: Ok\n\n&quot;);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;大体是通过setjmp，longjmp 跨越函数的跳动。&lt;/p&gt;
&lt;p&gt;原理类似if else，但要解决try catch嵌套问题，引入栈空间。&lt;/p&gt;
&lt;p&gt;每个结点存有上一个结点的地址，用链表串起来。&lt;/p&gt;
&lt;p&gt;通过pthread_setspecific，pthre
      
    
    </summary>
    
      <category term="基础" scheme="http://twh233.github.io/categories/%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="基础" scheme="http://twh233.github.io/tags/%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>rpc应用和原理</title>
    <link href="http://twh233.github.io/2020/11/23/rpc%E5%BA%94%E7%94%A8%E5%92%8C%E5%8E%9F%E7%90%86/"/>
    <id>http://twh233.github.io/2020/11/23/rpc应用和原理/</id>
    <published>2020-11-23T15:21:37.000Z</published>
    <updated>2020-11-23T15:29:49.778Z</updated>
    
    <content type="html"><![CDATA[<img src="/2020/11/23/rpc应用和原理/1.png"><p>rpc是实现图中RPC协议部分。</p><img src="/2020/11/23/rpc应用和原理/2.png"><p>等于是把接口写在存根里，然后通过同步或者异步的方式去调用对端的接口。这样做等于封装了框架，业务逻辑不用再管协议层，通过rpc来解决协议对接问题。</p><p>服务寻址可以使用 Call ID 映射，在 RPC 中，所有的函数都必须有自己的一个 ID 。<br>因为在本地调用中，函数体是直接通过函数指针来指定的，但是在远程调用中，函数指针是不<br>行的，因为两个进程的地址空间是完全不一样的。</p><p>客户端在做远程过程调用时，必须附上这个 ID。然后我们还需要在客户端和服务端分别维护一<br>个函数和Call ID的对应表。<br>当客户端需要进行远程调用时，它就查一下这个表，找出相应的 Call ID，然后把它传给服务端，<br>服务端也通过查表，来确定客户端需要调用的函数，然后执行相应函数的代码。</p><h2 id="使用rpc还有哪些问题要解决"><a href="#使用rpc还有哪些问题要解决" class="headerlink" title="使用rpc还有哪些问题要解决"></a>使用rpc还有哪些问题要解决</h2><ol><li><p>调用超时处理</p></li><li><p>单向调用（只send）</p></li><li><p>幂等问题</p><p> 一端数据丢失，给另一端多次发送请求。另一端只处理一次</p></li><li><p>反向调用（Nat穿越）</p> <img src="/2020/11/23/rpc应用和原理/3.png"><p> (1 客户机A1、B1顺利通过各自网关访问服务器C ，均没有问题（类似于登录）<br> (2 服务器C保存了 A1、B1各自在其网关的信息（1.2.3.4:62000、1.2.3.5:31000）没有问题。并可将该信息告知A1、B2。<br> (3 此时A1发送给B1网关的1.2.3.5:31000是否会被B1收到？答案是基本上不行（除非Y1设置为完全圆锥型，但这种设置非常少），因为Y1上检测到其存活的会话中没有一个的目的IP或端口与1.2.3.4:62000有关而将数据包全部丢弃！<br> (4 此时要实现A1、B1通过X1、Y1来互访，需要服务器C告诉它们各自在自己的网关上建立“UDP隧道”，即命令A1发送一个 192.168.0.8:4000——1.2.3.5:31000的数据报，B1发送一个192.168.1.8:4000——1.2.3.4:62000的数据报，UDP形式，这样X1、Y1上均存在了IP端口相同的两个不同会话（很显然，这要求网关为Cone NAT型–地址限制锥型或端口限制锥型），否则，对称型Symmetric NAT设置网关将导致对不同会话开启了不同端口，而该端口无法为服务器和对方所知，也就没有意义）。<br> (5 此时A1发给Y1，或者B1发给X1的数据报将不会被丢弃且正确的被对方收到.</p><p> 综合P2P可实现的条件需要：</p><p> 1、 中间服务器保存信息、并能发出建立UDP隧道的命令</p><p> 2、 网关均要求为Cone NAT类型。Symmetric NAT不适合。</p><p> 3、 完全圆锥型网关可以无需建立udp隧道，但这种情况非常少，要求双方均为这种类型网关的更少。</p><p> 4、 假如X1网关为Symmetric NAT， Y1为Address Restricted Cone NAT 或Full Cone NAT型网关，各自建立隧道后，A1可通过X1发送数据报给Y1到B1(因为Y1最多只进行IP级别的甄别)，但B1发送给X1的将会被丢弃（因为发送来的数据报中端口与X1上存在会话的端口不一致，虽然IP地址一致），所以同样没有什么意义。</p><p> 5、 假如双方均为Symmetric NAT的情形，新开了端口，对方可以在不知道的情况下尝试猜解，也可以达到目的，但这种情形成功率很低，且带来额外的系统开支，不是个好的解决办法。</p><p> 6、 不同网关型设置的差异在于，对内会采用替换IP的方式、使用不同端口不同会话的方式，使用相同端口不同会话的方式；对外会采用什么都不限制、限制IP地址、限制IP地址及端口。</p></li><li><p>MQ异步</p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;img src=&quot;/2020/11/23/rpc应用和原理/1.png&quot;&gt;
&lt;p&gt;rpc是实现图中RPC协议部分。&lt;/p&gt;
&lt;img src=&quot;/2020/11/23/rpc应用和原理/2.png&quot;&gt;
&lt;p&gt;等于是把接口写在存根里，然后通过同步或者异步的方式去调用对端的接口。这
      
    
    </summary>
    
      <category term="协议层" scheme="http://twh233.github.io/categories/%E5%8D%8F%E8%AE%AE%E5%B1%82/"/>
    
    
      <category term="rpc" scheme="http://twh233.github.io/tags/rpc/"/>
    
  </entry>
  
  <entry>
    <title>Redis/Mysql 连接池</title>
    <link href="http://twh233.github.io/2020/11/22/Redis-Mysql-%E8%BF%9E%E6%8E%A5%E6%B1%A0/"/>
    <id>http://twh233.github.io/2020/11/22/Redis-Mysql-连接池/</id>
    <published>2020-11-22T10:01:35.000Z</published>
    <updated>2020-11-22T11:54:12.797Z</updated>
    
    <content type="html"><![CDATA[<h2 id="为什么需要数据库连接池"><a href="#为什么需要数据库连接池" class="headerlink" title="为什么需要数据库连接池"></a>为什么需要数据库连接池</h2><img src="/2020/11/22/Redis-Mysql-连接池/1.png"><img src="/2020/11/22/Redis-Mysql-连接池/2.png"><h2 id="好处"><a href="#好处" class="headerlink" title="好处"></a>好处</h2><img src="/2020/11/22/Redis-Mysql-连接池/3.png"><p>做法，参考线程池</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;为什么需要数据库连接池&quot;&gt;&lt;a href=&quot;#为什么需要数据库连接池&quot; class=&quot;headerlink&quot; title=&quot;为什么需要数据库连接池&quot;&gt;&lt;/a&gt;为什么需要数据库连接池&lt;/h2&gt;&lt;img src=&quot;/2020/11/22/Redis-Mysql-连接池
      
    
    </summary>
    
      <category term="基础" scheme="http://twh233.github.io/categories/%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="连接池" scheme="http://twh233.github.io/tags/%E8%BF%9E%E6%8E%A5%E6%B1%A0/"/>
    
  </entry>
  
  <entry>
    <title>协程设计原理与实现</title>
    <link href="http://twh233.github.io/2020/11/22/%E5%8D%8F%E7%A8%8B%E8%AE%BE%E8%AE%A1%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E7%8E%B0/"/>
    <id>http://twh233.github.io/2020/11/22/协程设计原理与实现/</id>
    <published>2020-11-22T08:01:16.000Z</published>
    <updated>2020-11-22T09:48:41.984Z</updated>
    
    <content type="html"><![CDATA[<h2 id="同步-异步与协程有什么关系？"><a href="#同步-异步与协程有什么关系？" class="headerlink" title="同步/异步与协程有什么关系？"></a>同步/异步与协程有什么关系？</h2><p>同步编程方式，更加的直观。但性能不高。</p><p>目的就是以同步的编程方式，有异步的性能。</p><h2 id="如何实现？"><a href="#如何实现？" class="headerlink" title="如何实现？"></a>如何实现？</h2><p>当我们需要异步调用的时候，我们会创建一个协程。比如 accept 返回一个新的sockfd，创建一个客户端处理的子过程。再比如需要监听多个端口的时候，创建一个 server的子过程，这样多个端口同时工作的，是符合微服务的架构的。</p><h3 id="实现IO异步操作"><a href="#实现IO异步操作" class="headerlink" title="实现IO异步操作"></a>实现IO异步操作</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">while (1) &#123;</span><br><span class="line"> int nready = epoll_wait(epfd, events, EVENT_SIZE, -1);</span><br><span class="line"> for (i = 0;i &lt; nready;i ++) &#123;</span><br><span class="line"> int sockfd = events[i].data.fd;</span><br><span class="line"> if (sockfd == listenfd) &#123;</span><br><span class="line"> int connfd = accept(listenfd, xxx, xxxx);</span><br><span class="line"></span><br><span class="line"> setnonblock(connfd);</span><br><span class="line"> ev.events = EPOLLIN | EPOLLET;</span><br><span class="line"> ev.data.fd = connfd;</span><br><span class="line"> epoll_ctl(epfd, EPOLL_CTL_ADD, connfd, &amp;ev);</span><br><span class="line">  &#125; else &#123;</span><br><span class="line"></span><br><span class="line"> epoll_ctl(epfd, EPOLL_CTL_DEL, sockfd, NULL);</span><br><span class="line"> recv(sockfd, buffer, length, 0);</span><br><span class="line"> //parser_proto(buffer, length);</span><br><span class="line"> send(sockfd, buffer, length, 0);</span><br><span class="line"> epoll_ctl(epfd, EPOLL_CTL_ADD, sockfd, NULL);</span><br><span class="line"> &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>能够保证 sockfd 只在一个上下文中能够操作 IO 的。不会出现在多个上下文同时对一个 IO 进行操作的。协程的 IO 异步操作正式是采用此模式进行的。</p><img src="/2020/11/22/协程设计原理与实现/1.png"><h3 id="切换"><a href="#切换" class="headerlink" title="切换"></a>切换</h3><p>上下文通过保存CPU寄存器状态，并切换到下个CPU寄存器状态来实现。</p><img src="/2020/11/22/协程设计原理与实现/2.png"><p>底层是汇编代码</p><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><ol><li>运行体 R：包含运行状态{就绪，睡眠，等待}，运行体回调函数，<br>回调参数，栈指针，栈大小，当前运行体</li><li>调度器 S：包含执行集合{就绪，睡眠，等待}</li></ol><p>本身在使用协程的时候是创建协程，但内部是创建了一个R，需要上层S调度。</p><p>协程定义:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">typedef struct _nty_coroutine &#123;</span><br><span class="line">nty_cpu_ctx ctx;</span><br><span class="line">proc_coroutine func;</span><br><span class="line">void *arg;</span><br><span class="line">size_t stack_size;</span><br><span class="line">nty_coroutine_status status;</span><br><span class="line">nty_schedule *sched;</span><br><span class="line">uint64_t birth;</span><br><span class="line">uint64_t id;</span><br><span class="line">void *stack;</span><br><span class="line">RB_ENTRY(_nty_coroutine) sleep_node;</span><br><span class="line">RB_ENTRY(_nty_coroutine) wait_node;</span><br><span class="line">TAILQ_ENTRY(_nty_coroutine) ready_next;</span><br><span class="line">TAILQ_ENTRY(_nty_coroutine) defer_next;</span><br><span class="line">&#125; nty_coroutine;</span><br></pre></td></tr></table></figure></p><p>调度器定义:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">typedef struct _nty_coroutine_queue nty_coroutine_queue;</span><br><span class="line">typedef struct _nty_coroutine_rbtree_sleep nty_coroutine_rbtree_sleep;</span><br><span class="line">typedef struct _nty_coroutine_rbtree_wait nty_coroutine_rbtree_wait;</span><br><span class="line">typedef struct _nty_schedule &#123;</span><br><span class="line">uint64_t birth;</span><br><span class="line">nty_cpu_ctx ctx;</span><br><span class="line">struct _nty_coroutine *curr_thread;</span><br><span class="line">int page_size;</span><br><span class="line">int poller_fd;</span><br><span class="line">int eventfd;</span><br><span class="line">struct epoll_event eventlist[NTY_CO_MAX_EVENTS];</span><br><span class="line">int nevents;</span><br><span class="line">int num_new_events;</span><br><span class="line">nty_coroutine_queue ready;</span><br><span class="line">nty_coroutine_rbtree_sleep sleeping;</span><br><span class="line">nty_coroutine_rbtree_wait waiting;</span><br><span class="line">&#125; nty_schedule;</span><br></pre></td></tr></table></figure></p><h3 id="调度器"><a href="#调度器" class="headerlink" title="调度器"></a>调度器</h3><ol><li>生产者消费者模式</li></ol><img src="/2020/11/22/协程设计原理与实现/3.png"><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">while (1) &#123;</span><br><span class="line">//遍历睡眠集合，将满足条件的加入到 ready</span><br><span class="line"> nty_coroutine *expired = NULL;</span><br><span class="line"> while ((expired = sleep_tree_expired(sched)) != ) &#123;</span><br><span class="line">TAILQ_ADD(&amp;sched-&gt;ready, expired);</span><br><span class="line"> &#125;</span><br><span class="line"> //遍历等待集合，将满足添加的加入到 ready</span><br><span class="line"> nty_coroutine *wait = NULL;</span><br><span class="line"> int nready = epoll_wait(sched-&gt;epfd, events, EVENT_MAX, 1);</span><br><span class="line"> for (i = 0;i &lt; nready;i ++) &#123;</span><br><span class="line"> wait = wait_tree_search(events[i].data.fd);</span><br><span class="line"> TAILQ_ADD(&amp;sched-&gt;ready, wait);</span><br><span class="line"> &#125;</span><br><span class="line"> // 使用 resume 回复 ready 的协程运行权</span><br><span class="line"> while (!TAILQ_EMPTY(&amp;sched-&gt;ready)) &#123;</span><br><span class="line"> nty_coroutine *ready = TAILQ_POP(sched-&gt;ready);</span><br><span class="line"> resume(ready);</span><br><span class="line"> &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>多状态运行模式 </li></ol><img src="/2020/11/22/协程设计原理与实现/4.png"><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">while (1) &#123;</span><br><span class="line"> //遍历睡眠集合，使用 resume 恢复 expired 的协程运行权</span><br><span class="line"> nty_coroutine *expired = NULL;</span><br><span class="line"> while ((expired = sleep_tree_expired(sched)) != ) &#123;</span><br><span class="line">resume(expired);</span><br><span class="line"> &#125;</span><br><span class="line"> //遍历等待集合，使用 resume 恢复 wait 的协程运行权</span><br><span class="line"> nty_coroutine *wait = NULL;</span><br><span class="line"> int nready = epoll_wait(sched-&gt;epfd, events, EVENT_MAX, 1);</span><br><span class="line"> for (i = 0;i &lt; nready;i ++) &#123;</span><br><span class="line"> wait = wait_tree_search(events[i].data.fd);</span><br><span class="line">resume(wait);</span><br><span class="line"> &#125;</span><br><span class="line"> // 使用 resume 恢复 ready 的协程运行权</span><br><span class="line"> while (!TAILQ_EMPTY(sched-&gt;ready)) &#123;</span><br><span class="line"> nty_coroutine *ready = TAILQ_POP(sched-&gt;ready);</span><br><span class="line"> resume(ready);</span><br><span class="line"> &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>如果没有一个协程，调度器没有任何意义，空转。</p><p>如果只有一个协程，会在init的时候把这个状态直接改成就绪。</p><h2 id="多核开发"><a href="#多核开发" class="headerlink" title="多核开发"></a>多核开发</h2><ol><li><p>借助线程</p><p> 所有线程公用一个调度器的话，会出现线程之间互跳。最好是每个线程单独一个调度器 </p></li><li><p>借助进程<br> 每个进程一个调度器</p><p> 每个CPU都有自己的ID，把调度器的进程通过系统调用挂在CPU上。<br> 那么CPU不会切换调度队列。    </p></li><li><p>汇编</p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;同步-异步与协程有什么关系？&quot;&gt;&lt;a href=&quot;#同步-异步与协程有什么关系？&quot; class=&quot;headerlink&quot; title=&quot;同步/异步与协程有什么关系？&quot;&gt;&lt;/a&gt;同步/异步与协程有什么关系？&lt;/h2&gt;&lt;p&gt;同步编程方式，更加的直观。但性能不高。&lt;/p
      
    
    </summary>
    
      <category term="基础" scheme="http://twh233.github.io/categories/%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="协程" scheme="http://twh233.github.io/tags/%E5%8D%8F%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>内核spinlock的说明和使用</title>
    <link href="http://twh233.github.io/2020/11/19/%E5%86%85%E6%A0%B8spinlock%E7%9A%84%E8%AF%B4%E6%98%8E%E5%92%8C%E4%BD%BF%E7%94%A8/"/>
    <id>http://twh233.github.io/2020/11/19/内核spinlock的说明和使用/</id>
    <published>2020-11-19T15:47:16.000Z</published>
    <updated>2020-11-19T16:05:40.584Z</updated>
    
    <content type="html"><![CDATA[<img src="/2020/11/19/内核spinlock的说明和使用/1.png"><p>进程与进程之间同步，临界区代码要睡眠的话，一定不要使用自旋锁，<br>用信号量。</p><p>获取自旋锁合适的方法：  int spin_trylock(spinlock_t *lock)</p><h2 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h2><img src="/2020/11/19/内核spinlock的说明和使用/2.png"><img src="/2020/11/19/内核spinlock的说明和使用/3.png"><p>owner表示持有这个数字的thread可以获取自旋锁</p><p>next表示如果后续再有thread请求获取这个自旋锁，就给它分配这个数字</p><img src="/2020/11/19/内核spinlock的说明和使用/4.png"><p>汇编，把next位加一进入while循环。如果成了，那么进入临界区smp_mb()；如果没有，那么wfe()睡眠，然后从内存ACCESS_ONCE读数据到内地lockval变量。所以说其他线程没拿到锁都会锁在这里忙等。</p><img src="/2020/11/19/内核spinlock的说明和使用/5.png">]]></content>
    
    <summary type="html">
    
      
      
        &lt;img src=&quot;/2020/11/19/内核spinlock的说明和使用/1.png&quot;&gt;
&lt;p&gt;进程与进程之间同步，临界区代码要睡眠的话，一定不要使用自旋锁，&lt;br&gt;用信号量。&lt;/p&gt;
&lt;p&gt;获取自旋锁合适的方法：  int spin_trylock(spinlock_t *
      
    
    </summary>
    
      <category term="linux" scheme="http://twh233.github.io/categories/linux/"/>
    
    
      <category term="linux" scheme="http://twh233.github.io/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>skynet源码</title>
    <link href="http://twh233.github.io/2020/11/19/skynet%E6%BA%90%E7%A0%81/"/>
    <id>http://twh233.github.io/2020/11/19/skynet源码/</id>
    <published>2020-11-19T15:38:56.000Z</published>
    <updated>2020-11-19T15:44:54.207Z</updated>
    
    <content type="html"><![CDATA[<h1 id="定时器skynet-timer-c"><a href="#定时器skynet-timer-c" class="headerlink" title="定时器skynet_timer.c"></a>定时器skynet_timer.c</h1><p>skynet自带定时器功能skynet-src/skynet_timer.c，在skynet启动时会创建一个线程专门跑定时器。每帧(0.0025秒/帧)调用skynet_updatetime()</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">// skynet-src/skynet_start.c</span><br><span class="line"></span><br><span class="line">create_thread(&amp;pid[1], thread_timer, m);</span><br><span class="line"></span><br><span class="line">static void *</span><br><span class="line">thread_timer(void *p) &#123;</span><br><span class="line">    struct monitor * m = p;</span><br><span class="line">    skynet_initthread(THREAD_TIMER);</span><br><span class="line">    for (;;) &#123;</span><br><span class="line">        skynet_updatetime();</span><br><span class="line">        CHECK_ABORT</span><br><span class="line">        wakeup(m,m-&gt;count-1);</span><br><span class="line">        usleep(2500);  //2500微妙=0.0025秒</span><br><span class="line">        if (SIG) &#123;</span><br><span class="line">            signal_hup();</span><br><span class="line">            SIG = 0;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="设计思想"><a href="#设计思想" class="headerlink" title="设计思想"></a>设计思想</h2><p>在skynet里，时间精度是0.01秒，这对于游戏服务器来说已经足够了，定义1滴答=0.01秒，1秒=100滴答。其核心思想是：每个定时器设置一个到期的滴答数，与当前系统的滴答数(启动时是0，然后1滴答1滴答往后跳)比较差值，如果差值interval比较小（0&lt;=interval&lt;=2^8-1），表示定时器即将到来，需要严格关注，把它们保存在2^8个定时器链表里；如果interval越大，表示定时器越远，可以不用太关注，划分成4个等级，2^8&lt;=interval&lt;=2^(8+6)-1，2^(8+6)&lt;=interval&lt;=2^(8+6+6)，…，每个等级只需要2^6个定时器链表保存，比如对于2^8&lt;=interval&lt;=2^(8+6)-1的定时器，将interval&gt;&gt;8相同的值idx保存在第一个等级位置为idx的链表里。</p><p>这样做的优势是：不用为每一个interval创建一个链表，而只需要2^8+4*(2^6)个链表，大大节省了内存。</p><p>之后，在不同情况下，分配不同等级的定时器，等级越高，表示越遥远，需要重新分配的次数越少。</p><h2 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h2><p>数据结构：timer-&gt;near，保存2^8个即将到来的定时器链表；timer-&gt;t，保存4个分级数组，数组的每一项是一个链表；timer-&gt;time保存从skynet启动到现在走过的滴答数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">// skynet-src/skynet_timer.c</span><br><span class="line">struct timer_event &#123;</span><br><span class="line">    uint32_t handle;</span><br><span class="line">    int session;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">struct timer_node &#123; //单个定时器节点</span><br><span class="line">    struct timer_node *next;</span><br><span class="line">    uint32_t expire; //到期滴答数</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">struct link_list &#123; //定时器链表</span><br><span class="line">    struct timer_node head;</span><br><span class="line">    struct timer_node *tail;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">struct timer &#123;</span><br><span class="line">    struct link_list near[TIME_NEAR];</span><br><span class="line">    struct link_list t[4][TIME_LEVEL];</span><br><span class="line">    struct spinlock lock;</span><br><span class="line">    uint32_t time; //启动到现在走过的滴答数，等同于current</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">// skynet-src/skynet_timer.c</span><br><span class="line">int</span><br><span class="line">skynet_timeout(uint32_t handle, int time, int session) &#123;</span><br><span class="line">    ...</span><br><span class="line">    struct timer_event event;</span><br><span class="line">    event.handle = handle;</span><br><span class="line">    event.session = session;</span><br><span class="line">    timer_add(TI, &amp;event, sizeof(event), time);</span><br><span class="line">/*</span><br><span class="line">timer_node指针分配空间</span><br><span class="line">*/</span><br><span class="line">    return session;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static void</span><br><span class="line">timer_add(struct timer *T,void *arg,size_t sz,int time) &#123;</span><br><span class="line">    struct timer_node *node = (struct timer_node *)skynet_malloc(sizeof(*node)+sz);</span><br><span class="line">/*</span><br><span class="line">timer_node结构里并没有timer_event字段，除了分配node自身大小外，额外再分配timer_event大小的空间用来存放event，之后通过node+1的位置可以获取到timer_event数据</span><br><span class="line">*/</span><br><span class="line">    memcpy(node+1,arg,sz);</span><br><span class="line"></span><br><span class="line">    SPIN_LOCK(T);</span><br><span class="line"></span><br><span class="line">    node-&gt;expire=time+T-&gt;time;</span><br><span class="line">    /*</span><br><span class="line">添加到定时器链表里，如果定时器的到期滴答数跟当前比较近(&lt;2^8)，表示即将触发定时器添加到T-&gt;near数组里，否则根据差值大小添加到对应的T-&gt;T[i]中</span><br><span class="line">*/</span><br><span class="line">add_node(T,node);</span><br><span class="line"></span><br><span class="line">    SPIN_UNLOCK(T);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static void</span><br><span class="line">add_node(struct timer *T,struct timer_node *node) &#123;</span><br><span class="line">    uint32_t time=node-&gt;expire;</span><br><span class="line">    uint32_t current_time=T-&gt;time;</span><br><span class="line"></span><br><span class="line">    if ((time|TIME_NEAR_MASK)==(current_time|TIME_NEAR_MASK)) &#123;</span><br><span class="line">        link(&amp;T-&gt;near[time&amp;TIME_NEAR_MASK],node);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        int i;</span><br><span class="line">        uint32_t mask=TIME_NEAR &lt;&lt; TIME_LEVEL_SHIFT;</span><br><span class="line">        for (i=0;i&lt;3;i++) &#123;</span><br><span class="line">            if ((time|(mask-1))==(current_time|(mask-1))) &#123;</span><br><span class="line">                 break;</span><br><span class="line">            &#125;</span><br><span class="line">            mask &lt;&lt;= TIME_LEVEL_SHIFT;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        link(&amp;T-&gt;t[i][((time&gt;&gt;(TIME_NEAR_SHIFT + i*TIME_LEVEL_SHIFT)) &amp; TIME_LEVEL_MASK)],node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">// skynet-src/skynet_timer.c</span><br><span class="line">static inline void</span><br><span class="line">timer_execute(struct timer *T) &#123;</span><br><span class="line">    int idx = T-&gt;time &amp; TIME_NEAR_MASK;</span><br><span class="line">/*</span><br><span class="line">每帧从T-&gt;near中触发到期的定时器链表，near数组里每一项的链表中的所有节点的到期滴答数是相同的</span><br><span class="line">*/</span><br><span class="line">    while (T-&gt;near[idx].head.next) &#123;</span><br><span class="line">        struct timer_node *current = link_clear(&amp;T-&gt;near[idx]);</span><br><span class="line">        SPIN_UNLOCK(T);</span><br><span class="line">        // dispatch_list don&apos;t need lock T</span><br><span class="line">        dispatch_list(current);</span><br><span class="line">        SPIN_LOCK(T);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static inline void</span><br><span class="line">dispatch_list(struct timer_node *current) &#123;</span><br><span class="line">    do &#123;</span><br><span class="line">/*</span><br><span class="line">调用dispatch_list进行分发，通过current+1获取timer_event数据</span><br><span class="line">*/</span><br><span class="line">        struct timer_event * event = (struct timer_event *)(current+1);</span><br><span class="line">        struct skynet_message message;</span><br><span class="line">        message.source = 0;</span><br><span class="line">        message.session = event-&gt;session;</span><br><span class="line">        message.data = NULL;</span><br><span class="line">        message.sz = (size_t)PTYPE_RESPONSE &lt;&lt; MESSAGE_TYPE_SHIFT;</span><br><span class="line">/*</span><br><span class="line">然后给event-&gt;handle push一条消息表示触发定时器</span><br><span class="line">*/</span><br><span class="line">       skynet_context_push(event-&gt;handle, &amp;message);</span><br><span class="line"></span><br><span class="line">       struct timer_node * temp = current;</span><br><span class="line">       current=current-&gt;next;</span><br><span class="line">       skynet_free(temp);</span><br><span class="line">    &#125; while (current);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>每帧除了触发定时器外，还需重新分配定时器所在区间(timer_shift)，因为T-&gt;near里保存即将触发的定时器，所以每TIME_NEAR-1（2^8-1）个滴答数才有可能需要分配（第22行）。否则，分配T-&gt;t中某个等级即可。</p><p>当T-&gt;time的低8位不全为0时，不需要分配，所以每2^8个滴答数才有需要分配一次；</p><p>当T-&gt;time的第9-14位不全为0时，重新分配T[0]等级，每2^8个滴答数分配一次，idx从1开始，每次分配+1；</p><p>当T-&gt;time的第15-20位不全为0时，重新分配T[1]等级，每2^(8+6)个滴答数分配一次，idx从1开始，每次分配+1；</p><p>当T-&gt;time的第21-26位不全为0时，重新分配T[2]等级，每2^(8+6+6)个滴答数分配一次，idx从1开始，每次分配+1；</p><p>当T-&gt;time的第27-32位不全为0时，重新分配T[3]等级，每2^(8+6+6+6)个滴答数分配一次，idx从1开始，每次分配+1；</p><p>即等级越大的定时器越遥远，越不关注，需要重新分配的次数也就越少。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">// skynet-src/skynet_timer.c</span><br><span class="line">static void</span><br><span class="line">move_list(struct timer *T, int level, int idx) &#123;</span><br><span class="line">    struct timer_node *current = link_clear(&amp;T-&gt;t[level][idx]);</span><br><span class="line">    while (current) &#123;</span><br><span class="line">        struct timer_node *temp=current-&gt;next;</span><br><span class="line">        add_node(T,current);</span><br><span class="line">        current=temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static void</span><br><span class="line">timer_shift(struct timer *T) &#123;</span><br><span class="line">    int mask = TIME_NEAR;</span><br><span class="line">    uint32_t ct = ++T-&gt;time;</span><br><span class="line">    if (ct == 0) &#123;</span><br><span class="line">        move_list(T, 3, 0);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        uint32_t time = ct &gt;&gt; TIME_NEAR_SHIFT;</span><br><span class="line">        int i=0;</span><br><span class="line"></span><br><span class="line">        while ((ct &amp; (mask-1))==0) &#123;</span><br><span class="line">            int idx=time &amp; TIME_LEVEL_MASK;</span><br><span class="line">            if (idx!=0) &#123;</span><br><span class="line">                move_list(T, i, idx);</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">            mask &lt;&lt;= TIME_LEVEL_SHIFT;</span><br><span class="line">            time &gt;&gt;= TIME_LEVEL_SHIFT;</span><br><span class="line">            ++i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;定时器skynet-timer-c&quot;&gt;&lt;a href=&quot;#定时器skynet-timer-c&quot; class=&quot;headerlink&quot; title=&quot;定时器skynet_timer.c&quot;&gt;&lt;/a&gt;定时器skynet_timer.c&lt;/h1&gt;&lt;p&gt;skynet自带定时
      
    
    </summary>
    
      <category term="skynet" scheme="http://twh233.github.io/categories/skynet/"/>
    
    
      <category term="skynet" scheme="http://twh233.github.io/tags/skynet/"/>
    
  </entry>
  
  <entry>
    <title>分布式锁实现</title>
    <link href="http://twh233.github.io/2020/11/18/%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E5%AE%9E%E7%8E%B0/"/>
    <id>http://twh233.github.io/2020/11/18/分布式锁实现/</id>
    <published>2020-11-18T15:44:36.000Z</published>
    <updated>2020-11-30T15:28:27.568Z</updated>
    
    <content type="html"><![CDATA[<h2 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h2><ol><li>线程锁<br>lock(mutex)<br>资源操作<br>unlock(mutex)</li><li>进程锁（nginx 中 accept 锁-共享内存+信号量）</li><li>分布式锁 在不同机器的进程的锁</li></ol><h2 id="分布式锁特征"><a href="#分布式锁特征" class="headerlink" title="分布式锁特征"></a>分布式锁特征</h2><p>a) 互斥性<br>b) 可重入性 一个进程允许递归获取锁（需要递归释放锁）<br>c) 锁超时（进程 crash 掉，需要考虑释放分布式锁）<br>d) 高效、高可用（redis，zk）（最后一样，一直一样）<br>e) 公平锁和非公平锁 按获取锁顺序执行，反之就是随机执行  </p><h2 id="redis实现"><a href="#redis实现" class="headerlink" title="redis实现"></a>redis实现</h2><p>redis 数据请求的方式： 请求回应+监听发布</p><p>按请求顺序来执行命令，同样的返回按照执行顺序</p><h3 id="方案1"><a href="#方案1" class="headerlink" title="方案1"></a>方案1</h3><p>获取锁：setnx(key, val) 只有在 key 不存在的时候，才能设置成功。成功收到+ok，失败收到nil。使用 setnx(key, val)需要使用额外命令设置超时 expire(key)，在这里需要使用 redis 事务lua。<br>释放锁：del(key)。</p><h3 id="方案2"><a href="#方案2" class="headerlink" title="方案2"></a>方案2</h3><p>获取锁：将 setnx 和 expire 合并为 set(“lock”, 四元组, “NX”, “EX”, 30);<br>四元组解决只由该进程释放锁，需要添加线程给操作续时间（因为可能执行逻辑超过 30 秒）。<br>释放锁：先 get(key)比较四元组，再 delete；在这里需要添加 redis 事务 lua。<br>if (get(key) == 四元组)<br>delete(key);<br>另外，当 A 释放锁，B,C,D 如何竞争锁；第一种，B,C,D 定时查询；第二种使用监听机制<br>（<a href="http://www.redis.cn/topics/pubsub.html），释放的时候发布" target="_blank" rel="noopener">http://www.redis.cn/topics/pubsub.html），释放的时候发布</a> key 删除事件，同时要监听 key<br>的超时（<a href="http://www.redis.cn/topics/notifications.html）；一般采用第一种。" target="_blank" rel="noopener">http://www.redis.cn/topics/notifications.html）；一般采用第一种。</a>  </p><img src="/2020/11/18/分布式锁实现/1.png"><h2 id="zookeeper实现"><a href="#zookeeper实现" class="headerlink" title="zookeeper实现"></a>zookeeper实现</h2><p>数据模型 + 监听机制来驱动所有的功能 事务</p><ol><li>数据模型 类似文件系统存储方式<br>持久的 持久化<br>短暂的 连接相关，连接断开后，连接创建的节点自动删除<br>顺序的  持久顺序节点<br>（持久节点，短暂顺序节点，短暂节点）</li><li>监听机制 可监听节点的变化 （创建，删除，值的变化，子节点的变化（创建或者删除））</li></ol><p>互斥锁的实现：<br>获取锁：创建同名短暂的节点 只有一个能创建成功<br>释放锁：delete 节点或者断开连接自动删除 锁超时  </p><img src="/2020/11/18/分布式锁实现/2.png"><p>公平锁的实现：  </p><ol><li>每个进程创建 lock 节点（短暂顺序节点）；  </li><li>每个进程都有独自的一个序号；假设序号为 0，说明它获取锁，那么序号不为 0， 只需要监听序号排序中前一位（可能序号小一，可能序号小更多，因为前一个节点可能自动删除了）就行了。  </li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#include &lt;time.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#include &quot;include/zookeeper.h&quot;</span><br><span class="line">#include &quot;include/zookeeper_log.h&quot;</span><br><span class="line"></span><br><span class="line">typedef struct zk_mutex_s &#123;</span><br><span class="line">    int seq_me; // 序号</span><br><span class="line">    int seq_watch; // 监听的序号</span><br><span class="line">    char watch[64]; // 监听的节点名</span><br><span class="line">&#125; zk_mutex_t;</span><br><span class="line">static zk_mutex_t zmt = &#123;0&#125;;</span><br><span class="line">static int quit = 0;</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">typedef void (*void_completion_t)(int rc, const void *data);</span><br><span class="line">*/</span><br><span class="line">void zk_delete_lock_res1_children(int rc, const void *data) &#123;</span><br><span class="line">    printf(&quot;zk_delete_lock_res1_children rc = %d\n&quot;, rc);</span><br><span class="line">    quit = 1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">typedef void (*stat_completion_t)(int rc, const struct Stat *stat,</span><br><span class="line">        const void *data);</span><br><span class="line">*/</span><br><span class="line">void zk_watch_children(int rc, const struct Stat *stat, const void *data) &#123;</span><br><span class="line">    printf(&quot;zk_watch_children_disappear rc = %d\n&quot;, rc);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">typedef void (*strings_completion_t)(int rc,</span><br><span class="line">        const struct String_vector *strings, const void *data);</span><br><span class="line">*/</span><br><span class="line">void zk_get_children_lock_res1(int rc, const struct String_vector *strings, const void *data) &#123;</span><br><span class="line">    printf(&quot;zk_get_children_lock_res1 rc = %d\n&quot;, rc);</span><br><span class="line">    if (rc == 0) &#123;</span><br><span class="line">        int i,v,n;</span><br><span class="line">        n = 0;</span><br><span class="line">        char * value_self = NULL;</span><br><span class="line">        char * value_other = NULL;</span><br><span class="line">        zhandle_t* zk_hdl = (zhandle_t*)data;</span><br><span class="line">        for (i = 0; i &lt; strings-&gt;count; i++) &#123;</span><br><span class="line">            sscanf(strings-&gt;data[i], &quot;%d&quot;, &amp;v);</span><br><span class="line">            if (v &lt; zmt.seq_me) &#123;</span><br><span class="line">                if (n == 0) &#123;</span><br><span class="line">                    zmt.seq_watch = v;</span><br><span class="line">                    value_other = strings-&gt;data[i];</span><br><span class="line">                    n++;</span><br><span class="line">                &#125; else if (n &gt; 0 &amp;&amp; v &gt; zmt.seq_watch) &#123;</span><br><span class="line">                    zmt.seq_watch = v;</span><br><span class="line">                    value_other = strings-&gt;data[i];</span><br><span class="line">                    n++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; else if (v == zmt.seq_me) &#123;</span><br><span class="line">                value_self = strings-&gt;data[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (n == 0) &#123;</span><br><span class="line">            // 说明自己已经最小的了</span><br><span class="line">            char temp[64] = &#123;0&#125;;</span><br><span class="line">            sprintf(temp, &quot;/lock/res1/%s&quot;, value_self);</span><br><span class="line">            printf(&quot;%s 获取锁, 获取执行权, 释放锁\n&quot;, temp);</span><br><span class="line">            zoo_adelete(zk_hdl, temp, -1, zk_delete_lock_res1_children, zk_hdl);</span><br><span class="line">        &#125; else if (n &gt; 0) &#123; // 找到可以监听的对象</span><br><span class="line">            memset(zmt.watch, 0, 64*sizeof(char));</span><br><span class="line">            sprintf(zmt.watch, &quot;/lock/res1/%s&quot;, value_other);</span><br><span class="line">            zoo_aexists(zk_hdl, zmt.watch, 1, zk_watch_children, zk_hdl);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">typedef void</span><br><span class="line">        (*string_completion_t)(int rc, const char *value, const void *data);</span><br><span class="line">*/</span><br><span class="line">void zk_create_lock_res1_es(int rc, const char *value, const void *data) &#123;</span><br><span class="line">    printf(&quot;zk_create_lock_res1_es rc = %d\n&quot;, rc);</span><br><span class="line">    if (rc == 0) &#123;</span><br><span class="line">        zhandle_t* zk_hdl = (zhandle_t*)data;</span><br><span class="line">        int seq;</span><br><span class="line">        sscanf(value, &quot;/lock/res1/%d&quot;, &amp;seq);</span><br><span class="line">        printf(&quot;\tname = %s seq = %d\n&quot;, value, seq);</span><br><span class="line">        zmt.seq_me = seq;</span><br><span class="line">        if (seq &gt; 0) &#123;</span><br><span class="line">            int ret;</span><br><span class="line">            ret = zoo_aget_children(zk_hdl, &quot;/lock/res1&quot;, 0, zk_get_children_lock_res1, data);</span><br><span class="line">            if (ret) &#123;</span><br><span class="line">                printf(&quot;error: zk_create_lock_res1_es:zoo_aget_children\n&quot;);</span><br><span class="line">                exit(EXIT_FAILURE);</span><br><span class="line">            &#125;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        printf(&quot;%s 获取锁, 获取执行权, 释放锁\n&quot;, value);</span><br><span class="line">        zoo_adelete(zk_hdl, value, -1, zk_delete_lock_res1_children, &quot;&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">typedef void (*watcher_fn)(zhandle_t *zh, int type,</span><br><span class="line">        int state, const char *path,void *watcherCtx);</span><br><span class="line">*/</span><br><span class="line">void zk_watcher_disconnect(zhandle_t *zh, int type, int state, const char *path, void *ctx) &#123;</span><br><span class="line">    if (0 == strcmp(zmt.watch, path)) &#123;</span><br><span class="line">        int ret = zoo_aget_children(zh, &quot;/lock/res1&quot;, 0, zk_get_children_lock_res1, zh);</span><br><span class="line">        if (ret) &#123;</span><br><span class="line">            printf(&quot;error: zk_watcher_disconnect:zoo_aget_children\n&quot;);</span><br><span class="line">            exit(EXIT_FAILURE);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main(int argc, const char *argv[]) &#123;</span><br><span class="line">    zoo_set_debug_level(ZOO_LOG_LEVEL_WARN);</span><br><span class="line">    zoo_set_log_stream(stdout);</span><br><span class="line"></span><br><span class="line">    /* 初始化 zk */</span><br><span class="line">    zhandle_t* zk_hdl = zookeeper_init(&quot;127.0.0.1:2181&quot;,</span><br><span class="line">            zk_watcher_disconnect, 30000, 0, &quot;zookeeper for distribute mutex.&quot;, 0);</span><br><span class="line">    if (!zk_hdl) &#123;</span><br><span class="line">        printf(&quot;error: connecting to zookeeper server...\n&quot;);</span><br><span class="line">        exit(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int ret;</span><br><span class="line">    /* 创建 /lock/res1/ 短暂顺序节点*/</span><br><span class="line">    ret = zoo_acreate(zk_hdl, &quot;/lock/res1/&quot;, &quot;mark&quot;, 5, &amp;ZOO_OPEN_ACL_UNSAFE,</span><br><span class="line">        ZOO_EPHEMERAL_SEQUENTIAL, zk_create_lock_res1_es, zk_hdl);</span><br><span class="line">    if (ret) &#123;</span><br><span class="line">        printf(&quot;error: create /lock/res1 EPHEMERAL SEQUENTIAL\n&quot;);</span><br><span class="line">        exit(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line">    ret = 0;</span><br><span class="line"></span><br><span class="line">    for (;;) &#123;</span><br><span class="line">        if (quit) break;</span><br><span class="line">        usleep(2500);</span><br><span class="line">    &#125;</span><br><span class="line">    zookeeper_close(zk_hdl);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;锁&quot;&gt;&lt;a href=&quot;#锁&quot; class=&quot;headerlink&quot; title=&quot;锁&quot;&gt;&lt;/a&gt;锁&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;线程锁&lt;br&gt;lock(mutex)&lt;br&gt;资源操作&lt;br&gt;unlock(mutex)&lt;/li&gt;
&lt;li&gt;进程锁（nginx 中 acc
      
    
    </summary>
    
      <category term="基础" scheme="http://twh233.github.io/categories/%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="分布式" scheme="http://twh233.github.io/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>定时器方案的实现</title>
    <link href="http://twh233.github.io/2020/11/17/%E5%AE%9A%E6%97%B6%E5%99%A8%E6%96%B9%E6%A1%88%E7%9A%84%E5%AE%9E%E7%8E%B0/"/>
    <id>http://twh233.github.io/2020/11/17/定时器方案的实现/</id>
    <published>2020-11-17T14:37:37.000Z</published>
    <updated>2020-11-19T14:20:49.112Z</updated>
    
    <content type="html"><![CDATA[<p>定时器需要满足的需求：</p><p>1.能快速找到第一个时间快到的结点</p><p>2.插入删除 o(logn)</p><h2 id="跳表"><a href="#跳表" class="headerlink" title="跳表"></a>跳表</h2><p>利用跳表来实现，那么跳表最左下角的结点就是第一个结点。<br>查找的效率o(1)</p><p>插入的效率趋近o(logn)</p><h2 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h2><p>查找、插入的效率(logn)</p><p>查第一个结点的时候<br>需要不断递归左子树</p><h2 id="时间轮"><a href="#时间轮" class="headerlink" title="时间轮"></a>时间轮</h2><img src="/2020/11/17/定时器方案的实现/1.png"><p>如图是skynet的定时器设计，就像手表，层数越低代表时间越近。</p><p>层数越低就像秒针。<br>第二层就像分针。<br>第三层像时针。</p><p>等60秒转完，那么分针的数据push进秒针里。分针往后移一格。<br>时针同理，所以称作时间轮。</p><p>缺点：<br>1.移动的，不好删除 + 引用计数  处理比较麻烦<br>2.像时钟一样运行，确保每10ms运行一次</p><h3 id="如何取消呢？"><a href="#如何取消呢？" class="headerlink" title="如何取消呢？"></a>如何取消呢？</h3><p>如果加入定时器，还没触发之前又要删掉。</p><p>只能在业务层处理屏蔽。因为时间轮这种方式是找不到对应的结点位置的。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;定时器需要满足的需求：&lt;/p&gt;
&lt;p&gt;1.能快速找到第一个时间快到的结点&lt;/p&gt;
&lt;p&gt;2.插入删除 o(logn)&lt;/p&gt;
&lt;h2 id=&quot;跳表&quot;&gt;&lt;a href=&quot;#跳表&quot; class=&quot;headerlink&quot; title=&quot;跳表&quot;&gt;&lt;/a&gt;跳表&lt;/h2&gt;&lt;p&gt;利用跳表
      
    
    </summary>
    
      <category term="基础" scheme="http://twh233.github.io/categories/%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="定时器" scheme="http://twh233.github.io/tags/%E5%AE%9A%E6%97%B6%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>内核原子变量的说明和使用</title>
    <link href="http://twh233.github.io/2020/11/17/%E5%86%85%E6%A0%B8%E5%8E%9F%E5%AD%90%E5%8F%98%E9%87%8F%E7%9A%84%E8%AF%B4%E6%98%8E%E5%92%8C%E4%BD%BF%E7%94%A8/"/>
    <id>http://twh233.github.io/2020/11/17/内核原子变量的说明和使用/</id>
    <published>2020-11-17T13:11:15.000Z</published>
    <updated>2020-11-17T13:22:11.222Z</updated>
    
    <content type="html"><![CDATA[<img src="/2020/11/17/内核原子变量的说明和使用/1.png"><p>static atomic_t can_open = ATOMIC_INIT(1);</p><p>atomic_dec_and_test 先减一，如果结果是0返回true，否则返回false。</p><p>第一次可以打开，第二次进入if。</p><p>atomic_inc 再加一，不会被打断。 原子的加法分三步，最底层调用汇编代码。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;img src=&quot;/2020/11/17/内核原子变量的说明和使用/1.png&quot;&gt;
&lt;p&gt;static atomic_t can_open = ATOMIC_INIT(1);&lt;/p&gt;
&lt;p&gt;atomic_dec_and_test 先减一，如果结果是0返回true，否则返回fal
      
    
    </summary>
    
      <category term="linux" scheme="http://twh233.github.io/categories/linux/"/>
    
    
      <category term="linux" scheme="http://twh233.github.io/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>semaphore内核源码的实现</title>
    <link href="http://twh233.github.io/2020/11/15/semaphore%E5%86%85%E6%A0%B8%E6%BA%90%E7%A0%81%E7%9A%84%E5%AE%9E%E7%8E%B0/"/>
    <id>http://twh233.github.io/2020/11/15/semaphore内核源码的实现/</id>
    <published>2020-11-15T10:11:26.000Z</published>
    <updated>2020-11-15T10:21:55.067Z</updated>
    
    <content type="html"><![CDATA[<img src="/2020/11/15/semaphore内核源码的实现/5.png"><p>首先down 是获取锁，如果获取到可以独占临界区资源执行下面语句，如果获取不到不断轮询去获取。</p><img src="/2020/11/15/semaphore内核源码的实现/2.png"><p>第一个进程只是把count–，而第二个进程才会去__down函数里</p><img src="/2020/11/15/semaphore内核源码的实现/1.png"><p>current 当前进程，把等待在信号量上的task加入waiter结构体里。</p><p>(如果有信号打断goto interrupted)</p><p>自旋锁的开销非常大，尽可能尽量少的代码在自旋锁的粒度里，所以才会有外面加锁，里面解锁又加锁。schedule_timeout会睡眠，所以没办法放进自旋锁的保护区里，当到进程二唤醒的时候接着加锁，waiter.up == true 返回 </p><img src="/2020/11/15/semaphore内核源码的实现/3.png"><p>同理。进程count++，如果wait_list空，那么调用__up函数</p><img src="/2020/11/15/semaphore内核源码的实现/4.png"><p>从刚才的容器里拿出来waiter， waiter-&gt;up = true</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;img src=&quot;/2020/11/15/semaphore内核源码的实现/5.png&quot;&gt;
&lt;p&gt;首先down 是获取锁，如果获取到可以独占临界区资源执行下面语句，如果获取不到不断轮询去获取。&lt;/p&gt;
&lt;img src=&quot;/2020/11/15/semaphore内核源码的实现
      
    
    </summary>
    
      <category term="linux" scheme="http://twh233.github.io/categories/linux/"/>
    
    
      <category term="linux" scheme="http://twh233.github.io/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>用户态协议栈TCPIP</title>
    <link href="http://twh233.github.io/2020/11/15/%E7%94%A8%E6%88%B7%E6%80%81%E5%8D%8F%E8%AE%AE%E6%A0%88TCPIP/"/>
    <id>http://twh233.github.io/2020/11/15/用户态协议栈TCPIP/</id>
    <published>2020-11-15T09:18:06.000Z</published>
    <updated>2020-11-17T13:09:27.269Z</updated>
    
    <content type="html"><![CDATA[<h2 id="网卡是属于协议栈哪一层"><a href="#网卡是属于协议栈哪一层" class="headerlink" title="网卡是属于协议栈哪一层"></a>网卡是属于协议栈哪一层</h2><p>网卡不属于任何一层。<br>物理层传输的是：光电信号<br>数据链路层对应：数字信号</p><p>网卡作用：将光电信号转化成数字信号，数字信号转化为光电信号。</p><h2 id="利用-netmap-实现协议栈"><a href="#利用-netmap-实现协议栈" class="headerlink" title="利用 netmap 实现协议栈"></a>利用 netmap 实现协议栈</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;sys/poll.h&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#define NETMAP_WITH_LIBS</span><br><span class="line"></span><br><span class="line">#include &lt;net/netmap_user.h&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#pragma pack(1)</span><br><span class="line"></span><br><span class="line">#define PROTO_IP 0x0800</span><br><span class="line">#define PROTO_UDP17</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#define ETH_LEN6</span><br><span class="line"></span><br><span class="line">struct ethhdr &#123;</span><br><span class="line"></span><br><span class="line">unsigned char h_dest[ETH_LEN]; //mac</span><br><span class="line">unsigned char h_src[ETH_LEN];</span><br><span class="line">unsigned short h_proto;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line">// sizeof(struct ethhdr) == 14</span><br><span class="line"></span><br><span class="line">struct iphdr &#123;</span><br><span class="line"></span><br><span class="line">unsigned char version:4,</span><br><span class="line">  hdrlen:4;</span><br><span class="line"></span><br><span class="line">unsigned char tos; //</span><br><span class="line">unsigned short length;</span><br><span class="line"></span><br><span class="line">unsigned short id;</span><br><span class="line"></span><br><span class="line">unsigned short flag:3,</span><br><span class="line">   offset:13;</span><br><span class="line"></span><br><span class="line">unsigned char ttl;</span><br><span class="line">unsigned char proto;</span><br><span class="line"></span><br><span class="line">unsigned short check;</span><br><span class="line"></span><br><span class="line">unsigned int sip;</span><br><span class="line">unsigned int dip;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// sizeof(struct ip) == 20</span><br><span class="line"></span><br><span class="line">struct udphdr &#123;</span><br><span class="line"></span><br><span class="line">unsigned short sport;</span><br><span class="line">unsigned short dport;</span><br><span class="line">unsigned short length;</span><br><span class="line">unsigned short check;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// sizeof(udphdr)  8</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">struct udppkt &#123;</span><br><span class="line"></span><br><span class="line">struct ethhdr eh; // 14</span><br><span class="line">struct iphdr ip;  // 20</span><br><span class="line">struct udphdr udp; // 8</span><br><span class="line"></span><br><span class="line">unsigned char body[0]; // sizeof(body)=0;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// sizeof(udppkt) = 44</span><br><span class="line">// sizeof()</span><br><span class="line"></span><br><span class="line">// f-stack</span><br><span class="line">// dpdk + bsd </span><br><span class="line"></span><br><span class="line">// netmap , dpdk, raw_socket</span><br><span class="line"></span><br><span class="line">// netmap:eth0</span><br><span class="line">// eth0</span><br><span class="line">int main() &#123;</span><br><span class="line"></span><br><span class="line">// eth0  --&gt; ens33</span><br><span class="line">struct nm_desc *nmr = nm_open(&quot;netmap:eth0&quot;, NULL, 0, NULL);</span><br><span class="line">if (nmr == NULL) &#123;</span><br><span class="line">return -1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">struct pollfd pfd = &#123;0&#125;;</span><br><span class="line">pfd.fd = nmr-&gt;fd; //</span><br><span class="line">pfd.events = POLLIN;</span><br><span class="line">// select/poll  or epoll</span><br><span class="line">// poll --&gt; select</span><br><span class="line">while (1) &#123;</span><br><span class="line"></span><br><span class="line">int ret = poll(&amp;pfd, 1, -1);</span><br><span class="line">if (ret &lt; 0) continue;</span><br><span class="line"></span><br><span class="line">if (pfd.revents &amp; POLLIN) &#123;</span><br><span class="line">struct nm_pkthdr h;</span><br><span class="line">unsigned char *stream = nm_nextpkt(nmr, &amp;h); // read</span><br><span class="line"></span><br><span class="line">struct ethhdr *eh = (struct ethhdr*)stream;</span><br><span class="line"></span><br><span class="line">// 0x0800</span><br><span class="line">if (ntohs(eh-&gt;h_proto) == PROTO_IP) &#123;</span><br><span class="line"></span><br><span class="line">struct udppkt *udp = (struct udppkt *)stream;</span><br><span class="line"></span><br><span class="line">if (udp-&gt;ip.proto == PROTO_UDP) &#123;</span><br><span class="line"></span><br><span class="line">//</span><br><span class="line">int udp_length = ntohs(udp-&gt;udp.length);</span><br><span class="line"></span><br><span class="line">udp-&gt;body[udp_length-8] = &apos;\0&apos;;</span><br><span class="line"></span><br><span class="line">printf(&quot;udp --&gt; %s\n&quot;, udp-&gt;body);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="为什么一会儿就不能接受发送到这个端口的数据了"><a href="#为什么一会儿就不能接受发送到这个端口的数据了" class="headerlink" title="为什么一会儿就不能接受发送到这个端口的数据了"></a>为什么一会儿就不能接受发送到这个端口的数据了</h3><p>因为arp过期了，icmp 会ping 对端，但是这个程序没有一直ping对端，导致arp过期。 不能再找到主机的MAC地址，所以发送不过去了。</p><h2 id="fd端口只有65535，为什么并发能做到上百万"><a href="#fd端口只有65535，为什么并发能做到上百万" class="headerlink" title="fd端口只有65535，为什么并发能做到上百万"></a>fd端口只有65535，为什么并发能做到上百万</h2><p>fd –&gt;  五元组(sip,dip,sport,dport,proto)</p><p>send(fd)的时候，fd 通过五元组判断客户端的唯一性</p><h2 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a>三次握手</h2><img src="/2020/11/15/用户态协议栈TCPIP/1.png"><p>syn 队列 accept队列满时，会造成真正要连接的fd阻塞。只能加外网防火墙拦截。</p><h2 id="滑动窗口"><a href="#滑动窗口" class="headerlink" title="滑动窗口"></a>滑动窗口</h2><img src="/2020/11/15/用户态协议栈TCPIP/2.png"><p>如果接收到ACK，那么说明从这个包之前的包都已经成功接受到，可以往后滑动，发送新的包。<br>对端ACK应答把窗口大小带上。</p><h2 id="快速重传"><a href="#快速重传" class="headerlink" title="快速重传"></a>快速重传</h2><p>当接收端收到比期望序号大的报文段时，便会重复发送最近一次确认的报文段的确认信号，我们称之为冗余ACK。<br>报文段1成功接收并被确认ACK 2，接收端的期待序号为2，当报文段2丢失，报文段3失序到来，与接收端的期望不匹配，接收端重复发送冗余ACK 2。</p><img src="/2020/11/15/用户态协议栈TCPIP/3.png"><h2 id="拥塞控制"><a href="#拥塞控制" class="headerlink" title="拥塞控制"></a>拥塞控制</h2><p>滑动窗口可以是动态控制大小的。跟rtt有关系。</p><p>rtt = 0.9 <em> oldrtt + 0.1 </em> newrtt</p><p>而cwnd 由慢启动 cwnd = cwnd * 2 再到拥塞控制 1/2这个过程逐步趋于一个平稳值。</p><h2 id="为什么会用udp做可靠传输"><a href="#为什么会用udp做可靠传输" class="headerlink" title="为什么会用udp做可靠传输"></a>为什么会用udp做可靠传输</h2><img src="/2020/11/15/用户态协议栈TCPIP/4.png"><p>下载的时候，TCP可以限制包数量，但是UDP不行。  </p><p>游戏打团得实时，TCP要保持有序，卡了怎么办，所以可以牺牲效率保证实时。</p><h2 id="四次挥手"><a href="#四次挥手" class="headerlink" title="四次挥手"></a>四次挥手</h2><img src="/2020/11/15/用户态协议栈TCPIP/5.png"><h3 id="为什么四次挥手是四次"><a href="#为什么四次挥手是四次" class="headerlink" title="为什么四次挥手是四次"></a>为什么四次挥手是四次</h3><p>因为对端都需要对方的确认，就像男女朋友，A提出分手，B先接受这个消息，表示我知道你要分手了。但是还需要一点时间消化，同意了再告诉A，我同意了。而且A提出分手的时候，B还有一些数据还在传，传完了之后再告诉A断开联系。所以必须是四次</p><h3 id="为什么还有fin-wait2状态"><a href="#为什么还有fin-wait2状态" class="headerlink" title="为什么还有fin_wait2状态"></a>为什么还有fin_wait2状态</h3><p>因为还要收B的数据 </p><h3 id="time-wait作用"><a href="#time-wait作用" class="headerlink" title="time_wait作用"></a>time_wait作用</h3><p>害怕最后一次ACK丢失，发送fin的时候有定时器，如果最后一次ACK可能丢失，如果在LAST_ACK状态的B收不到这个ACK的确认。B会超时重传FIN，所以time_wait是2MSL.A就能在这个时间内再次发送ACK确认，重新启动2MSL的计时器。并且有效防止了旧ACK的出现影响连接。下一个新的连接不会再出现这种旧的连接请求报文段。</p><h3 id="出现大量close-wait状态"><a href="#出现大量close-wait状态" class="headerlink" title="出现大量close_wait状态"></a>出现大量close_wait状态</h3><p>因为B端 recv() 没有调用close() 或者时机不对 </p><h3 id="如图，ACK丢失会怎样"><a href="#如图，ACK丢失会怎样" class="headerlink" title="如图，ACK丢失会怎样"></a>如图，ACK丢失会怎样</h3><p>A先收到FIN就出现closing状态，再收到ACK变为time_wait状态。</p><h3 id="中间ACK和FIN同时调用"><a href="#中间ACK和FIN同时调用" class="headerlink" title="中间ACK和FIN同时调用"></a>中间ACK和FIN同时调用</h3><p>出现A也发送关闭FIN，B也同时发送FIN，那么两边都会成为closing状态，各自收到ACK变成time_wait状态，四次挥手就变成了三次</p><h3 id="time-wait状态太多"><a href="#time-wait状态太多" class="headerlink" title="time_wait状态太多"></a>time_wait状态太多</h3><p>等待时间过长</p><h2 id="tcp与epoll的触发"><a href="#tcp与epoll的触发" class="headerlink" title="tcp与epoll的触发"></a>tcp与epoll的触发</h2><img src="/2020/11/15/用户态协议栈TCPIP/6.png">]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;网卡是属于协议栈哪一层&quot;&gt;&lt;a href=&quot;#网卡是属于协议栈哪一层&quot; class=&quot;headerlink&quot; title=&quot;网卡是属于协议栈哪一层&quot;&gt;&lt;/a&gt;网卡是属于协议栈哪一层&lt;/h2&gt;&lt;p&gt;网卡不属于任何一层。&lt;br&gt;物理层传输的是：光电信号&lt;br&gt;数据链路
      
    
    </summary>
    
      <category term="基础" scheme="http://twh233.github.io/categories/%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="TCP/IP" scheme="http://twh233.github.io/tags/TCP-IP/"/>
    
  </entry>
  
  <entry>
    <title>redis理解</title>
    <link href="http://twh233.github.io/2020/11/11/redis%E7%90%86%E8%A7%A3/"/>
    <id>http://twh233.github.io/2020/11/11/redis理解/</id>
    <published>2020-11-11T15:02:18.000Z</published>
    <updated>2020-11-14T10:00:48.980Z</updated>
    
    <content type="html"><![CDATA[<h2 id="redis的Hash如何解决冲突"><a href="#redis的Hash如何解决冲突" class="headerlink" title="redis的Hash如何解决冲突"></a>redis的Hash如何解决冲突</h2><p>链表法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">typedef struct dictht &#123;</span><br><span class="line">dictEntry **table;</span><br><span class="line">unsigned long size;</span><br><span class="line"> unsigned long sizemask;</span><br><span class="line"> unsigned long used;</span><br><span class="line">&#125; dictht;</span><br></pre></td></tr></table></figure><p>table 属性是⼀个数组，数组中的每个元素都是⼀个指向 dict.h/dictEntry 结构的指针，每个dictEntry 结构保存着⼀个键值对；<br>size 属性记录了哈希表的⼤⼩,也即是 table 数组的⼤⼩，⽽ used 属性则记录了哈希表⽬前已有节点（键值对）的数量；<br>sizemask 属性的值总是等于 size - 1 ，这个属性和哈希值⼀起决定⼀个键应该被放到 table 数组的哪个索引上⾯；used属性，表示hash表⾥已有的数量。如下图展示了⼀个空的hash表：</p><img src="/2020/11/11/redis理解/1.png"><p>hash表的节点哈希表节点使⽤ dictEntry 结构表示， 每个 dictEntry 结构都保存着⼀个键值对</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">typedef struct dictEntry &#123;</span><br><span class="line">    // 键</span><br><span class="line">    void *key;  </span><br><span class="line">    </span><br><span class="line">    // 值</span><br><span class="line">union &#123;</span><br><span class="line">void *val;</span><br><span class="line">uint64_t u64;</span><br><span class="line">int64_t s64;</span><br><span class="line">double d;</span><br><span class="line">&#125; v; </span><br><span class="line">    </span><br><span class="line">// 指向下个哈希表节点，形成链表</span><br><span class="line">struct dictEntry *next;</span><br><span class="line">&#125; dictEntry;</span><br></pre></td></tr></table></figure><p>举个例⼦，下图就展示了如何通过 next 指针，将两个索引值相同的键 k1 和 k0 连接在⼀起。</p><img src="/2020/11/11/redis理解/2.png"><p>hash表是随着K-V数量的增⼤⽽逐步增⼤的，并不直接以key的hash值为下标去取值得，⽽是以hash &amp; sizemask去获取hash表的对应节点的；hash表的节点实际上是⼀个链表，如果hash &amp;sizemask有冲突，则也把冲突key放在hash表的链表上，取值得时候还得遍历hash表⾥的链表。</p><h2 id="rehash"><a href="#rehash" class="headerlink" title="rehash"></a>rehash</h2><p>随着操作的不断执⾏，哈希表保存的键值对会逐渐地增多或者减少，为了让哈希表的负载因⼦（ratio）维持在⼀个合理的范围之内，当哈希表保存的键值对数量太多或者太少时，程序需要对哈希表的⼤⼩进⾏相应的扩展或者收缩。</p><p>扩容的步骤如下：<br>1、为字典ht[1]哈希表分配合适的空间；<br>2、将ht[0]中所有的键值对rehash到ht[1]：rehash 指的是重新计算键的哈希值和索引值，然后将键值对放置到 ht[1] 哈希表的指定位置上；<br>3、当 ht[0] 包含的所有键值对都迁移到了 ht[1] 之后（ht[0] 变为空表） 释放 ht[0] ，将 ht[1] 设置为 ht[0] ，并在 ht[1] 新创建⼀个空⽩哈希表，为下⼀次 rehash 做准备。  </p><p>当然rehash指渐进式hash，如果在服务器运作直接扩容，那么会影响服务器性能。以下是哈希表渐进式 rehash 的详细步骤：  </p><ol><li>为 ht[1] 分配空间，让字典同时持有 ht[0] 和 ht[1] 两个哈希表。</li><li>在字典中维持⼀个索引计数器变量 rehashidx ，并将它的值设置0 ， 表示 rehash ⼯作正式开始。  </li><li>在 rehash 进⾏期间，每次对字典执⾏添加、删除、查找或者更新操作时，程序除了执⾏指定的操作以外，还会顺带将 ht[0] 哈希表rehashidx 索引上的所有键值对 rehash 到 ht[1] ，当 rehash ⼯作完成之后，程序将 rehashidx 属性的值增⼀。</li><li>随着字典操作的不断执⾏，最终在某个时间点上 ht[0] 的所有键对都会被 rehash ⾄ ht[1] ，这时程序将 rehashidx 属性的值设为 -1 ， 表示 rehash 操作已完成。</li></ol><p>插曲：</p><p>keys hkeys 枚举形式，是通过高位加1的方式进行next，这样的好处是让每次扩缩容，前面的for不用再进行遍历。</p><h2 id="跳表"><a href="#跳表" class="headerlink" title="跳表"></a>跳表</h2><p>跳表与红黑树区别：<br>1) 结构的区别： 多层有序链表，二叉树<br>2）搜索的区别： 大概率的o(logn)<br>3) 功能性的区别： o(logn) zrange logn * o(logn)</p><img src="/2020/11/11/redis理解/3.png"><h2 id="主从复制"><a href="#主从复制" class="headerlink" title="主从复制"></a>主从复制</h2><h3 id="2-8版本以前的方案：全量同步"><a href="#2-8版本以前的方案：全量同步" class="headerlink" title="2.8版本以前的方案：全量同步"></a>2.8版本以前的方案：全量同步</h3><p>1.master 持久化，之后的命令写入缓冲区，发送rdb<br>2.slave接受rdb，加载至内存<br>3.master 发送缓冲区的命令，slave依次处理  </p><p>下面三种情况如何保证效率问题：<br>a.新加入从结点 b.主从连接故障  c.从结点重启 </p><p>其实如果是b情况，只需要将少量写操作同步给从数据库就行了<br>于是引入2.8版本 </p><h3 id="2-8版本"><a href="#2-8版本" class="headerlink" title="2.8版本"></a>2.8版本</h3><p>1.记录偏移量 psync<br>2.主master运行id </p><h3 id="之后版本"><a href="#之后版本" class="headerlink" title="之后版本"></a>之后版本</h3><p>rdb保存运行id以及offset<br>主切换 从需要记录之前运行id以及偏移量</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;redis的Hash如何解决冲突&quot;&gt;&lt;a href=&quot;#redis的Hash如何解决冲突&quot; class=&quot;headerlink&quot; title=&quot;redis的Hash如何解决冲突&quot;&gt;&lt;/a&gt;redis的Hash如何解决冲突&lt;/h2&gt;&lt;p&gt;链表法&lt;/p&gt;
&lt;figur
      
    
    </summary>
    
      <category term="redis" scheme="http://twh233.github.io/categories/redis/"/>
    
    
      <category term="redis" scheme="http://twh233.github.io/tags/redis/"/>
    
  </entry>
  
  <entry>
    <title>x86段页式内存管理和页表映射机制</title>
    <link href="http://twh233.github.io/2020/11/11/x86%E6%AE%B5%E9%A1%B5%E5%BC%8F%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E5%92%8C%E9%A1%B5%E8%A1%A8%E6%98%A0%E5%B0%84%E6%9C%BA%E5%88%B6/"/>
    <id>http://twh233.github.io/2020/11/11/x86段页式内存管理和页表映射机制/</id>
    <published>2020-11-11T14:51:04.000Z</published>
    <updated>2020-11-11T15:01:37.572Z</updated>
    
    <content type="html"><![CDATA[<h2 id="页表映射"><a href="#页表映射" class="headerlink" title="页表映射"></a>页表映射</h2><p>如图二级页表：</p><img src="/2020/11/11/x86段页式内存管理和页表映射机制/1.png"><p>简单来说CPU在页表映射的时候，Dir 代表页目录表的索引，Offset是偏移，Table是页表的索引。</p><p>先定位页表地址，通过Table定位到物理块地址，再加上offset得到真正的物理地址。</p><p>内核用一个页目录表，但不同进程有各自的页目录表。</p><h2 id="逻辑地址到物理地址的转换"><a href="#逻辑地址到物理地址的转换" class="headerlink" title="逻辑地址到物理地址的转换"></a>逻辑地址到物理地址的转换</h2><p>从虚拟地址段页式的转化转化成线性地址，再线性地址页表映射转化成物理地址。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;页表映射&quot;&gt;&lt;a href=&quot;#页表映射&quot; class=&quot;headerlink&quot; title=&quot;页表映射&quot;&gt;&lt;/a&gt;页表映射&lt;/h2&gt;&lt;p&gt;如图二级页表：&lt;/p&gt;
&lt;img src=&quot;/2020/11/11/x86段页式内存管理和页表映射机制/1.png&quot;&gt;
&lt;p
      
    
    </summary>
    
      <category term="linux" scheme="http://twh233.github.io/categories/linux/"/>
    
    
      <category term="linux" scheme="http://twh233.github.io/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>内核空间和用户空间</title>
    <link href="http://twh233.github.io/2020/11/10/%E5%86%85%E6%A0%B8%E7%A9%BA%E9%97%B4%E5%92%8C%E7%94%A8%E6%88%B7%E7%A9%BA%E9%97%B4/"/>
    <id>http://twh233.github.io/2020/11/10/内核空间和用户空间/</id>
    <published>2020-11-10T13:17:02.000Z</published>
    <updated>2020-11-10T13:22:22.296Z</updated>
    
    <content type="html"><![CDATA[<img src="/2020/11/10/内核空间和用户空间/1.png"><p>内核空间与用户空间拷贝的时候，需要在用户空间找到物理地址，再拷贝到内核空间的物理地址中。如果物理地址刚好在一张页上，那么可以一次完成拷贝；但如果物理地址跨页，那么会进行跨页的拷贝，性能有所降低；再者，如果在内存中没有找到，那么会引发缺页中断，去对应磁盘地址上拷贝，性能会更低。</p><img src="/2020/11/10/内核空间和用户空间/2.png"><img src="/2020/11/10/内核空间和用户空间/3.png">]]></content>
    
    <summary type="html">
    
      
      
        &lt;img src=&quot;/2020/11/10/内核空间和用户空间/1.png&quot;&gt;
&lt;p&gt;内核空间与用户空间拷贝的时候，需要在用户空间找到物理地址，再拷贝到内核空间的物理地址中。如果物理地址刚好在一张页上，那么可以一次完成拷贝；但如果物理地址跨页，那么会进行跨页的拷贝，性能有所降低；
      
    
    </summary>
    
      <category term="linux" scheme="http://twh233.github.io/categories/linux/"/>
    
    
      <category term="linux" scheme="http://twh233.github.io/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>skynet</title>
    <link href="http://twh233.github.io/2020/11/08/skynet/"/>
    <id>http://twh233.github.io/2020/11/08/skynet/</id>
    <published>2020-11-08T11:35:34.000Z</published>
    <updated>2020-11-08T12:25:31.920Z</updated>
    
    <content type="html"><![CDATA[<h2 id="多核开发与actor模型"><a href="#多核开发与actor模型" class="headerlink" title="多核开发与actor模型"></a>多核开发与actor模型</h2><ol><li><p>多进程<br> a) 消息队列  </p><pre><code>i. 协议问题  ii. 断线重连  iii. 进程启动顺序问题  iv. 负载均衡问题  v. 数据同步问题  </code></pre><p> b) RPC  </p><pre><code>i. 两个系统保持同步问题   </code></pre><p> c) zk    </p><pre><code>i. 配置项管理问题  ii. 集群管理   iii. 统一命名问题  iv. 状态同步问题  v. 分布式锁问题    </code></pre><p> d) 拆分  </p><pre><code>i. 功能拆分  ii. 热点拆分  </code></pre></li><li><p>多线程  </p></li><li>并发模型：CSP 模型 与 actor 模型  </li><li>结论：多进程并发实体是进程，多线程并发实体是线程，go 并发实体是 goroutine（协程），actor 并发实体是 actor（语言层面抽象出来的“进程”）。它们都是在隔离性（运行环境）与统一性（数据统一）之间作取舍平衡，而 actor 模型在语言层面做运行环境的隔离，数据同步依然需要通过消息来同步。actor 模型是加强版的多进程解决方案，进程间通信由<br>socket 转为指针的传递，从而通信变得更加可靠，同时多进程解决方案中，公共开源组件（消息队列，rpc，zookeeper）解决的问题，在 actor 模型中处理起来更方便。  </li><li>actor 定义：<br> a) 用于并行计算<br> b) actor 是最基本的计算单元<br> c) 基于消息计算<br> d) actor 之间通过消息沟通并且相互隔离  </li></ol><h2 id="skynet中的actor模型"><a href="#skynet中的actor模型" class="headerlink" title="skynet中的actor模型"></a>skynet中的actor模型</h2><ol><li>结构组成<br> a) 隔离的环境（内存块或 lua 虚拟机）<br> b) 消息队列<br> c) 回调函数  </li><li>实现<br> a) logger 服务 service-src/service_logger.c<br> b) lua 服务启动器 service-src/service_snlua.c  </li></ol><h2 id="actor运行以及消息调度"><a href="#actor运行以及消息调度" class="headerlink" title="actor运行以及消息调度"></a>actor运行以及消息调度</h2><img src="/2020/11/08/skynet/1.png"><ol><li>消息队列<br> a) 全局消息队列<br> b) actor 消息队列   </li><li>skynet 中锁的使用<br> a) 互斥锁  <pre><code>{% asset_img 2.png %}  </code></pre> b) 自旋锁  <pre><code>worker 轮询消息队列  {% asset_img 3.png %} </code></pre> c) 读写锁  <pre><code>handle_storage  </code></pre> d) 条件变量  <pre><code>worker 线程的休眠  </code></pre></li><li>skynet 中线程<br> a) timer<br> b) socket<br> c) worker<pre><code>i. “权重”来定制消费消息的数量（-1 消费一个，0 全部消费，1 消费一半）  ii. 休眠（条件变量）与唤醒（timer 和 socket）</code></pre> d) monitor  <pre><code>i. 检查服务消息过载</code></pre></li></ol><img src="/2020/11/08/skynet/5.png">  <img src="/2020/11/08/skynet/6.png"><h2 id="skynet网络层"><a href="#skynet网络层" class="headerlink" title="skynet网络层"></a>skynet网络层</h2><h3 id="actor-需要网络事件绑定？"><a href="#actor-需要网络事件绑定？" class="headerlink" title="actor 需要网络事件绑定？"></a>actor 需要网络事件绑定？</h3><p>1.connetfd 跟 redis  接受redis的数据<br>2.clientfd<br>3.listenfd clientfd = accept(); skynet作为客户端连接其他服务fd<br>4.管道fd 管道读端  work 线程往管道写端写数据  socket线程在管道读端读数据</p><p>worker在发送数据的时候 try_spinlock() 拿到锁，直接在worker线程将数据发送出去，其他情况在socket线程</p><img src="/2020/11/08/skynet/4.jpg"> <h3 id="阻塞IO与非阻塞IO的区别"><a href="#阻塞IO与非阻塞IO的区别" class="headerlink" title="阻塞IO与非阻塞IO的区别"></a>阻塞IO与非阻塞IO的区别</h3><ol><li>阻塞网络线程</li><li>在于没有数据到达的时候是否立刻返回</li><li>fnctl fd noblock(recv/send  read/write)决定了IO是否阻塞</li></ol><p>read(fd,buf,sz)<br>recv(fd,buf,sz,0)</p><h2 id="lua-与-c-接口编程"><a href="#lua-与-c-接口编程" class="headerlink" title="lua 与 c 接口编程"></a>lua 与 c 接口编程</h2><ol><li>元表<br> a) 定制行为 <strong>index, </strong>newindex<br> b) 只有 table 和 userdata 对象有独自的元表，其他类型只有类型元表<br> c) 只有 table 可以在 lua 中修改设置元表<br> d) userdata 只能在 c 中修改设置元表，lua 中不能修改 userdata 元表  </li><li>协程<br> a) 一段独立的执行线程<br> b) 一个 lua 虚拟机中同时只能有一个协程在运行<br> c) 目的：写的时候是同步的书写方式，而实际内部是异步非阻塞的实现   <img src="/2020/11/08/skynet/8.png"> </li><li>闭包<br> a) 表现  <pre><code>i. 函数内部可以访问函数外部的变量  ii. lua 文件是一个匿名函数  </code></pre> b) 实现  <pre><code>i. c 函数以及绑定在 c 函数上的 upvalues(上值)  </code></pre> c) 用 lua_pushcclosure 用来创建 c 闭包<br> d) 通过 lua_upvalueindex 伪索引来获取上值  </li><li>虚拟栈<br> 通过虚拟栈实现两者的读写数据操作   <img src="/2020/11/08/skynet/7.png"> </li><li>注册表<br> a) 预定义的表，用来保存任何 c 代码想保存的 lua 值<br> b) 使用 LUA_REGISTRYINDEX 来索引  </li></ol><h2 id="actor-通信"><a href="#actor-通信" class="headerlink" title="actor 通信"></a>actor 通信</h2><ol><li>skynet.send/skynet.call  </li><li>skynet.redirect  </li><li>skynet.response  </li><li>skynet.ret  </li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;多核开发与actor模型&quot;&gt;&lt;a href=&quot;#多核开发与actor模型&quot; class=&quot;headerlink&quot; title=&quot;多核开发与actor模型&quot;&gt;&lt;/a&gt;多核开发与actor模型&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;多进程&lt;br&gt; a) 消息队列  &lt;/p&gt;
      
    
    </summary>
    
      <category term="skynet" scheme="http://twh233.github.io/categories/skynet/"/>
    
    
      <category term="skynet" scheme="http://twh233.github.io/tags/skynet/"/>
    
  </entry>
  
  <entry>
    <title>工作中遇到的问题</title>
    <link href="http://twh233.github.io/2020/11/04/%E5%B7%A5%E4%BD%9C%E4%B8%AD%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98/"/>
    <id>http://twh233.github.io/2020/11/04/工作中遇到的问题/</id>
    <published>2020-11-04T14:15:10.000Z</published>
    <updated>2020-11-05T13:40:24.176Z</updated>
    
    <content type="html"><![CDATA[<p>1.result 等字段可重用的可以考虑重用节约内存<br>2.不要在客户端请求的时候处理数据，提前处理好，客户端请求直接返回<br>3.从数据库拿出来的数据都是数组，需要取ret[1]<br>4.可以从过参数传递函数，做定时器处理<br>5.数据库日志分得越详细越好，不同功能的表尽量分开<br>6.节点与节点间尽量一次性调用，避免绕圈调用<br>7.逻辑不与客户端同步，尽量保持单请求也能有反馈<br>8.在agent的监听，下线记得清除或者在task_msg_center.lua去统一<br>9.lua是协程，有的情况也得考虑下锁的问题<br>10.mysql中，<br>varchar 存储变长的字符串，但需要1个或2个额外字节记录字符串长度；<br>char 存储定长的字符串。<br>DataTime 8字节，TimeStamp 4字节。<br>能用TinyInt的话不要用Int。<br>索引在where条件查询和group by查询的时候特别有效。<br>11.查询优化：<br>(1 避免查找无关列<br>(2 分解关联查询，减少锁竞争<br>(3 用=不用&lt;&gt;，”=” 增加了索引使用几率<br>(4 UNION ALL 不去重，效率高于UNION<br>(5 数据行长度不要超过8020字节，超过这个长度会占用两行<br>(6 能用数字类型的字段尽量选择数字类型而不用字符串类型（电话号码），这会降低查询和连接性能，并会增加存储开销<br>(7 对于不可变char和可变varchar，char查询快，但是耗空间，varchar慢一些，但是节省存储空间<br>(8 避免在where子句进行null判断或者用or来连接条件<br>select id from t where num = 10 or num = 20;<br>select id from t where num = 10 union all select id from t where num = 20;<br>(9 in 和 not in 慎用。对于连续的数值能用between就不要用in<br>select id from t where num in (1,2,3);<br>select id from t where num between 1 and 3;<br>(10 避免在where子句中对字段进行操作<br>select id from t where substring(name,1,3) = ‘abc’;<br>select <em> from T1 where F1 = 100 </em> 2;<br>12.DATA.match_config.signup_data_config.signup_dur 变量过长用简写local变量代替<br>13.数据结构先行，不能到后面再来补数据结构<br>14.有些数据可以考虑不写数据库<br>15.lua for k,v in pairs(table)  如果v是普通类型，直接修改v不会导致table的数据变化，如果v也是table 修改v同时会修改table<br>16.用local变量等于一张表的时候，对local变量修改之后，最后把变量重新赋值给表  </p><pre><code>local s = _table or {}s.v = 1  _table = s  </code></pre><p>17.设计功能时，考虑多方面情况，例如托管节点崩溃，上一场的崩溃是否影响下一场，避免这种情况<br>18.脑里构建模块化，无论是函数还是功能，可以分函数，分文件来写<br>19.做完功能，设计好处理崩溃的函数，例如查询在比赛里的人或者PUBLIC.exit()  </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;1.result 等字段可重用的可以考虑重用节约内存&lt;br&gt;2.不要在客户端请求的时候处理数据，提前处理好，客户端请求直接返回&lt;br&gt;3.从数据库拿出来的数据都是数组，需要取ret[1]&lt;br&gt;4.可以从过参数传递函数，做定时器处理&lt;br&gt;5.数据库日志分得越详细越好，不同
      
    
    </summary>
    
      <category term="基础" scheme="http://twh233.github.io/categories/%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="基础" scheme="http://twh233.github.io/tags/%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
</feed>
