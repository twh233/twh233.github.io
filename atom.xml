<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Twh233&#39;s Blog</title>
  
  <subtitle>Love Coding,Enjoy Life</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://twh233.github.io/"/>
  <updated>2020-10-25T03:20:28.250Z</updated>
  <id>http://twh233.github.io/</id>
  
  <author>
    <name>Twh233</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Makefile</title>
    <link href="http://twh233.github.io/2020/10/22/Makefile/"/>
    <id>http://twh233.github.io/2020/10/22/Makefile/</id>
    <published>2020-10-22T14:19:42.000Z</published>
    <updated>2020-10-25T03:20:28.250Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Makefile"><a href="#Makefile" class="headerlink" title="Makefile"></a>Makefile</h2><p>就是在命令前加了⼀个‘@’。 这⼀符号告诉 make，<br>在运⾏时不要将这⼀⾏命令显示出来。</p><p>make 在检查⼀个规则时，采⽤的⽅法是：如果先决条件中相关的⽂<br>件的时间戳⼤于⽬标的时间戳，即先决条件中的⽂件⽐⽬标更新，则知道有变化，那么需要运⾏规则当中<br>的命令重新构建⽬标。</p><h3 id="假目标"><a href="#假目标" class="headerlink" title="假目标"></a>假目标</h3><p>.PHONY: clean</p><h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><h3 id="自动变量"><a href="#自动变量" class="headerlink" title="自动变量"></a>自动变量</h3><p>$@⽤于表示⼀个规则中的⽬标。当我们的⼀个规则中有多个⽬标时，$@所指的是其中任何造成命令被<br>运⾏的⽬标。<br>$^则表示的是规则中的所有先择条件。<br>$&lt;表示的是规则中的第⼀个先决条件。  </p><h3 id="变量类别"><a href="#变量类别" class="headerlink" title="变量类别"></a>变量类别</h3><p>“=”  可递归</p><p>“:=” make 只对其进⾏⼀次扫描和替换  </p><p>“?=” 条件赋值的意思是当变量以前没有定义时，就定义它并且将左边的值赋值给它，如果已<br>经定义了那么就不再改变其值。条件赋值类似于提供了给变量赋缺省值的功能。  </p><h3 id="引用替换"><a href="#引用替换" class="headerlink" title="引用替换"></a>引用替换</h3><p>Makefile<br>.PHONY: all<br>foo = a.o b.o c.o<br>bar := $(foo:.o=.c)<br>all:<br>@echo “bar = $(bar)”  </p><p>执⾏<br>$make<br>bar = a.c b.c c.c  </p><h3 id="override"><a href="#override" class="headerlink" title="override"></a>override</h3><p>手动替换</p><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><img src="/2020/10/22/Makefile/1.png"><img src="/2020/10/22/Makefile/2.png"><h2 id="包含文件"><a href="#包含文件" class="headerlink" title="包含文件"></a>包含文件</h2><p>include $(DEPS)</p><p>-include $(DEPS)  忽略文件</p><h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line">PHONY: all clean</span><br><span class="line">MKDIR = mkdir</span><br><span class="line">RM = rm</span><br><span class="line">RMFLAGS = -fr</span><br><span class="line">CC = gcc</span><br><span class="line">AR = ar</span><br><span class="line">ARFLAGS = crs</span><br><span class="line">DIR_OBJS = objs</span><br><span class="line">DIR_EXES = $(ROOT)/build/exes</span><br><span class="line">DIR_DEPS = deps</span><br><span class="line">DIR_LIBS = $(ROOT)/build/libs</span><br><span class="line">DIRS = $(DIR_DEPS) $(DIR_OBJS) $(DIR_EXES) $(DIR_LIBS)</span><br><span class="line">RMS = $(DIR_OBJS) $(DIR_DEPS)</span><br><span class="line">ifneq ($(EXE), &quot;&quot;)</span><br><span class="line">EXE := $(addprefix $(DIR_EXES)/, $(EXE))</span><br><span class="line">RMS += $(EXE)</span><br><span class="line">endif</span><br><span class="line">ifneq ($(LIB), &quot;&quot;)</span><br><span class="line">LIB := $(addprefix $(DIR_LIBS)/, $(LIB))</span><br><span class="line">RMS += $(LIB)</span><br><span class="line">endif</span><br><span class="line">SRCS = $(wildcard *.c)</span><br><span class="line">OBJS = $(SRCS:.c=.o)</span><br><span class="line">OBJS := $(addprefix $(DIR_OBJS)/, $(OBJS))</span><br><span class="line">DEPS = $(SRCS:.c=.dep)</span><br><span class="line">DEPS := $(addprefix $(DIR_DEPS)/, $(DEPS))</span><br><span class="line">ifneq ($(EXE), &quot;&quot;)</span><br><span class="line">all: $(EXE)</span><br><span class="line">endif</span><br><span class="line">ifneq ($(LIB), &quot;&quot;)</span><br><span class="line">all: $(LIB)</span><br><span class="line">endif</span><br><span class="line">ifneq ($(MAKECMDGOALS), clean)</span><br><span class="line">include $(DEPS)</span><br><span class="line">endif</span><br><span class="line">ifneq ($(INC_DIRS), &quot;&quot;)</span><br><span class="line">INC_DIRS := $(strip $(INC_DIRS))</span><br><span class="line">INC_DIRS := $(addprefix -I, $(INC_DIRS))</span><br><span class="line">endif</span><br><span class="line">ifneq ($(LINK_LIBS), &quot;&quot;)</span><br><span class="line">LINK_LIBS := $(strip $(LINK_LIBS))</span><br><span class="line">LINK_LIBS := $(addprefix -l, $(LINK_LIBS))</span><br><span class="line">endif</span><br><span class="line">$(DIRS):</span><br><span class="line">$(MKDIR) $@</span><br><span class="line">$(EXE): $(DIR_EXES) $(OBJS)</span><br><span class="line">$(CC) -L$(DIR_LIBS) -o $@ $(filter %.o, $^) $(LINK_LIBS)</span><br><span class="line">$(LIB): $(DIR_LIBS) $(OBJS)</span><br><span class="line">$(AR) $(ARFLAGS) $@ $(filter %.o, $^)</span><br><span class="line">$(DIR_OBJS)/%.o: $(DIR_OBJS) %.c</span><br><span class="line">$(CC) $(INC_DIRS) -o $@ -c $(filter %.c, $^)</span><br><span class="line">$(DIR_DEPS)/%.dep: $(DIR_DEPS) %.c</span><br><span class="line">@echo &quot;Making $@ ...&quot;</span><br><span class="line">set -e ; \</span><br><span class="line">$(RM) $(RMFLAGS) $@.tmp ; \</span><br><span class="line">$(CC) $(INC_DIRS) -E -MM $(filter %.c, $^) &gt; $@.tmp ; \</span><br><span class="line">sed &apos;s,\(.*\)\.o[ :]*,objs/\1.o $@: ,g&apos; &lt; $@.tmp &gt; $@ ; \</span><br><span class="line">$(RM) $(RMFLAGS) $@.tmp</span><br><span class="line">clean:</span><br><span class="line">$(RM) $(RMFLAGS) $(RMS)</span><br><span class="line">source/foo/src/Makefile</span><br><span class="line">EXE =</span><br><span class="line">LIB = libfoo.a</span><br><span class="line">INC_DIRS = $(ROOT)/source/foo/inc</span><br><span class="line">LINK_LIBS =</span><br><span class="line">include $(ROOT)/build/make.rule</span><br><span class="line">source/huge/src/Makefile</span><br><span class="line">EXE = huge</span><br><span class="line">LIB =</span><br><span class="line">INC_DIRS = $(ROOT)/source/foo/inc</span><br><span class="line">LINK_LIBS = foo</span><br><span class="line">include $(ROOT)/build/make.rule</span><br></pre></td></tr></table></figure><p>执行<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">⽬录 /Makefile/huge/source/huge/src</span><br><span class="line">$make</span><br><span class="line">/Makefile/huge/build/make.rule:43: deps/main.dep: No such file or directory</span><br><span class="line">mkdir deps</span><br><span class="line">Making deps/main.dep ...</span><br><span class="line">mkdir objs</span><br><span class="line">gcc -I/Makefile/huge/source/foo/inc -o objs/main.o -c main.c</span><br><span class="line">gcc -L/Makefile/huge/build/libs -o /Makefile/huge/build/exes/huge objs/main.o -lfoo</span><br><span class="line">⽬录 /Makefile/huge/source/huge/src</span><br><span class="line">$$ROOT/build/exes/huge</span><br><span class="line">This is foo ()!</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">source/build/Makefile</span><br><span class="line">.PHONY: all clean</span><br><span class="line">DIRS = $(ROOT)/source/foo/src \</span><br><span class="line">$(ROOT)/source/bar/src \</span><br><span class="line">$(ROOT)/source/huge/src</span><br><span class="line">RM = rm</span><br><span class="line">RMFLAGS = -fr</span><br><span class="line">RMS = $(ROOT)/build/exes $(ROOT)/build/libs</span><br><span class="line">all:</span><br><span class="line">@set -e; \</span><br><span class="line">for dir in $(DIRS); \</span><br><span class="line">do \</span><br><span class="line">cd $$dir &amp;&amp; $(MAKE) ; \</span><br><span class="line">done</span><br><span class="line">@echo &quot;&quot;</span><br><span class="line">@echo &quot;:-) Completed&quot;</span><br><span class="line">@echo &quot;&quot;</span><br><span class="line">clean:</span><br><span class="line">@set -e; \</span><br><span class="line">for dir in $(DIRS); \</span><br><span class="line">do \</span><br><span class="line">cd $$dir &amp;&amp; $(MAKE) clean;\</span><br><span class="line">done</span><br><span class="line">$(RM) $(RMFLAGS) $(RMS)</span><br><span class="line">@echo &quot;&quot;</span><br><span class="line">@echo &quot;:-) Completed&quot;</span><br><span class="line">@echo &quot;&quot;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">⽬录 /Makefile/build</span><br><span class="line">$make</span><br><span class="line">make[1]: Entering directory `/Makefile/huge/source/foo/src&apos;</span><br><span class="line">/Makefile/huge/build/make.rule:43: deps/foo.dep: No such file or directory</span><br><span class="line">mkdir deps</span><br><span class="line">Making deps/foo.dep ...</span><br><span class="line">make[1]: Leaving directory `/Makefile/huge/source/foo/src&apos;</span><br><span class="line">make[1]: Entering directory `/Makefile/huge/source/foo/src&apos;</span><br><span class="line">mkdir /Makefile/huge/build/libs</span><br><span class="line">mkdir objs</span><br><span class="line">gcc -I/Makefile/huge/source/foo/inc -o objs/foo.o -c foo.c</span><br><span class="line">ar crs /Makefile/huge/build/libs/libfoo.a objs/foo.o</span><br><span class="line">make[1]: Leaving directory `/Makefile/huge/source/foo/src&apos;</span><br><span class="line">make[1]: Entering directory `/Makefile/huge/source/bar/src&apos;</span><br><span class="line">/Makefile/huge/build/make.rule:43: deps/bar.dep: No such file or director</span><br><span class="line">mkdir deps</span><br><span class="line">Making deps/bar.dep ...</span><br><span class="line">make[1]: Leaving directory `/Makefile/huge/source/bar/src&apos;</span><br><span class="line">make[1]: Entering directory `/Makefile/huge/source/bar/src&apos;</span><br><span class="line">mkdir objs</span><br><span class="line">gcc -I/Makefile/huge/source/bar/inc -o objs/bar.o -c bar.c</span><br><span class="line">ar crs /Makefile/huge/build/libs/libbar.a objs/bar.o</span><br><span class="line">make[1]: Leaving directory `/Makefile/huge/source/bar/src&apos;</span><br><span class="line">make[1]: Entering directory `/Makefile/huge/source/huge/src&apos;</span><br><span class="line">/Makefile/huge/build/make.rule:43: deps/main.dep: No such file or directory</span><br><span class="line">mkdir deps</span><br><span class="line">Making deps/main.dep ...</span><br><span class="line">make[1]: Leaving directory `/Makefile/huge/source/huge/src&apos;</span><br><span class="line">make[1]: Entering directory `/Makefile/huge/source/huge/src&apos;</span><br><span class="line">mkdir /Makefile/huge/build/exes</span><br><span class="line">mkdir objs</span><br><span class="line">gcc -I/Makefile/huge/source/foo/inc -I/Makefile/huge/source/bar/inc -o objs/main.o -c</span><br><span class="line">main.c</span><br><span class="line">gcc -L/Makefile/huge/build/libs -o /Makefile/huge/build/exes/huge objs/main.o -lfoo -lbar</span><br><span class="line">make[1]: Leaving directory `/Makefile/huge/source/huge/src&apos;</span><br><span class="line">:-) Completed</span><br><span class="line">⽬录 /Makefile/build</span><br><span class="line">$make clean</span><br><span class="line">make[1]: Entering directory `/Makefile/huge/source/foo/src&apos;</span><br><span class="line">rm -fr objs deps /Makefile/huge/build/libs/libfoo.a</span><br><span class="line">make[1]: Leaving directory `/Makefile/huge/source/foo/src&apos;</span><br><span class="line">make[1]: Entering directory `/Makefile/huge/source/bar/src&apos;</span><br><span class="line">rm -fr objs deps /Makefile/huge/build/libs/libbar.a</span><br><span class="line">make[1]: Leaving directory `/Makefile/huge/source/bar/src&apos;</span><br><span class="line">make[1]: Entering directory `/Makefile/huge/source/huge/src&apos;</span><br><span class="line">rm -fr objs deps /Makefile/huge/build/exes/huge</span><br><span class="line">make[1]: Leaving directory `/Makefile/huge/source/huge/src&apos;</span><br><span class="line">rm -fr /Makefile/huge/build/exes /Makefile/huge/build/libs</span><br><span class="line">:-) Completed</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Makefile&quot;&gt;&lt;a href=&quot;#Makefile&quot; class=&quot;headerlink&quot; title=&quot;Makefile&quot;&gt;&lt;/a&gt;Makefile&lt;/h2&gt;&lt;p&gt;就是在命令前加了⼀个‘@’。 这⼀符号告诉 make，&lt;br&gt;在运⾏时不要将这⼀⾏命令显示出
      
    
    </summary>
    
      <category term="基础" scheme="http://twh233.github.io/categories/%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="makefile" scheme="http://twh233.github.io/tags/makefile/"/>
    
  </entry>
  
  <entry>
    <title>Linux系统命令</title>
    <link href="http://twh233.github.io/2020/10/19/Linux%E7%B3%BB%E7%BB%9F%E5%91%BD%E4%BB%A4/"/>
    <id>http://twh233.github.io/2020/10/19/Linux系统命令/</id>
    <published>2020-10-19T12:44:13.000Z</published>
    <updated>2020-10-19T13:05:53.831Z</updated>
    
    <content type="html"><![CDATA[<h2 id="grep"><a href="#grep" class="headerlink" title="grep"></a>grep</h2><img src="/2020/10/19/Linux系统命令/1.png"><p>grep login -r msg_server/<br>反向查找，查找文件中，不包含 hello 的行。  </p><p>grep -v login ImUser.cpp<br>找出文件中包含 login 的行，并打印出行号</p><p>grep -n login ImUser.cpp<br>找出文件中包含 login 的行，打印出行号，并显示前后 3 行</p><p>grep -C 3 -n login ImUser.cpp<br>找出文件中包含 login 的行，打印出行号，并显示前后 3 行，并忽略大小写</p><p>grep -C 3 -i -n login ImUser.cpp</p><h2 id="find"><a href="#find" class="headerlink" title="find"></a>find</h2><p>find . -name FILE_NAME<br>find . -iname FILE_NAME 忽略文件名称大小写</p><h2 id="scp"><a href="#scp" class="headerlink" title="scp"></a>scp</h2><p>scp <a href="mailto:liaoqingfu@122.152.222.180" target="_blank" rel="noopener">liaoqingfu@122.152.222.180</a>:/home/liaoqingfu/test.txt . //下载文件<br>scp mi9.aac <a href="mailto:liaoqingfu@122.152.222.180" target="_blank" rel="noopener">liaoqingfu@122.152.222.180</a>:/home/liaoqingfu/ //上传文件<br>scp ‐r <a href="mailto:liaoqingfu@122.152.222.180" target="_blank" rel="noopener">liaoqingfu@122.152.222.180</a>:/home/liaoqingfu/ . //下载目录<br>scp ‐r test <a href="mailto:liaoqingfu@122.152.222.180" target="_blank" rel="noopener">liaoqingfu@122.152.222.180</a>:/home/liaoqingfu/ //上传目录  </p><h2 id="ls"><a href="#ls" class="headerlink" title="ls"></a>ls</h2><p> -t 可以查看最新修改的时间<br> -l 每行显示一个条目<br> -h 可以结合显示文件的 GB，MB 等(human)；<br> -R 递归显示<br> -n 显示组 id 和 gid  </p><p>ls -lt 按最新修改的时间排序，新修改的在前面显示。<br>ls -ltR 按最新修改的时间排序，新修改的在前面显示，并显示子目录的文件信息<br>ls -lh 以单位显示文件大小  </p><h2 id="wc"><a href="#wc" class="headerlink" title="wc"></a>wc</h2><p>wc 命令用于计算字数。 利用 wc 指令我们可以计算文件的 Byte 数、字数、或是列<br>数，若不指定文件名称、或是所给予的文件名为”-“，则 wc 指令会从标准输入设备读<br>取数据。</p><p>语法<br>wc [-clw][–help][–version][文件…] </p><p>参数：<br>-c 或–bytes 或–chars 只显示 Bytes 数。<br>-l 或–lines 只显示行数。<br>-w 或–words 只显示字数。<br>–help 在线帮助。<br>–version 显示版本信息。  </p><h2 id="pidstat"><a href="#pidstat" class="headerlink" title="pidstat"></a>pidstat</h2><p>pidstat 用于监控全部或指定的进程占用系统资源的情况，包括 CPU、内存、磁盘 I/O、<br>程切换、线程数等数据。</p><p>• -u：表示查看 cpu 相关的性能指标<br>• -w：表示查看上下文切换情况<br>• -t：查看线程相关的信息，默认是进程的;常与-w 结合使用(cpu 的上下文切换包<br>括进程的切换、线程的切换、中断的切换)<br>• -d：展示磁盘 I/O 统计数据<br>• -p：指明进程号<br>使用方式：pidstat [option] interval [count]  </p><p>[root@VM_0_3_centos ~]# pidstat -urd -p 24615<br>Linux 3.10.0-957.5.1.el7.x86_64 (VM_0_3_centos) 08/22/2019 _x86_64_ (1<br>CPU)<br>输出 CPU 的使用信息 -u<br>03:48:12 PM UID PID %usr %system %guest %CPU CPU Command<br>03:48:12 PM 0 24615 0.00 0.00 0.00 0.00 0 nginx<br>输出内存的使用信息 -r<br>03:48:12 PM UID PID minflt/s majflt/s VSZ RSS %MEM<br>Command<br>03:48:12 PM 0 24615 0.00 0.00 58252 24940 1.32 nginx<br>输出磁盘 I/O 的使用信息 -d<br>03:48:12 PM UID PID kB_rd/s kB_wr/s kB_ccwr/s Command<br>03:48:12 PM 0 24615 0.07 0.00 0.00 nginx  </p><p>03:20:54 PM UID PID cswch/s nvcswch/s Command<br>03:20:54 PM 0 24615 0.03 0.00 nginx</p><h2 id="free"><a href="#free" class="headerlink" title="free"></a>free</h2><p>此命令用于显示系统内存的使用情况，包括总体内存、己经使用的内存；还可用于显<br>示系统内核使用的缓冲区，包括缓冲（buffer）和缓存（cache）等。<br>使用方式：free<br>命令输出：<br><img src="/2020/10/19/Linux系统命令/2.png"></p><p>buffer: 攒数据，然后批量写入，比如硬盘数据的写入</p><p>cache: 低速设备到高速设备的缓存（预读），比如从硬盘读取数据，读取100字节，但实际读了4K到cache里面，下次直接从cache里取</p><h2 id="mpstat"><a href="#mpstat" class="headerlink" title="mpstat"></a>mpstat</h2><p>此命令用于实时监控系统 CPU 的一些统计信息，这些信息存放在/proc/stat 文件中，在<br>多核 CPU 系统里，不但能查看所有 CPU 的平均使用信息，还能查看某个特定 CPU 的信息。<br>使用方式：mpstat [-P {cpu|ALL}] [internal [count]]<br>当 mpstat 不带参数时，输出为从系统启动以来的平均值。</p><h2 id="df"><a href="#df" class="headerlink" title="df"></a>df</h2><p>硬盘使用情况</p><p>df -h </p><img src="/2020/10/19/Linux系统命令/3.png"><h2 id="nc"><a href="#nc" class="headerlink" title="nc"></a>nc</h2><p>验证服务器端口有没有开放</p><p>参数<br>-l 用于指定 nc 将处于侦听模式。指定该参数，则意味着 nc 被当作 server，侦听并<br>接受连接，而非向其它地址发起连接。<br>-p 暂未用到（老版本的 nc 可能需要在端口号前加-p 参数，下面测试环境是<br>centos6.6，nc 版本是 nc-1.84，未用到-p 参数）<br>-s 指定发送数据的源 IP 地址，适用于多网卡机<br>-u 指定 nc 使用 UDP 协议，默认为 TCP<br>-v 输出交互或出错信息，新手调试时尤为有用<br>-w 超时秒数，后面跟数字  </p><img src="/2020/10/19/Linux系统命令/4.png"><h2 id="nslookup"><a href="#nslookup" class="headerlink" title="nslookup"></a>nslookup</h2><p>解析IP地址</p><p>nslookup sina.com</p><h2 id="tcpdump"><a href="#tcpdump" class="headerlink" title="tcpdump"></a>tcpdump</h2><p>tcpdump 是网络状况分析和跟踪工具，是可以用来抓包的实用命令，使用前需要对<br>TCP/IP 有所熟悉，因为过滤使用的信息都是 TCP/IP 格式。</p><img src="/2020/10/19/Linux系统命令/5.png"><h2 id="proc"><a href="#proc" class="headerlink" title="proc"></a>proc</h2><p>Linux 系统内核提供了通过/proc 文件系统查看运行时内核内部数据结构的能力，也可<br>以改变内核参数设置。  </p><p>显示 CPU 信息：<br>cat /proc/cpuinfo</p><p>显示内存信息：<br>cat /proc/meminfo</p><p>显示详细的内存映射信息：<br>cat /proc/zoneinfo</p><p>显示磁盘映射信息：<br>cat /proc/mounts</p><p>查看系统平均负载命令：<br>cat /proc/loadavg</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;grep&quot;&gt;&lt;a href=&quot;#grep&quot; class=&quot;headerlink&quot; title=&quot;grep&quot;&gt;&lt;/a&gt;grep&lt;/h2&gt;&lt;img src=&quot;/2020/10/19/Linux系统命令/1.png&quot;&gt;
&lt;p&gt;grep login -r msg_serv
      
    
    </summary>
    
      <category term="linux" scheme="http://twh233.github.io/categories/linux/"/>
    
    
      <category term="linux" scheme="http://twh233.github.io/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>Valgrind/gdb</title>
    <link href="http://twh233.github.io/2020/10/15/Valgrind-gdb/"/>
    <id>http://twh233.github.io/2020/10/15/Valgrind-gdb/</id>
    <published>2020-10-15T06:47:03.000Z</published>
    <updated>2020-10-18T07:02:12.461Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Valgrind"><a href="#Valgrind" class="headerlink" title="Valgrind"></a>Valgrind</h1><p>Valgrind 是一套 Linux 下，开放源代码（ GPL V2）的仿真调试工具的集合。 Valgrind<br>由内核（ core）以及基于内核的其他调试工具组成。内核类似于一个框架（ framework），<br>它模拟了一个 CPU 环境，并提供服务给其他工具；而其他工具则类似于插件 (plug-in)，<br>利用内核提供的服务完成各种特定的内存调试任务。</p><p>1.编译安装 Valgrind<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">wget https://fossies.org/linux/misc/valgrind-3.15.0.tar.bz2</span><br><span class="line">tar -jxvf valgrind-3.15.0.tar.bz2</span><br><span class="line">cd valgrind-3.15.0</span><br><span class="line">./configure</span><br><span class="line">make</span><br><span class="line">sudo make install</span><br><span class="line">示例：</span><br><span class="line">alpha@alpha:~/share/gdb/valgrind$</span><br><span class="line">-g sample.c -o sample</span><br><span class="line">alpha@alpha:~/share/gdb/valgrind$ ls</span><br><span class="line">badacc.c badleak2.cpp badloop.c README.md sample.c valgrind-3.15.0</span><br><span class="line">badlap.c badleak.cpp badmac.cpp sample uninitial.c valgrind-3.15.0.tar.bz2</span><br><span class="line">alpha@alpha:~/share/gdb/valgrind$ valgrind ./sample</span><br><span class="line">==31558== Memcheck, a memory error detector</span><br><span class="line">==31558== LEAK SUMMARY:</span><br><span class="line">==31558== definitely lost: 40 bytes in 1 blocks</span><br><span class="line">==31558== indirectly lost: 0 bytes in 0 blocks</span><br><span class="line">==31558== possibly lost: 0 bytes in 0 blocks</span><br><span class="line">==31558== still reachable: 0 bytes in 0 blocks</span><br><span class="line">==31558== suppressed: 0 bytes in 0 blocks</span><br><span class="line">==31558== Rerun with --leak-check=full to see details of leaked memory</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">void fun( )</span><br><span class="line">&#123;</span><br><span class="line">int *p = (int *)malloc(10*sizeof(int));</span><br><span class="line">p[10] = 0;</span><br><span class="line">&#125;</span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">fun();</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>申请了空间，但是没有被释放<br>物理内存不一定连续，虚拟地址是连续的</p><h1 id="gdb"><a href="#gdb" class="headerlink" title="gdb"></a>gdb</h1><p>在编译时需要加上-g<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">–g –o hello_server hello_server.c</span><br><span class="line">alpha@alpha:~/share/gdb/gdb$ ls</span><br><span class="line">core_dump.c hello_server.c jump.c next.c redis-4.0.11.tar.gz step1.c watch.c</span><br><span class="line">alpha@alpha:~/share/gdb/gdb$</span><br><span class="line">-o hello_server hello_server.c</span><br><span class="line">alpha@alpha:~/share/gdb/gdb$ gdb hello_server</span><br><span class="line">GNU gdb (Ubuntu 7.7.1-0ubuntu5~14.04.3) 7.7.1</span><br><span class="line">Copyright (C) 2014 Free Software Foundation, Inc.</span><br><span class="line">License GPLv3+: GNU GPL version 3 or later &lt;http://gnu.org/licenses/gpl.html&gt;</span><br><span class="line">This is free software: you are free to change and redistribute it.</span><br><span class="line">There is NO WARRANTY, to the extent permitted by law. Type &quot;show copying&quot;</span><br><span class="line">and &quot;show warranty&quot; for details.</span><br><span class="line">This GDB was configured as &quot;x86_64-linux-gnu&quot;.</span><br><span class="line">Type &quot;show configuration&quot; for configuration details.</span><br><span class="line">For bug reporting instructions, please see:</span><br><span class="line">&lt;http://www.gnu.org/software/gdb/bugs/&gt;.</span><br><span class="line">Find the GDB manual and other documentation resources online at:</span><br><span class="line">&lt;http://www.gnu.org/software/gdb/documentation/&gt;.</span><br><span class="line">For help, type &quot;help&quot;.</span><br><span class="line">Type &quot;apropos word&quot; to search for commands related to &quot;word&quot;...</span><br><span class="line">Reading symbols from hello_server...(no debugging symbols found)...done.</span><br></pre></td></tr></table></figure></p><h2 id="调试-redis"><a href="#调试-redis" class="headerlink" title="调试 redis"></a>调试 redis</h2><p>安装 redis<br>1.下载源码并解压<br>wget <a href="http://download.redis.io/releases/redis-4.0.11.tar.gz" target="_blank" rel="noopener">http://download.redis.io/releases/redis-4.0.11.tar.gz</a><br>tar zxvf redis-4.0.11.tar.gz  </p><ol start="2"><li>进入 redis 源码目录并编译，注意编译时要生成调试符号并且关闭编译器优化选<br>项。<br>cd redis-4.0.11<br>make CFLAGS=”-g -O0” -j 2<br>由于 redis 是纯 C 项目，使用的编译器是 ，因而这里设置编译器的选项时使用的是 CFLAGS 选项；如<br>果项目使用的语言是 C++，那么使用的编译器一般是 g++，相对应的编译器选项是 CXXFLAGS。这点请<br>读者注意区别。另外，这里 makefile 使用了 -j 选项，其值是 2，表示开启 2 个进程同时编译，加<br>快编译速度。编译成功后，会在 src 目录下生成多个可执行程序，其中 redis-server 和 redis-cli 是需要调<br>试的程序。 进入 src 目录，使用 GDB 启动 redis-server 这个程序：<br>cd src<br>gdb ./redis-server  </li></ol><img src="/2020/10/15/Valgrind-gdb/1.png"><h2 id="gdb三种调试方式"><a href="#gdb三种调试方式" class="headerlink" title="gdb三种调试方式"></a>gdb三种调试方式</h2><h3 id="gdb-filename-直接调试目标程序"><a href="#gdb-filename-直接调试目标程序" class="headerlink" title="gdb filename 直接调试目标程序"></a>gdb filename 直接调试目标程序</h3><p>gdb ./hello_server  </p><h3 id="gdb-attach-pid-附加进程"><a href="#gdb-attach-pid-附加进程" class="headerlink" title="gdb attach pid 附加进程"></a>gdb attach pid 附加进程</h3><p>在某些情况下，一个程序已经启动了，我们想调试这个程序，但是又不想重启这个程序。 比如调试 redis。<br><img src="/2020/10/15/Valgrind-gdb/2.png"></p><p>得到 redis 进程 PID 为 35456，然后使用 gdb attach 35456，如果不是 root 权限需要加上 sudo，即是<br>sudo gdb attach 35456。</p><img src="/2020/10/15/Valgrind-gdb/3.png"><p>当用 gdb attach 上目标进程后，调试器会暂停下来，此时可以使用 continue 命令让程序继续运行，或者加<br>上相应的断点再继续运行程序。当调试完程序想结束此次调试时，而且不对当前进程 redis 有任何影响，<br>也就是说想让这个程序继续运行，可以在GDB 的命令行界面输入 detach 命令让程序与 GDB调试器分离，<br>这样 redis 就可以继续运行了：</p><img src="/2020/10/15/Valgrind-gdb/4.png"><h3 id="gdb-filename-corename-调试-core-文件"><a href="#gdb-filename-corename-调试-core-文件" class="headerlink" title="gdb filename corename 调试 core 文件"></a>gdb filename corename 调试 core 文件</h3><p>ulimit –c unlimited  暂时生效<br>产生 coredump 的条件发现 core file size 那一行默认是 0，表示关闭生成 core 文件，可以使用“ ulimit 选项名 设置值”来修改。例如，可以将 core 文件生成改成具体某个值（最大允许的字节数），这里我们使用 ulimit -c unlimited （ unlimited 是 -c 选项值）直接修改成不限制大小。将 ulimit -c unlimited 放入/etc/profile 中，然后执行 source /etc/profile 即可立即生效。即是：<br>（ 1） 将 ulimit -c unlimited 放入/etc/profile<br>（ 2） source /etc/profile<br>（ 3） 再次查看 ulimit -a<br>alpha@alpha:~/share/redis-4.0.11/src$ ulimit -a core file size          (blocks, -c) unlimited   </p><p>范例测试<br><img src="/2020/10/15/Valgrind-gdb/5.png"></p><p>编译运行<br><img src="/2020/10/15/Valgrind-gdb/6.png"></p><img src="/2020/10/15/Valgrind-gdb/7.png"><img src="/2020/10/15/Valgrind-gdb/8.png">]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Valgrind&quot;&gt;&lt;a href=&quot;#Valgrind&quot; class=&quot;headerlink&quot; title=&quot;Valgrind&quot;&gt;&lt;/a&gt;Valgrind&lt;/h1&gt;&lt;p&gt;Valgrind 是一套 Linux 下，开放源代码（ GPL V2）的仿真调试工具的集合。
      
    
    </summary>
    
      <category term="测试" scheme="http://twh233.github.io/categories/%E6%B5%8B%E8%AF%95/"/>
    
    
      <category term="测试" scheme="http://twh233.github.io/tags/%E6%B5%8B%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>log4cpp</title>
    <link href="http://twh233.github.io/2020/10/13/log4cpp/"/>
    <id>http://twh233.github.io/2020/10/13/log4cpp/</id>
    <published>2020-10-13T14:36:51.000Z</published>
    <updated>2020-10-13T14:39:53.550Z</updated>
    
    <content type="html"><![CDATA[<img src="/2020/10/13/log4cpp/1.png">]]></content>
    
    <summary type="html">
    
      
      
        &lt;img src=&quot;/2020/10/13/log4cpp/1.png&quot;&gt;

      
    
    </summary>
    
      <category term="日志" scheme="http://twh233.github.io/categories/%E6%97%A5%E5%BF%97/"/>
    
    
      <category term="log4cpp" scheme="http://twh233.github.io/tags/log4cpp/"/>
    
  </entry>
  
  <entry>
    <title>reactor模型</title>
    <link href="http://twh233.github.io/2020/10/12/reactor%E6%A8%A1%E5%9E%8B/"/>
    <id>http://twh233.github.io/2020/10/12/reactor模型/</id>
    <published>2020-10-12T14:31:23.000Z</published>
    <updated>2020-10-18T07:27:47.831Z</updated>
    
    <content type="html"><![CDATA[<p>作为一个高性能服务器程序通常需要考虑处理三类事件： I/O 事件，定时事件及信号。</p><p>应用程序需要提供相应的接口并注册到 Reactor 上，<br>如果相应的时间发生，Reactor 将主动调用应用程序注册的接口，所以Reactor译为反应堆。</p><p>Reactor 模型有三个重要的组件：<br> 多路复用器：由操作系统提供，在 linux 上一般是 select, poll, epoll 等系统调用。<br> 事件分发器：将多路复用器中返回的就绪事件分到对应的处理函数中。<br> 事件处理器：负责处理特定事件的处理函数。  </p><p>问题在于他是单线程，CPU现在的发展状况是以核心数上升。当程序需要使用多核资源时，Reactor 模型就会悲剧。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#include &lt;sys/socket.h&gt;</span><br><span class="line">#include &lt;sys/epoll.h&gt;</span><br><span class="line">#include &lt;arpa/inet.h&gt;</span><br><span class="line"></span><br><span class="line">#include &lt;fcntl.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#include &lt;errno.h&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#define BUFFER_LENGTH4096</span><br><span class="line">#define MAX_EPOLL_EVENTS1024</span><br><span class="line">#define SERVER_PORT8888</span><br><span class="line"></span><br><span class="line">typedef int NCALLBACK(int ,int, void*);</span><br><span class="line"></span><br><span class="line">struct ntyevent &#123;</span><br><span class="line">int fd;</span><br><span class="line">int events;</span><br><span class="line">void *arg;</span><br><span class="line">int (*callback)(int fd, int events, void *arg);</span><br><span class="line"></span><br><span class="line">int status;</span><br><span class="line">char buffer[BUFFER_LENGTH];</span><br><span class="line">int length;</span><br><span class="line">long last_active;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line"> * 核心是epoll和反应堆的管理</span><br><span class="line"> */</span><br><span class="line">struct ntyreactor &#123;</span><br><span class="line">int epfd;</span><br><span class="line">struct ntyevent *events;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int recv_cb(int fd, int events, void *arg);</span><br><span class="line">int send_cb(int fd, int events, void *arg);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">void nty_event_set(struct ntyevent *ev, int fd, NCALLBACK callback, void *arg) &#123;</span><br><span class="line"></span><br><span class="line">ev-&gt;fd = fd;</span><br><span class="line">ev-&gt;callback = callback;</span><br><span class="line">ev-&gt;events = 0;</span><br><span class="line">ev-&gt;arg = arg;</span><br><span class="line">ev-&gt;last_active = time(NULL);</span><br><span class="line"></span><br><span class="line">return ;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int nty_event_add(int epfd, int events, struct ntyevent *ev) &#123;</span><br><span class="line"></span><br><span class="line">struct epoll_event ep_ev = &#123;0, &#123;0&#125;&#125;;</span><br><span class="line">ep_ev.data.ptr = ev;</span><br><span class="line">ep_ev.events = ev-&gt;events = events;</span><br><span class="line"></span><br><span class="line">int op;</span><br><span class="line">if (ev-&gt;status == 1) &#123;</span><br><span class="line">op = EPOLL_CTL_MOD;</span><br><span class="line">&#125; else &#123;</span><br><span class="line">op = EPOLL_CTL_ADD;</span><br><span class="line">ev-&gt;status = 1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">if (epoll_ctl(epfd, op, ev-&gt;fd, &amp;ep_ev) &lt; 0) &#123;</span><br><span class="line">printf(&quot;event add failed [fd=%d], events[%d]\n&quot;, ev-&gt;fd, events);</span><br><span class="line">return -1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int nty_event_del(int epfd, struct ntyevent *ev) &#123;</span><br><span class="line"></span><br><span class="line">struct epoll_event ep_ev = &#123;0, &#123;0&#125;&#125;;</span><br><span class="line"></span><br><span class="line">if (ev-&gt;status != 1) &#123;</span><br><span class="line">return -1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ep_ev.data.ptr = ev;</span><br><span class="line">ev-&gt;status = 0;</span><br><span class="line">epoll_ctl(epfd, EPOLL_CTL_DEL, ev-&gt;fd, &amp;ep_ev);</span><br><span class="line"></span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int recv_cb(int fd, int events, void *arg) &#123;</span><br><span class="line"></span><br><span class="line">struct ntyreactor *reactor = (struct ntyreactor*)arg;</span><br><span class="line">struct ntyevent *ev = reactor-&gt;events+fd;</span><br><span class="line"></span><br><span class="line">int len = recv(fd, ev-&gt;buffer, BUFFER_LENGTH, 0);</span><br><span class="line">nty_event_del(reactor-&gt;epfd, ev);</span><br><span class="line"></span><br><span class="line">if (len &gt; 0) &#123;</span><br><span class="line"></span><br><span class="line">ev-&gt;length = len;</span><br><span class="line">ev-&gt;buffer[len] = &apos;\0&apos;;</span><br><span class="line"></span><br><span class="line">printf(&quot;C[%d]:%s\n&quot;, fd, ev-&gt;buffer);</span><br><span class="line"></span><br><span class="line">nty_event_set(ev, fd, send_cb, reactor);</span><br><span class="line">nty_event_add(reactor-&gt;epfd, EPOLLOUT, ev);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125; else if (len == 0) &#123;</span><br><span class="line"></span><br><span class="line">close(ev-&gt;fd);</span><br><span class="line">printf(&quot;[fd=%d] pos[%ld], closed\n&quot;, fd, ev-reactor-&gt;events);</span><br><span class="line"> </span><br><span class="line">&#125; else &#123;</span><br><span class="line"></span><br><span class="line">close(ev-&gt;fd);</span><br><span class="line">printf(&quot;recv[fd=%d] error[%d]:%s\n&quot;, fd, errno, strerror(errno));</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">return len;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int send_cb(int fd, int events, void *arg) &#123;</span><br><span class="line"></span><br><span class="line">struct ntyreactor *reactor = (struct ntyreactor*)arg;</span><br><span class="line">struct ntyevent *ev = reactor-&gt;events+fd;</span><br><span class="line"></span><br><span class="line">int len = send(fd, ev-&gt;buffer, ev-&gt;length, 0);</span><br><span class="line">if (len &gt; 0) &#123;</span><br><span class="line">printf(&quot;send[fd=%d], [%d]%s\n&quot;, fd, len, ev-&gt;buffer);</span><br><span class="line"></span><br><span class="line">nty_event_del(reactor-&gt;epfd, ev);</span><br><span class="line">nty_event_set(ev, fd, recv_cb, reactor);</span><br><span class="line">nty_event_add(reactor-&gt;epfd, EPOLLIN, ev);</span><br><span class="line"></span><br><span class="line">&#125; else &#123;</span><br><span class="line"></span><br><span class="line">close(ev-&gt;fd);</span><br><span class="line"></span><br><span class="line">nty_event_del(reactor-&gt;epfd, ev);</span><br><span class="line">printf(&quot;send[fd=%d] error %s\n&quot;, fd, strerror(errno));</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">return len;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int accept_cb(int fd, int events, void *arg) &#123;</span><br><span class="line"></span><br><span class="line">struct ntyreactor *reactor = (struct ntyreactor*)arg;</span><br><span class="line">if (reactor == NULL) return -1;</span><br><span class="line"></span><br><span class="line">struct sockaddr_in client_addr;</span><br><span class="line">socklen_t len = sizeof(client_addr);</span><br><span class="line"></span><br><span class="line">int clientfd;</span><br><span class="line"></span><br><span class="line">if ((clientfd = accept(fd, (struct sockaddr*)&amp;client_addr, &amp;len)) == -1) &#123;</span><br><span class="line">if (errno != EAGAIN &amp;&amp; errno != EINTR) &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">printf(&quot;accept: %s\n&quot;, strerror(errno));</span><br><span class="line">return -1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int i = 0;</span><br><span class="line">do &#123;</span><br><span class="line"></span><br><span class="line">for (i = 0;i &lt; MAX_EPOLL_EVENTS;i ++) &#123;</span><br><span class="line">if (reactor-&gt;events[i].status == 0) &#123;</span><br><span class="line">break;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">if (i == MAX_EPOLL_EVENTS) &#123;</span><br><span class="line">printf(&quot;%s: max connect limit[%d]\n&quot;, __func__, MAX_EPOLL_EVENTS);</span><br><span class="line">break;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int flag = 0;</span><br><span class="line">if ((flag = fcntl(clientfd, F_SETFL, O_NONBLOCK)) &lt; 0) &#123;</span><br><span class="line">printf(&quot;%s: fcntl nonblocking failed, %d\n&quot;, __func__, MAX_EPOLL_EVENTS);</span><br><span class="line">break;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">nty_event_set(&amp;reactor-&gt;events[clientfd], clientfd, recv_cb, reactor);</span><br><span class="line">nty_event_add(reactor-&gt;epfd, EPOLLIN, &amp;reactor-&gt;events[clientfd]);</span><br><span class="line"></span><br><span class="line">&#125; while (0);</span><br><span class="line"></span><br><span class="line">printf(&quot;new connect [%s:%d][time:%ld], pos[%d]\n&quot;, </span><br><span class="line">inet_ntoa(client_addr.sin_addr), ntohs(client_addr.sin_port), reactor-&gt;events[i].last_active, i);</span><br><span class="line"></span><br><span class="line">return 0;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int init_sock(short port) &#123;</span><br><span class="line"></span><br><span class="line">int fd = socket(AF_INET, SOCK_STREAM, 0);</span><br><span class="line">fcntl(fd, F_SETFL, O_NONBLOCK);</span><br><span class="line"></span><br><span class="line">struct sockaddr_in server_addr;</span><br><span class="line">memset(&amp;server_addr, 0, sizeof(server_addr));</span><br><span class="line">server_addr.sin_family = AF_INET;</span><br><span class="line">server_addr.sin_addr.s_addr = htonl(INADDR_ANY);</span><br><span class="line">server_addr.sin_port = htons(port);</span><br><span class="line"></span><br><span class="line">bind(fd, (struct sockaddr*)&amp;server_addr, sizeof(server_addr));</span><br><span class="line"></span><br><span class="line">if (listen(fd, 20) &lt; 0) &#123;</span><br><span class="line">printf(&quot;listen failed : %s\n&quot;, strerror(errno));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">return fd;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int ntyreactor_init(struct ntyreactor *reactor) &#123;</span><br><span class="line"></span><br><span class="line">if (reactor == NULL) return -1;</span><br><span class="line">memset(reactor, 0, sizeof(struct ntyreactor));</span><br><span class="line"></span><br><span class="line">reactor-&gt;epfd = epoll_create(1);</span><br><span class="line">if (reactor-&gt;epfd &lt;= 0) &#123;</span><br><span class="line">printf(&quot;create epfd in %s err %s\n&quot;, __func__, strerror(errno));</span><br><span class="line">return -2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">reactor-&gt;events = (struct ntyevent*)malloc((MAX_EPOLL_EVENTS) * sizeof(struct ntyevent));</span><br><span class="line">if (reactor-&gt;events == NULL) &#123;</span><br><span class="line">printf(&quot;create epfd in %s err %s\n&quot;, __func__, strerror(errno));</span><br><span class="line">close(reactor-&gt;epfd);</span><br><span class="line">return -3;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int ntyreactor_destory(struct ntyreactor *reactor) &#123;</span><br><span class="line"></span><br><span class="line">close(reactor-&gt;epfd);</span><br><span class="line">free(reactor-&gt;events);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int ntyreactor_addlistener(struct ntyreactor *reactor, int sockfd, NCALLBACK *acceptor) &#123;</span><br><span class="line"></span><br><span class="line">if (reactor == NULL) return -1;</span><br><span class="line">if (reactor-&gt;events == NULL) return -1;</span><br><span class="line"></span><br><span class="line">nty_event_set(&amp;reactor-&gt;events[sockfd], sockfd, acceptor, reactor);</span><br><span class="line">nty_event_add(reactor-&gt;epfd, EPOLLIN, &amp;reactor-&gt;events[sockfd]);</span><br><span class="line"></span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int ntyreactor_run(struct ntyreactor *reactor) &#123;</span><br><span class="line">if (reactor == NULL) return -1;</span><br><span class="line">if (reactor-&gt;epfd &lt; 0) return -1;</span><br><span class="line">if (reactor-&gt;events == NULL) return -1;</span><br><span class="line"></span><br><span class="line">struct epoll_event events[MAX_EPOLL_EVENTS+1];</span><br><span class="line"></span><br><span class="line">int checkpos = 0, i;</span><br><span class="line"></span><br><span class="line">while (1) &#123;</span><br><span class="line"></span><br><span class="line">long now = time(NULL);</span><br><span class="line">for (i = 0;i &lt; 100;i ++, checkpos ++) &#123;</span><br><span class="line">if (checkpos == MAX_EPOLL_EVENTS) &#123;</span><br><span class="line">checkpos = 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">if (reactor-&gt;events[checkpos].status != 1) &#123;</span><br><span class="line">continue;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">long duration = now - reactor-&gt;events[checkpos].last_active;</span><br><span class="line"></span><br><span class="line">if (duration &gt;= 60) &#123;</span><br><span class="line">close(reactor-&gt;events[checkpos].fd);</span><br><span class="line">printf(&quot;[fd=%d] timeout\n&quot;, reactor-&gt;events[checkpos].fd);</span><br><span class="line">nty_event_del(reactor-&gt;epfd, &amp;reactor-&gt;events[checkpos]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int nready = epoll_wait(reactor-&gt;epfd, events, MAX_EPOLL_EVENTS, 1000);</span><br><span class="line">if (nready &lt; 0) &#123;</span><br><span class="line">printf(&quot;epoll_wait error, exit\n&quot;);</span><br><span class="line">continue;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">for (i = 0;i &lt; nready;i ++) &#123;</span><br><span class="line"></span><br><span class="line">struct ntyevent *ev = (struct ntyevent*)events[i].data.ptr;</span><br><span class="line"></span><br><span class="line">if ((events[i].events &amp; EPOLLIN) &amp;&amp; (ev-&gt;events &amp; EPOLLIN)) &#123;</span><br><span class="line">ev-&gt;callback(ev-&gt;fd, events[i].events, ev-&gt;arg);</span><br><span class="line">&#125;</span><br><span class="line">if ((events[i].events &amp; EPOLLOUT) &amp;&amp; (ev-&gt;events &amp; EPOLLOUT)) &#123;</span><br><span class="line">ev-&gt;callback(ev-&gt;fd, events[i].events, ev-&gt;arg);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">int main(int argc, char *argv[]) &#123;</span><br><span class="line"></span><br><span class="line">unsigned short port = SERVER_PORT;</span><br><span class="line">if (argc == 2) &#123;</span><br><span class="line">port = atoi(argv[1]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int sockfd = init_sock(port);</span><br><span class="line"></span><br><span class="line">struct ntyreactor *reactor = (struct ntyreactor*)malloc(sizeof(struct ntyreactor));</span><br><span class="line">ntyreactor_init(reactor);</span><br><span class="line"></span><br><span class="line">ntyreactor_addlistener(reactor, sockfd, accept_cb);</span><br><span class="line">ntyreactor_run(reactor);</span><br><span class="line"></span><br><span class="line">ntyreactor_destory(reactor);</span><br><span class="line">close(sockfd);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="如何使用reactor实现百万并发"><a href="#如何使用reactor实现百万并发" class="headerlink" title="如何使用reactor实现百万并发"></a>如何使用reactor实现百万并发</h2><p>服务需要解决的问题：<br>1.操作系统fd的限制<br>2.Segmentation fault(core dumped)<br>3.端口的问题</p><p>客户端端口以及服务器端口，并且同时listen多个端口</p><p>遇到问题考虑tcp五元组(sip, dip, sport, dport, proto)  </p><img src="/2020/10/12/reactor模型/1.png">]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;作为一个高性能服务器程序通常需要考虑处理三类事件： I/O 事件，定时事件及信号。&lt;/p&gt;
&lt;p&gt;应用程序需要提供相应的接口并注册到 Reactor 上，&lt;br&gt;如果相应的时间发生，Reactor 将主动调用应用程序注册的接口，所以Reactor译为反应堆。&lt;/p&gt;
&lt;p&gt;
      
    
    </summary>
    
      <category term="基础" scheme="http://twh233.github.io/categories/%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="reactor" scheme="http://twh233.github.io/tags/reactor/"/>
    
  </entry>
  
  <entry>
    <title>消息队列和ZeroMQ</title>
    <link href="http://twh233.github.io/2020/10/09/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E5%92%8CZeroMQ/"/>
    <id>http://twh233.github.io/2020/10/09/消息队列和ZeroMQ/</id>
    <published>2020-10-09T08:56:28.000Z</published>
    <updated>2020-10-09T09:07:47.440Z</updated>
    
    <content type="html"><![CDATA[<h2 id="消息可靠性处理"><a href="#消息可靠性处理" class="headerlink" title="消息可靠性处理"></a>消息可靠性处理</h2><p>(1) 确认ACK，如果没有ACK就超时重传；<br>(2) 定义序列号，消息序号是连续，中间发现消息不连续的时候就知道丢了信息；<br>(3) 备份；<br>(4) 持久化 RocketMQ</p><h2 id="消息吞吐量"><a href="#消息吞吐量" class="headerlink" title="消息吞吐量"></a>消息吞吐量</h2><img src="/2020/10/09/消息队列和ZeroMQ/1.png"><h2 id="流量削峰"><a href="#流量削峰" class="headerlink" title="流量削峰"></a>流量削峰</h2><p>使用消息队列隔离网关和后端服务，以达到流量控制和保护后端服务的目的</p><img src="/2020/10/09/消息队列和ZeroMQ/2.png"><h2 id="模型"><a href="#模型" class="headerlink" title="模型"></a>模型</h2><img src="/2020/10/09/消息队列和ZeroMQ/3.png"><img src="/2020/10/09/消息队列和ZeroMQ/4.png">]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;消息可靠性处理&quot;&gt;&lt;a href=&quot;#消息可靠性处理&quot; class=&quot;headerlink&quot; title=&quot;消息可靠性处理&quot;&gt;&lt;/a&gt;消息可靠性处理&lt;/h2&gt;&lt;p&gt;(1) 确认ACK，如果没有ACK就超时重传；&lt;br&gt;(2) 定义序列号，消息序号是连续，中间发现消
      
    
    </summary>
    
      <category term="ZeroMQ" scheme="http://twh233.github.io/categories/ZeroMQ/"/>
    
    
      <category term="ZeroMQ" scheme="http://twh233.github.io/tags/ZeroMQ/"/>
    
  </entry>
  
  <entry>
    <title>内存池</title>
    <link href="http://twh233.github.io/2020/10/09/%E5%86%85%E5%AD%98%E6%B1%A0/"/>
    <id>http://twh233.github.io/2020/10/09/内存池/</id>
    <published>2020-10-09T08:02:09.000Z</published>
    <updated>2020-10-09T08:03:18.795Z</updated>
    
    <content type="html"><![CDATA[<img src="/2020/10/09/内存池/1.png"><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line"></span><br><span class="line">#include &lt;fcntl.h&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#define MP_ALIGNMENT       32</span><br><span class="line">#define MP_PAGE_SIZE4096</span><br><span class="line">#define MP_MAX_ALLOC_FROM_POOL(MP_PAGE_SIZE-1)</span><br><span class="line"></span><br><span class="line">#define mp_align(n, alignment) (((n)+(alignment-1)) &amp; ~(alignment-1))</span><br><span class="line">#define mp_align_ptr(p, alignment) (void *)((((size_t)p)+(alignment-1)) &amp; ~(alignment-1))</span><br><span class="line"></span><br><span class="line">struct mp_large_s &#123;</span><br><span class="line">    struct mp_large_s *next;</span><br><span class="line">    void *alloc;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">struct mp_node_s &#123;</span><br><span class="line"></span><br><span class="line">    unsigned char *last; // 已经使用区段末尾</span><br><span class="line">    unsigned char *end; // 整个数据区段末尾</span><br><span class="line"></span><br><span class="line">    struct mp_node_s *next;</span><br><span class="line">    size_t failed;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">struct mp_pool_s &#123;</span><br><span class="line"></span><br><span class="line">    size_t max;</span><br><span class="line"></span><br><span class="line">    struct mp_node_s *current; // 指向mp_node_s 结点</span><br><span class="line">    struct mp_large_s *large; //大块内存</span><br><span class="line"></span><br><span class="line">    struct mp_node_s head[0];</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">//内存池创建</span><br><span class="line">struct mp_pool_s *mp_create_pool(size_t size) &#123;</span><br><span class="line">    struct mp_pool_s *p;</span><br><span class="line">    int ret = posix_memalign((void **)&amp;p, MP_ALIGNMENT, size + sizeof(struct mp_pool_s) + sizeof(struct mp_node_s));</span><br><span class="line">    if (ret) &#123;</span><br><span class="line">        return NULL;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    p-&gt;max = (size &lt; MP_MAX_ALLOC_FROM_POOL) ? size : MP_MAX_ALLOC_FROM_POOL;</span><br><span class="line">    p-&gt;current = p-&gt;head;</span><br><span class="line">    p-&gt;large = NULL;</span><br><span class="line"></span><br><span class="line">    p-&gt;head-&gt;last = (unsigned char *)p + sizeof(struct mp_pool_s) + sizeof(struct mp_node_s);</span><br><span class="line">    p-&gt;head-&gt;end = p-&gt;head-&gt;last + size;</span><br><span class="line">    p-&gt;head-&gt;failed = 0;</span><br><span class="line"></span><br><span class="line">    return p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//内存池销毁</span><br><span class="line">void mp_destory_pool(struct mp_pool_s *pool) &#123;</span><br><span class="line"></span><br><span class="line">    struct mp_node_s *h, *n;</span><br><span class="line">    struct mp_large_s *l;</span><br><span class="line">    for (l = pool-&gt;large; l; l-&gt;next) &#123;</span><br><span class="line">        if (l-&gt;alloc) &#123;</span><br><span class="line">            free(l-&gt;alloc);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    h = pool-&gt;head-&gt;next;</span><br><span class="line">    while(h) &#123;</span><br><span class="line">        n = h-&gt;next;</span><br><span class="line">        free(h);</span><br><span class="line">        h = n;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    free(pool);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//释放大页内存</span><br><span class="line">void mp_free(struct mp_pool_s *pool, void *p) &#123;</span><br><span class="line"></span><br><span class="line">    struct mp_large_s *l;</span><br><span class="line">    for (l = pool-&gt;large; l; l = l-&gt;next) &#123;</span><br><span class="line">        if (p == l-&gt;alloc) &#123;</span><br><span class="line">            free(l-&gt;alloc);</span><br><span class="line">            l-&gt;alloc = NULL;</span><br><span class="line"></span><br><span class="line">            return ;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//内存池重置</span><br><span class="line">//1.释放large</span><br><span class="line">//2.将node节点last重置</span><br><span class="line">void mp_reset_pool(struct mp_pool_s *pool) &#123;</span><br><span class="line"></span><br><span class="line">    struct mp_node_s *h;</span><br><span class="line">    struct mp_large_s *l;</span><br><span class="line"></span><br><span class="line">    for (l = pool-&gt;large; l; l = l-&gt;next) &#123;</span><br><span class="line">        if (l-&gt;alloc) &#123;</span><br><span class="line">            free(l-&gt;alloc);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    pool-&gt;large = NULL;</span><br><span class="line">    for (h = pool-&gt;head; h; h = h-&gt;next) &#123;</span><br><span class="line">        h-&gt;last = (unsigned char *)h + sizeof(struct mp_node_s);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//分配小块内存</span><br><span class="line">static void *mp_alloc_block(struct mp_pool_s *pool, size_t size) &#123;</span><br><span class="line"></span><br><span class="line">    unsigned char *m;</span><br><span class="line">    struct mp_node_s *h = pool-&gt;head;</span><br><span class="line">    size_t psize = (size_t)(h-&gt;end - (unsigned char *)h);</span><br><span class="line"></span><br><span class="line">    int ret = posix_memalign((void **)&amp;m, MP_ALIGNMENT, psize);</span><br><span class="line">    if (ret) return NULL;</span><br><span class="line"></span><br><span class="line">    struct mp_node_s *p, *new_node, *current;</span><br><span class="line">    new_node = (struct mp_node_s*)m;</span><br><span class="line"></span><br><span class="line">    new_node-&gt;end = m + psize;</span><br><span class="line">    new_node-&gt;next = NULL;</span><br><span class="line">    new_node-&gt;failed = 0;</span><br><span class="line"></span><br><span class="line">    m += sizeof(struct mp_node_s);</span><br><span class="line">    m = mp_align_ptr(m, MP_ALIGNMENT);</span><br><span class="line">    new_node-&gt;last = m + size;</span><br><span class="line"></span><br><span class="line">    current = pool-&gt;current;</span><br><span class="line"></span><br><span class="line">    for(p = current; p-&gt;next; p = p-&gt;next) &#123;</span><br><span class="line">        if (p-&gt;failed++ &gt; 4) &#123;</span><br><span class="line">            current = p-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    p-&gt;next = new_node;</span><br><span class="line"></span><br><span class="line">    pool-&gt;current = current ? current : new_node;</span><br><span class="line">    return m;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//分配大块内存</span><br><span class="line">static void *mp_alloc_large(struct mp_pool_s *pool, size_t size) &#123;</span><br><span class="line"></span><br><span class="line">    void *p = malloc(size);</span><br><span class="line">    if (p == NULL) return NULL;</span><br><span class="line"></span><br><span class="line">    size_t n = 0;</span><br><span class="line">    struct mp_large_s *large;</span><br><span class="line">    for (large = pool-&gt;large; large; large = large-&gt;next) &#123;</span><br><span class="line">        if (large-&gt;alloc == NULL) &#123;</span><br><span class="line">            large-&gt;alloc = p;</span><br><span class="line">            return p;</span><br><span class="line">        &#125;</span><br><span class="line">        if (n ++ &gt; 3) break;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    large = mp_alloc(pool, sizeof(struct mp_large_s));</span><br><span class="line">    if (large == NULL) &#123;</span><br><span class="line">        free(p);</span><br><span class="line">        return NULL;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    large-&gt;alloc = p;</span><br><span class="line">    large-&gt;next = pool-&gt;large;</span><br><span class="line">    pool-&gt;large = large;</span><br><span class="line"></span><br><span class="line">    return p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//内存池分配</span><br><span class="line">void *mp_alloc(struct mp_pool_s *pool, size_t size) &#123;</span><br><span class="line"></span><br><span class="line">    unsigned char *m;</span><br><span class="line">    struct mp_node_s *p;</span><br><span class="line"></span><br><span class="line">    if (size &lt;= pool-&gt;max) &#123;</span><br><span class="line">        p = pool-&gt;current;</span><br><span class="line"></span><br><span class="line">        do &#123;</span><br><span class="line">            m = mp_align_ptr(p-&gt;last, MP_ALIGNMENT);</span><br><span class="line">            if((size_t)(p-&gt;end - m) &gt;= size) &#123;</span><br><span class="line">                p-&gt;last = m + size;</span><br><span class="line">                return m;</span><br><span class="line">            &#125;</span><br><span class="line">            p = p-&gt;next;</span><br><span class="line">        &#125; while (p);</span><br><span class="line"></span><br><span class="line">        return mp_alloc_block(pool, size);</span><br><span class="line">    &#125;</span><br><span class="line">    return mp_alloc_large(pool, size);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main(int argc, char *argv[]) &#123;</span><br><span class="line"></span><br><span class="line">    int size = 1 &lt;&lt; 12;</span><br><span class="line"></span><br><span class="line">    struct mp_pool_s *p = mp_create_pool(size);</span><br><span class="line"></span><br><span class="line">    int i = 0;</span><br><span class="line">    for (i = 0;i &lt; 10;i ++) &#123;</span><br><span class="line"></span><br><span class="line">        void *mp = mp_alloc(p, 512);</span><br><span class="line">//mp_free(mp);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //printf(&quot;mp_create_pool: %ld\n&quot;, p-&gt;max);</span><br><span class="line">    printf(&quot;mp_align(123, 32): %d, mp_align(17, 32): %d\n&quot;, mp_align(24, 32), mp_align(17, 32));</span><br><span class="line">    //printf(&quot;mp_align_ptr(p-&gt;current, 32): %lx, p-&gt;current: %lx, mp_align(p-&gt;large, 32): %lx, p-&gt;large: %lx\n&quot;, mp_align_ptr(p-&gt;current, 32), p-&gt;current, mp_align_ptr(p-&gt;large, 32), p-&gt;large);</span><br><span class="line"></span><br><span class="line">    int j = 0;</span><br><span class="line">    for (i = 0;i &lt; 5;i ++) &#123;</span><br><span class="line"></span><br><span class="line">        char *pp = mp_calloc(p, 32);</span><br><span class="line">        for (j = 0;j &lt; 32;j ++) &#123;</span><br><span class="line">            if (pp[j]) &#123;</span><br><span class="line">                printf(&quot;calloc wrong\n&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">            printf(&quot;calloc success\n&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //printf(&quot;mp_reset_pool\n&quot;);</span><br><span class="line"></span><br><span class="line">    for (i = 0;i &lt; 5;i ++) &#123;</span><br><span class="line">        void *l = mp_alloc(p, 8192);</span><br><span class="line">        mp_free(p, l);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mp_reset_pool(p);</span><br><span class="line"></span><br><span class="line">    //printf(&quot;mp_destory_pool\n&quot;);</span><br><span class="line">    for (i = 0;i &lt; 58;i ++) &#123;</span><br><span class="line">        mp_alloc(p, 256);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mp_destory_pool(p);</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;img src=&quot;/2020/10/09/内存池/1.png&quot;&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span cl
      
    
    </summary>
    
      <category term="基础" scheme="http://twh233.github.io/categories/%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="内存池" scheme="http://twh233.github.io/tags/%E5%86%85%E5%AD%98%E6%B1%A0/"/>
    
  </entry>
  
  <entry>
    <title>字符编码Unicode原理数据流压缩Zlib与Miniz的实现</title>
    <link href="http://twh233.github.io/2020/10/08/%E5%AD%97%E7%AC%A6%E7%BC%96%E7%A0%81Unicode%E5%8E%9F%E7%90%86%E6%95%B0%E6%8D%AE%E6%B5%81%E5%8E%8B%E7%BC%A9Zlib%E4%B8%8EMiniz%E7%9A%84%E5%AE%9E%E7%8E%B0/"/>
    <id>http://twh233.github.io/2020/10/08/字符编码Unicode原理数据流压缩Zlib与Miniz的实现/</id>
    <published>2020-10-08T06:31:46.000Z</published>
    <updated>2020-10-08T07:17:22.526Z</updated>
    
    <content type="html"><![CDATA[<p>字符Unicode其实是根据码表转化映射出图形。<br>根据码表找到位图文件显示出文字。</p><p>UTF-8 1-6字节<br>UTF-16 2或4字节<br>UTF-32 4字节  </p><p>通过前缀码，编译器可以知道是这个文件是按什么格式编码的。</p><p>Mysql的“uft8”不是真正的UTF-8，“utf8”只支持每个字符最多3个字节。</p><p>Mysql真正的UTF-8是”utf8mb4”。  </p><img src="/2020/10/08/字符编码Unicode原理数据流压缩Zlib与Miniz的实现/1.png">]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;字符Unicode其实是根据码表转化映射出图形。&lt;br&gt;根据码表找到位图文件显示出文字。&lt;/p&gt;
&lt;p&gt;UTF-8 1-6字节&lt;br&gt;UTF-16 2或4字节&lt;br&gt;UTF-32 4字节  &lt;/p&gt;
&lt;p&gt;通过前缀码，编译器可以知道是这个文件是按什么格式编码的。&lt;/p&gt;
&lt;
      
    
    </summary>
    
      <category term="基础" scheme="http://twh233.github.io/categories/%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="基础" scheme="http://twh233.github.io/tags/%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>Golang 系统监控</title>
    <link href="http://twh233.github.io/2020/10/07/Golang-%E7%B3%BB%E7%BB%9F%E7%9B%91%E6%8E%A7/"/>
    <id>http://twh233.github.io/2020/10/07/Golang-系统监控/</id>
    <published>2020-10-07T09:06:23.000Z</published>
    <updated>2020-10-07T09:07:06.729Z</updated>
    
    <content type="html"><![CDATA[<p>系统监控程序会定期的检查上次垃圾回收器什么时候执行的，如果发现已经有很长时间没有执行垃圾回收操作了，它就强制执行一次回收。  </p><p>它来定期扫描自由内存块，如果长时间不用，它就会建议操作系统把物理内存收回去。  </p><p>在函数头部插入一段汇编指令：<br>第一件事用来判断栈帧空间够不够用，不够用进行扩张<br>第二件事检查当前的G执行多长，如果系统调度发出抢占通知，立即中止G执行。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;系统监控程序会定期的检查上次垃圾回收器什么时候执行的，如果发现已经有很长时间没有执行垃圾回收操作了，它就强制执行一次回收。  &lt;/p&gt;
&lt;p&gt;它来定期扫描自由内存块，如果长时间不用，它就会建议操作系统把物理内存收回去。  &lt;/p&gt;
&lt;p&gt;在函数头部插入一段汇编指令：&lt;br&gt;
      
    
    </summary>
    
      <category term="基础" scheme="http://twh233.github.io/categories/%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="Golang" scheme="http://twh233.github.io/tags/Golang/"/>
    
  </entry>
  
  <entry>
    <title>Golang 并发</title>
    <link href="http://twh233.github.io/2020/10/07/Golang-%E5%B9%B6%E5%8F%91/"/>
    <id>http://twh233.github.io/2020/10/07/Golang-并发/</id>
    <published>2020-10-07T08:57:14.000Z</published>
    <updated>2020-10-07T09:06:57.960Z</updated>
    
    <content type="html"><![CDATA[<h2 id="PMG模型"><a href="#PMG模型" class="headerlink" title="PMG模型"></a>PMG模型</h2><img src="/2020/10/07/Golang-并发/1.png"><p>第一本地队列超过 256 个任务转移一半任务到全局队列，第二本地队列执行 60 个任务则到全局队列执行一个确保公平性。  </p><h2 id="runnext"><a href="#runnext" class="headerlink" title="runnext"></a>runnext</h2><p>G对象有runnext属性，记录最后一个G对象。执行 runnext 优先，然后 runq 队列。</p><h2 id="栈内存"><a href="#栈内存" class="headerlink" title="栈内存"></a>栈内存</h2><p>M 的所有的状态都保存在 G 任务栈，优点是在任意时 M 都能上下文切换。</p><p>M 使用的栈保存在 G 栈上，切换时只需要把 M 使用的 SP 等寄存器保存到 G 的寄存器上，保存后 M 就可以上下文切换。</p><p>G 自带栈可以从 2KB 扩容到 1GB，那么怎么扩容呢？实际上重新分配两倍的内存，然后把数据拷贝进来，栈指针指向新的地址，原来的释放掉，称之为拷贝栈。收缩也一样，创建小一点的块，把数据拷贝进来，用它来替换原来的释放。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;PMG模型&quot;&gt;&lt;a href=&quot;#PMG模型&quot; class=&quot;headerlink&quot; title=&quot;PMG模型&quot;&gt;&lt;/a&gt;PMG模型&lt;/h2&gt;&lt;img src=&quot;/2020/10/07/Golang-并发/1.png&quot;&gt;
&lt;p&gt;第一本地队列超过 256 个任务转移
      
    
    </summary>
    
      <category term="基础" scheme="http://twh233.github.io/categories/%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="Golang" scheme="http://twh233.github.io/tags/Golang/"/>
    
  </entry>
  
  <entry>
    <title>垃圾回收</title>
    <link href="http://twh233.github.io/2020/10/07/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/"/>
    <id>http://twh233.github.io/2020/10/07/垃圾回收/</id>
    <published>2020-10-07T08:55:34.000Z</published>
    <updated>2020-10-07T08:56:17.106Z</updated>
    
    <content type="html"><![CDATA[<h2 id="引用计数"><a href="#引用计数" class="headerlink" title="引用计数"></a>引用计数</h2><p>引用计数实现方式非常简单，每个对象头部有一个计数器，引用对象时计数器加一，取消引用时计数器减一，等于零时释放内存。</p><p>缺点：<br>1.易内存泄漏<br>2.不支持循环引用 </p><h2 id="代龄"><a href="#代龄" class="headerlink" title="代龄"></a>代龄</h2><p>代龄机制是这样的，对象通常分成三级代龄 0、1、2。新创建的对象的代龄是 0，每级代龄都有阈值，当 0 级对象数量超过阈值就会启动垃圾回收，垃圾回收扫描所有 0 级代龄对象，扫描完对象是活着或者死着两种状态。理论来说在第一次回收活着对象在第二次回收活着几率很高，垃圾回收器把第一次扫描活着对象标记为 1 级代龄对象，下次扫描 0 级代龄对象不用扫描第一次扫描过的对象，减少扫描对象的数量。当 1 级代龄对象数量超过阈值便扫描 1 级代龄对象，如果 1 级代龄还活着说明这个对象生命周期更长，就标记为 2 级代龄对象。  </p><p>优点1：减少扫描对象数量<br>优点2：支持内存压缩  </p><h2 id="标记清理"><a href="#标记清理" class="headerlink" title="标记清理"></a>标记清理</h2><p>回收器启动把所有对象标记成白色。A引用B，B变成灰色。白色可以释放。下次扫描灰色。<br>B变成黑色，如果B引用C。C依然是灰色。不断递归，只剩黑色和白色。那么黑色的都是活着的白色的都是死的。</p><h2 id="并发清理"><a href="#并发清理" class="headerlink" title="并发清理"></a>并发清理</h2><p>回收白色对象的时候可以和用户逻辑并发。</p><h2 id="写屏障"><a href="#写屏障" class="headerlink" title="写屏障"></a>写屏障</h2><p>一旦进入垃圾回收状态时进行短暂 STW 暂停，打开标记位标记为正在执行垃圾回收。扫描当时状态。<br>在垃圾回收阶段重新引用另外新对象，这个屏障把这种行为重新过滤。</p><h2 id="信用授权"><a href="#信用授权" class="headerlink" title="信用授权"></a>信用授权</h2><p>回收的速度跟不上分配的速度垃圾回收器会把用户逻辑暂停，用户逻辑暂停后不会有新的对象出现。<br>黑白对象标记完的对象数量累计到公共账户信用值，如果小于等于零则调度切换为垃圾回收，切换后不停的增加信用值和检查公共账户信用值，尽早提前结束切换执行用户代码，保证用户代码和垃圾回收的并行。  </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;引用计数&quot;&gt;&lt;a href=&quot;#引用计数&quot; class=&quot;headerlink&quot; title=&quot;引用计数&quot;&gt;&lt;/a&gt;引用计数&lt;/h2&gt;&lt;p&gt;引用计数实现方式非常简单，每个对象头部有一个计数器，引用对象时计数器加一，取消引用时计数器减一，等于零时释放内存。&lt;/p&gt;

      
    
    </summary>
    
      <category term="基础" scheme="http://twh233.github.io/categories/%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="垃圾回收" scheme="http://twh233.github.io/tags/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/"/>
    
  </entry>
  
  <entry>
    <title>内存分配器</title>
    <link href="http://twh233.github.io/2020/10/07/%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E5%99%A8/"/>
    <id>http://twh233.github.io/2020/10/07/内存分配器/</id>
    <published>2020-10-07T08:54:21.000Z</published>
    <updated>2020-10-07T08:55:13.154Z</updated>
    
    <content type="html"><![CDATA[<p>为了避免程序频繁的向操作系统申请，占用更多的空间延长内存的使用时间。可以一次性申请<br>多一部分的内存重复使用。例如：对象池、连接池。并且一次性申请大块内存可以做到连续分<br>配，通过相邻的地址空间的合并减少碎片化。  </p><h3 id="虚拟地址空间如何使用"><a href="#虚拟地址空间如何使用" class="headerlink" title="虚拟地址空间如何使用"></a>虚拟地址空间如何使用</h3><p>每个进程有一个虚拟地址空间，内存分配在某段虚拟地址空间内就能保证是连续的。</p><p>1.让操作系统随机开始，保留一段地址空间，如果失败，加上或者减去偏移量重新选择。<br>2.如果连续的方式不行使用分段的方式。空间扩展尝试同一方向扩展，失败则换个相反<br>方向扩展，这样空间还是连续的。操作系统随机从两个方向扩展的方式称之为稀疏堆。<br>3.使用一个数组。数组存储内存指针指向自由块，自由块有各种状态，比如当前使用多<br>少内存、是否是空闲状态等，形成类似反查表的作用。自由块的内存起始地址减去初始<br>位置得到偏移量，偏移量按页大小对齐作为数组索引。这样的优点是只需检查数组就知<br>道内存分配的信息、检查相邻的两项的是否空闲可以合并成大块内存。通过反查表实现<br>碎片化问题。</p><h3 id="Go管理内存框架"><a href="#Go管理内存框架" class="headerlink" title="Go管理内存框架"></a>Go管理内存框架</h3><p>内存分配的完整流程首先检查 Cache 里有没有自由块，有的话直接返回；没有的话计算<br>向哪个 Central 申请，如果 Central 有则取回一批，如果没有，则向Heap申请大块自由<br>块切割，如果Heap没有多余的自由块，Heap向操作系统申请。Go语言在初始化时建立一个<br>静态表，通过静态表知道一次取多少个，这个数字是基于大量的统计得到的，有些语言根<br>据程序运行期动态调整这个数字。  </p><p>任何时候内存管理都会涉及两个核心问题。  </p><p>第一个快速分配，比如实现无锁操作或者减少锁。因为 Central 被很多Cache共享，操作<br>数据必须加锁处理，Heap 被很多 Central 共享，操作数据要加锁。</p><p>第二个尽可能在内存复用方面做到平衡。快速操作意味着用批处理代替单次处理实现性能<br>提升，但是批处理会浪费大量的资源。所以一来用批处理来实现快速分配操作的性能，一<br>来实现内存节约避免快速消耗，需要在中间找到平衡点。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;为了避免程序频繁的向操作系统申请，占用更多的空间延长内存的使用时间。可以一次性申请&lt;br&gt;多一部分的内存重复使用。例如：对象池、连接池。并且一次性申请大块内存可以做到连续分&lt;br&gt;配，通过相邻的地址空间的合并减少碎片化。  &lt;/p&gt;
&lt;h3 id=&quot;虚拟地址空间如何使用&quot;&gt;
      
    
    </summary>
    
      <category term="基础" scheme="http://twh233.github.io/categories/%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="内存" scheme="http://twh233.github.io/tags/%E5%86%85%E5%AD%98/"/>
    
  </entry>
  
  <entry>
    <title>线程池</title>
    <link href="http://twh233.github.io/2020/10/07/%E7%BA%BF%E7%A8%8B%E6%B1%A0/"/>
    <id>http://twh233.github.io/2020/10/07/线程池/</id>
    <published>2020-10-07T08:51:40.000Z</published>
    <updated>2020-10-07T08:54:47.166Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#include &lt;assert.h&gt;</span><br><span class="line">#include &lt;stdarg.h&gt;</span><br><span class="line"></span><br><span class="line">#include &lt;pthread.h&gt;</span><br><span class="line"></span><br><span class="line">#define LL_ADD(item, list) do &#123; \</span><br><span class="line">item-&gt;prev = NULL;\</span><br><span class="line">item-&gt;next = list;\</span><br><span class="line">list = item;\</span><br><span class="line">&#125; while(0)</span><br><span class="line"></span><br><span class="line">#define LL_REMOVE(item, list) do &#123;\</span><br><span class="line">if (item-&gt;prev != NULL) item-&gt;prev-&gt;next = item-&gt;next;\</span><br><span class="line">if (item-&gt;next != NULL) item-&gt;next-&gt;prev = item-&gt;prev;\</span><br><span class="line">if (list == item) list = item-&gt;next;\</span><br><span class="line">item-&gt;prev = item-&gt;next = NULL;\</span><br><span class="line">&#125; while(0)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//执行（线程ID，终止标识，池管理组件对象）</span><br><span class="line">typedef struct NWORKER &#123;</span><br><span class="line">pthread_t thread;</span><br><span class="line">int terminate;</span><br><span class="line">struct NWORKQUEUE *workqueue;</span><br><span class="line">struct NWORKER *prev;</span><br><span class="line">struct NWORKER *next;</span><br><span class="line">&#125; nWorker;</span><br><span class="line"></span><br><span class="line">//任务（任务回调函数，任务执行的参数）</span><br><span class="line">typedef struct NJOB &#123;</span><br><span class="line">void (*job_function)(struct NJOB *job);</span><br><span class="line">void *user_data;</span><br><span class="line">struct NJOB *prev;</span><br><span class="line">struct NJOB *next;</span><br><span class="line">&#125; nJob;</span><br><span class="line"></span><br><span class="line">//池管理组件（互斥锁，条件变量，执行队列，任务队列）</span><br><span class="line">typedef struct NWORKQUEUE &#123;</span><br><span class="line">struct NWORKER *workers;</span><br><span class="line">struct NJOB *waiting_jobs;</span><br><span class="line">pthread_mutex_t jobs_mtx;</span><br><span class="line">pthread_cond_t jobs_cond;</span><br><span class="line">&#125; nWorkQueue;</span><br><span class="line"></span><br><span class="line">typedef nWorkQueue nThreadPool;</span><br><span class="line"></span><br><span class="line">static void *ntyWorkerThread(void *ptr) &#123;</span><br><span class="line">nWorker *worker = (nWorker*)ptr;</span><br><span class="line"></span><br><span class="line">while (1) &#123;</span><br><span class="line">pthread_mutex_lock(&amp;worker-&gt;workqueue-&gt;jobs_mtx);</span><br><span class="line"></span><br><span class="line">while (worker-&gt;workqueue-&gt;waiting_jobs == NULL) &#123;</span><br><span class="line">if (worker-&gt;terminate) break;</span><br><span class="line">pthread_cond_wait(&amp;worker-&gt;workqueue-&gt;jobs_cond, &amp;worker-&gt;workqueue-&gt;jobs_mtx);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">if (worker-&gt;terminate) &#123;</span><br><span class="line">pthread_mutex_unlock(&amp;worker-&gt;workqueue-&gt;jobs_mtx);</span><br><span class="line">break;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">nJob *job = worker-&gt;workqueue-&gt;waiting_jobs;</span><br><span class="line">if (job != NULL) &#123;</span><br><span class="line">LL_REMOVE(job, worker-&gt;workqueue-&gt;waiting_jobs);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">pthread_mutex_unlock(&amp;worker-&gt;workqueue-&gt;jobs_mtx);</span><br><span class="line"></span><br><span class="line">if (job == NULL) continue;</span><br><span class="line"></span><br><span class="line">job-&gt;job_function(job);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">free(worker);</span><br><span class="line">pthread_exit(NULL);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int ntyThreadPoolCreate(nThreadPool *workqueue, int numWorkers) &#123;</span><br><span class="line"></span><br><span class="line">if (numWorkers &lt; 1) numWorkers = 1;</span><br><span class="line">memset(workqueue, 0, sizeof(nThreadPool));</span><br><span class="line"></span><br><span class="line">pthread_cond_t blank_cond = PTHREAD_COND_INITIALIZER;</span><br><span class="line">memcpy(&amp;workqueue-&gt;jobs_cond, &amp;blank_cond, sizeof(workqueue-&gt;jobs_cond));</span><br><span class="line"></span><br><span class="line">pthread_mutex_t blank_mutex = PTHREAD_MUTEX_INITIALIZER;</span><br><span class="line">memcpy(&amp;workqueue-&gt;jobs_mtx, &amp;blank_mutex, sizeof(workqueue-&gt;jobs_mtx));</span><br><span class="line"></span><br><span class="line">int i = 0;</span><br><span class="line">for (i = 0;i &lt; numWorkers;i ++) &#123;</span><br><span class="line">nWorker *worker = (nWorker*)malloc(sizeof(nWorker));</span><br><span class="line">if (worker == NULL) &#123;</span><br><span class="line">perror(&quot;malloc&quot;);</span><br><span class="line">return 1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">memset(worker, 0, sizeof(nWorker));</span><br><span class="line">worker-&gt;workqueue = workqueue;</span><br><span class="line"></span><br><span class="line">        //printf(&quot;pthread_create --&gt; %d\n&quot;, i);</span><br><span class="line">int ret = pthread_create(&amp;worker-&gt;thread, NULL, ntyWorkerThread, (void *)worker);</span><br><span class="line">if (ret) &#123;</span><br><span class="line"></span><br><span class="line">perror(&quot;pthread_create&quot;);</span><br><span class="line">free(worker);</span><br><span class="line"></span><br><span class="line">return 1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">LL_ADD(worker, worker-&gt;workqueue-&gt;workers);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">void ntyThreadPoolShutdown(nThreadPool *workqueue) &#123;</span><br><span class="line">nWorker *worker = NULL;</span><br><span class="line"></span><br><span class="line">for (worker = workqueue-&gt;workers;worker != NULL;worker = worker-&gt;next) &#123;</span><br><span class="line">worker-&gt;terminate = 1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">pthread_mutex_lock(&amp;workqueue-&gt;jobs_mtx);</span><br><span class="line"></span><br><span class="line">workqueue-&gt;workers = NULL;</span><br><span class="line">workqueue-&gt;waiting_jobs = NULL;</span><br><span class="line"></span><br><span class="line">pthread_cond_broadcast(&amp;workqueue-&gt;jobs_cond);</span><br><span class="line"></span><br><span class="line">pthread_mutex_unlock(&amp;workqueue-&gt;jobs_mtx);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void ntyThreadPoolQueue(nThreadPool *workqueue, nJob *job) &#123;</span><br><span class="line"></span><br><span class="line">pthread_mutex_lock(&amp;workqueue-&gt;jobs_mtx);</span><br><span class="line"></span><br><span class="line">LL_ADD(job, workqueue-&gt;waiting_jobs);</span><br><span class="line"></span><br><span class="line">pthread_cond_signal(&amp;workqueue-&gt;jobs_cond);</span><br><span class="line">pthread_mutex_unlock(&amp;workqueue-&gt;jobs_mtx);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#define KING_MAX_THREAD80</span><br><span class="line">#define KING_COUNTER_SIZE1000</span><br><span class="line"></span><br><span class="line">void king_counter(nJob *job) &#123;</span><br><span class="line"></span><br><span class="line">int index = *(int*)job-&gt;user_data;</span><br><span class="line"></span><br><span class="line">printf(&quot;index : %d, selfid : %lu\n&quot;, index, pthread_self());</span><br><span class="line"></span><br><span class="line">free(job-&gt;user_data);</span><br><span class="line">free(job);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main(int argc, char *argv[]) &#123;</span><br><span class="line"></span><br><span class="line">nThreadPool pool;</span><br><span class="line"></span><br><span class="line">ntyThreadPoolCreate(&amp;pool, KING_MAX_THREAD);</span><br><span class="line"></span><br><span class="line">int i = 0;</span><br><span class="line">for (i = 0;i &lt; KING_COUNTER_SIZE;i ++) &#123;</span><br><span class="line">nJob *job = (nJob*)malloc(sizeof(nJob));</span><br><span class="line">if (job == NULL) &#123;</span><br><span class="line">perror(&quot;malloc&quot;);</span><br><span class="line">exit(1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">job-&gt;job_function = king_counter;</span><br><span class="line">job-&gt;user_data = malloc(sizeof(int));</span><br><span class="line">*(int*)job-&gt;user_data = i;</span><br><span class="line"></span><br><span class="line">ntyThreadPoolQueue(&amp;pool, job);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">getchar();</span><br><span class="line">printf(&quot;\n&quot;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class
      
    
    </summary>
    
      <category term="基础" scheme="http://twh233.github.io/categories/%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="线程池" scheme="http://twh233.github.io/tags/%E7%BA%BF%E7%A8%8B%E6%B1%A0/"/>
    
  </entry>
  
  <entry>
    <title>无锁CAS无锁队列</title>
    <link href="http://twh233.github.io/2020/10/07/%E6%97%A0%E9%94%81CAS%E6%97%A0%E9%94%81%E9%98%9F%E5%88%97/"/>
    <id>http://twh233.github.io/2020/10/07/无锁CAS无锁队列/</id>
    <published>2020-10-07T08:50:23.000Z</published>
    <updated>2020-10-07T08:50:54.366Z</updated>
    
    <content type="html"><![CDATA[<pre><code>#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;pthread.h&gt;#include &lt;mutex&gt;#include &lt;time.h&gt;#include &lt;atomic&gt;#include &lt;list&gt;#include &lt;memory&gt;#define MAX_THREAD_NUM 1#define FOR_LOOP_COUNT 10000000static int counter = 0;static pthread_spinlock_t spinlock;static std::mutex s_mutex;static int s_count_push = 0;static int s_count_pop = 0;// using namespace lock_free;// 有锁队列，直接使用liststatic std::list&lt;int&gt; s_list;typedef void *(*thread_func_t)(void *argv);static int lxx_atomic_add(int *ptr, int increment){  int old_value = *ptr;  __asm__ volatile(&quot;lock; xadd %0, %1 \n\t&quot;                   : &quot;=r&quot;(old_value), &quot;=m&quot;(*ptr)                   : &quot;0&quot;(increment), &quot;m&quot;(*ptr)                   : &quot;cc&quot;, &quot;memory&quot;);  return *ptr;}template &lt;typename ElemType&gt;struct qnode // 链表节点{  struct qnode *_next;  ElemType _data;};template &lt;typename ElemType&gt;class Queue{private:  struct qnode&lt;ElemType&gt; *volatile _head = NULL;  // 随着pop后指向的位置是不一样的, head不是固定的  struct qnode&lt;ElemType&gt; *volatile _tail = NULL;public:  Queue()  {    _head = _tail = new qnode&lt;ElemType&gt;;    _head-&gt;_next = NULL;    _tail-&gt;_next = NULL;    printf(&quot;Queue _head:%p\n&quot;, _head);  }  void push(const ElemType &amp;e)  {    struct qnode&lt;ElemType&gt; *p = new qnode&lt;ElemType&gt;;    p-&gt;_data = e;    p-&gt;_next = NULL;    struct qnode&lt;ElemType&gt; *t = _tail; // 获取尾部    t-&gt;_next = p; // 插到尾部    _tail = p; // 更新尾部节点  }  void push2(const ElemType &amp;e)  {    struct qnode&lt;ElemType&gt; *p = new qnode&lt;ElemType&gt;;    // printf(&quot;push head:%p, p:%p\n&quot;, _head, p);    p-&gt;_next = NULL;    p-&gt;_data = e;    struct qnode&lt;ElemType&gt; *t = _tail;    struct qnode&lt;ElemType&gt; *old_t = _tail;    int count = 0;    do    {      while (t-&gt;_next != NULL) // 非空的时候要去更新 t-&gt;_next        t = t-&gt;_next;          // 找到最后的节点      if (count++ &gt;= 1)      {        printf(&quot;push count:%d, t-&gt;_next:%p\n&quot;, count, t-&gt;_next);      }      // 将null换为p即是插入的节点    } while (!__sync_bool_compare_and_swap(&amp;t-&gt;_next, NULL, p));    // 将最后的节点_tail更换为p节点    __sync_bool_compare_and_swap(&amp;_tail, old_t, p);  }  bool pop(ElemType &amp;e)  {    struct qnode&lt;ElemType&gt; *p = _head;         // 头结点    struct qnode&lt;ElemType&gt; *np = _head-&gt;_next; // 首元素节点    if (!np)    {      return false;    }    e = np-&gt;_data;    _head-&gt;_next = np-&gt;_next;    delete np;    return true;  }  bool pop2(ElemType &amp;e)  {    struct qnode&lt;ElemType&gt; *p = NULL;    struct qnode&lt;ElemType&gt; *np = NULL;    int count = 0;    do    {      p = _head; // 头节点，不真正存储数据      np = p-&gt;_next;      if (p-&gt;_next == NULL) // 首元节点为空，则返回      {        return false;      }      if (count++ &gt;= 1)      {        printf(&quot;pop count:%d, p-&gt;_next:%p\n&quot;, count, p-&gt;_next);      }      // 更新头结点位置    } while (!__sync_bool_compare_and_swap(&amp;_head, p, p-&gt;_next));    e = p-&gt;_next-&gt;_data;    // printf(&quot;pop p:%p\n&quot;, p);    delete p; // 因为我们已经将头部节点换成了p-&gt;_next, 所以可以释放掉    return true;  }  ~Queue()  {    struct qnode&lt;ElemType&gt; *volatile tmp;    while (_head)    {      tmp = _head-&gt;_next;      printf(&quot;_head:%p\n&quot;, _head);      delete _head;      _head = tmp;    }  }};void *mutex_thread_push(void *argv){  for (int i = 0; i &lt; FOR_LOOP_COUNT; i++)  {    s_mutex.lock();    s_count_push++;    s_list.push_back(i);    s_mutex.unlock();  }  return NULL;}void *mutex_thread_pop(void *argv){  while (true)  {    int value = 0;    s_mutex.lock();    if (s_list.size() &gt; 0)    {      value = s_list.front();      s_list.pop_front();      s_count_pop++;    }    s_mutex.unlock();    if (s_count_pop &gt;= FOR_LOOP_COUNT * MAX_THREAD_NUM)    {      printf(&quot;%s dequeue:%d\n&quot;, __FUNCTION__, value);      break;    }  }  printf(&quot;%s exit\n&quot;, __FUNCTION__);  return NULL;}static Queue&lt;int&gt; s_queue;void *queue_free_thread_push(void *argv){  for (int i = 0; i &lt; FOR_LOOP_COUNT; i++)  {    s_queue.push2(i);    lxx_atomic_add(&amp;s_count_push, 1);    // printf(&quot;s_count_push:%d\n&quot;,s_count_push);  }  return NULL;}void *queue_free_thread_pop(void *argv){  // for (int i = 0; i &lt; FOR_LOOP_COUNT*5; i++)  int last_value = 0;  static int s_pid_count = 0;  s_pid_count++;  int pid = s_pid_count;  while (true)  {    int value = 0;    if (s_queue.pop2(value))    {      last_value = value;      if (s_count_pop != value)      {        printf(&quot;pid:%d, -&gt; value:%d, expected:%d\n&quot;, pid, value, s_count_pop);      }      s_count_pop++;      // printf(&quot;pid:%d, -&gt; value:%d\n&quot;, pid, value);    }    else    {      // printf(&quot;pid:%d, null\n&quot;, pid);    }    if (s_count_pop &gt;= FOR_LOOP_COUNT * MAX_THREAD_NUM)    {      printf(&quot;%s dequeue:%d\n&quot;, __FUNCTION__, last_value);      break;    }  }  printf(&quot;%s exit\n&quot;, __FUNCTION__);  return NULL;}int test_queue(thread_func_t func_push, thread_func_t func_pop, char **argv){  clock_t start = clock();  pthread_t tid_push[MAX_THREAD_NUM] = {0};  for (int i = 0; i &lt; MAX_THREAD_NUM; i++)  {    int ret = pthread_create(&amp;tid_push[i], NULL, func_push, argv);    if (0 != ret)    {      printf(&quot;create thread failed\n&quot;);    }  }  pthread_t tid_pop[MAX_THREAD_NUM] = {0};  for (int i = 0; i &lt; MAX_THREAD_NUM; i++)  {    int ret = pthread_create(&amp;tid_pop[i], NULL, func_pop, argv);    if (0 != ret)    {      printf(&quot;create thread failed\n&quot;);    }  }  for (int i = 0; i &lt; MAX_THREAD_NUM; i++)  {    pthread_join(tid_push[i], NULL);  }  for (int i = 0; i &lt; MAX_THREAD_NUM; i++)  {    pthread_join(tid_pop[i], NULL);  }  clock_t end = clock();  printf(&quot;spend clock : %ld, push:%d, pop:%d\n&quot;, (end - start) / CLOCKS_PER_SEC,         s_count_push, s_count_pop);  return 0;}// 多尝试几次 g++ -o 4_test_queue 4_test_queue.cpp -lpthread -latomic -std=c++11int main(int argc, char **argv){  printf(&quot;THREAD_NUM:%d\n\n&quot;, MAX_THREAD_NUM);  for (int i = 0; i &lt; 100; i++)  {    s_count_push = 0;    s_count_pop = 0;    printf(&quot;\n\n---------&gt;i:%d\n\n&quot;, i);    printf(&quot;use mutex queue -----------&gt;\n&quot;);    test_queue(mutex_thread_push, mutex_thread_pop, NULL);    s_count_push = 0;    s_count_pop = 0;    printf(&quot;\nuse queue_free queue -----------&gt;\n&quot;);    test_queue(queue_free_thread_push, queue_free_thread_pop, NULL);  }  printf(&quot;finish\n&quot;);  return 0;}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;pre&gt;&lt;code&gt;#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;stdlib.h&amp;gt;
#include &amp;lt;pthread.h&amp;gt;
#include &amp;lt;mutex&amp;gt;
#include &amp;lt;time.h&amp;gt;
#inc
      
    
    </summary>
    
      <category term="基础" scheme="http://twh233.github.io/categories/%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="CAS" scheme="http://twh233.github.io/tags/CAS/"/>
    
  </entry>
  
  <entry>
    <title>进程协程线程</title>
    <link href="http://twh233.github.io/2020/09/27/%E8%BF%9B%E7%A8%8B%E5%8D%8F%E7%A8%8B%E7%BA%BF%E7%A8%8B/"/>
    <id>http://twh233.github.io/2020/09/27/进程协程线程/</id>
    <published>2020-09-27T14:34:51.000Z</published>
    <updated>2020-09-27T14:44:15.572Z</updated>
    
    <content type="html"><![CDATA[<p>进程是一种资源单位，操作系统按照进程来分配资源管理资源。线程是进程内的，专门用来执行。  </p><h2 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h2><p>线程我们严格意义上来说指的是任务加上任务执行所需的资源，称之为线程，如果线程只是执行单位没有任何资源，称之为任务，它是可复用的，线程本身有状态的，因为线程执行时有线程栈，所以任务加上任务执行所需的线程栈等资源称之为线程。</p><h3 id="系统线程与用户线程"><a href="#系统线程与用户线程" class="headerlink" title="系统线程与用户线程"></a>系统线程与用户线程</h3><img src="/2020/09/27/进程协程线程/1.png">  <p>系统线程指的是操作系统提供的的任务单元。用户线程指的是在用户空间实现的一些并发任务，跟操作系统没关系。</p><h3 id="线程池模型"><a href="#线程池模型" class="headerlink" title="线程池模型"></a>线程池模型</h3><p>使用池模型不再需要频繁的创建系统线程，用户态可以创建很多用来存储状态的执行单位。执行时把它绑定到一个系统线程上去执行，执行完把系统线程释放，系统线程把绑定状态删除放到池中，不需要杀掉系统线程，接下来另外一个执行单位重新的绑定到这个系统线程上去执行。</p><p>如下图所示：<br><img src="/2020/09/27/进程协程线程/2.png"></p><p>首先创建一定数量的系统线程专门用来执行的。其次在用户态空间创建一些对象专门用来保存执行时所需要的状态，包括线程栈。它不负责执行，它只是很普通的数据抽象容器。它执行时把它绑定到某个系统线程上，这个系统线程就具备了普通线程状态然后去执行，执行完把这个线程的状态全部剥离，这个线程就恢复成原始状态，接下来可以执行其他的任务。</p><p>实现用户态的执行和系统态的执行分离，避免反复系统调用所消耗的资源。</p><h2 id="协程"><a href="#协程" class="headerlink" title="协程"></a>协程</h2><p>为了充分利用时间片，利用异步机制，在用户态实现调度机制把阻塞的时间片执行其他的任务，当任务执行完成时，下次再执行时去检查返回的事件，把事件返回的结果返还给原先任务。</p><p>很明显，协程是串行不是并行，它的执行序是执行 A 任务，当 A 任务阻塞时唤醒 B 任务，B 任务执行结束检查 A 的结果是否有返回，不断的切换实现多任务并发。</p><h3 id="上下文切换对性能的影响"><a href="#上下文切换对性能的影响" class="headerlink" title="上下文切换对性能的影响"></a>上下文切换对性能的影响</h3><p>无论进程级别、线程级别、主动系统调用引发的上下文切换都会造成一定的性能损失。尽可能的减少系统调用实际上是减少上下文切换造成的性能损失。因为离 CPU 近的资源比如 L 级的 Cache，寄存器数据都要写回到主存，系统代码执行完要把主存数据读回来，相对 CPU 执行速度从主存操作数据非常慢。 </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;进程是一种资源单位，操作系统按照进程来分配资源管理资源。线程是进程内的，专门用来执行。  &lt;/p&gt;
&lt;h2 id=&quot;线程&quot;&gt;&lt;a href=&quot;#线程&quot; class=&quot;headerlink&quot; title=&quot;线程&quot;&gt;&lt;/a&gt;线程&lt;/h2&gt;&lt;p&gt;线程我们严格意义上来说指的是任务加
      
    
    </summary>
    
      <category term="操作系统" scheme="http://twh233.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
      <category term="操作系统" scheme="http://twh233.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>设计模式</title>
    <link href="http://twh233.github.io/2020/09/26/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    <id>http://twh233.github.io/2020/09/26/设计模式/</id>
    <published>2020-09-26T11:12:02.000Z</published>
    <updated>2020-10-25T03:10:57.655Z</updated>
    
    <content type="html"><![CDATA[<h2 id="策略模式"><a href="#策略模式" class="headerlink" title="策略模式"></a>策略模式</h2><p>策略模式定义了算法族，分别封装起来，让他们之间可以互相替换，此模式让算法的变化独立于使用算法的客户。</p><h2 id="装饰器模式"><a href="#装饰器模式" class="headerlink" title="装饰器模式"></a>装饰器模式</h2><p>装饰器模式中主要有两个角色：</p><p>1.装饰器  2.被装饰的对象</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">老王（ 被装饰的对象 ）：</span><br><span class="line">public interface Person &#123;</span><br><span class="line">    /**</span><br><span class="line">     * 计算累计消费</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    public Double cost();</span><br><span class="line">    public void show();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class LaoWang implements Person&#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public Double cost() &#123;</span><br><span class="line">        return 0.0; //赤果果的时候累计消费为0</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void show() &#123;</span><br><span class="line">        System.out.println(&quot;我是赤果果的老王&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">装饰器超类，和被装饰的对象实现同一个接口 Person ：</span><br><span class="line">public abstract class ClothesDecorator implements Person &#123;</span><br><span class="line">    //装饰器中要使用被装饰器的对象，构造方法中传入</span><br><span class="line">    protected Person person;</span><br><span class="line"></span><br><span class="line">    public ClothesDecorator(Person person)&#123;</span><br><span class="line">        this.person = person;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">具体的装饰，夹克和帽子：</span><br><span class="line">public class Jacket extends ClothesDecorator &#123;</span><br><span class="line"></span><br><span class="line">    public Jacket(Person person) &#123;</span><br><span class="line">        super(person);</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public void show() &#123;</span><br><span class="line">        person.show();</span><br><span class="line">        System.out.println(&quot;穿上夹克，累计消费&quot; + this.cost());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public Double cost() &#123;</span><br><span class="line">        return person.cost() + 100; //夹克100元</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">public class Hat extends ClothesDecorator &#123;</span><br><span class="line"></span><br><span class="line">    public Hat(Person person) &#123;</span><br><span class="line">        super(person);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void show() &#123;</span><br><span class="line">        //执行已有功能</span><br><span class="line">        person.show();</span><br><span class="line">        //此处是附加的功能</span><br><span class="line">        System.out.println(&quot;戴上帽子，累计消费&quot; + this.cost());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public Double cost() &#123;</span><br><span class="line">        return person.cost() + 50; //帽子50元</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">测试：</span><br><span class="line">Person laowang = new LaoWang();</span><br><span class="line">//穿上夹克</span><br><span class="line">laowang = new Jacket(laowang);</span><br><span class="line">//戴上帽子</span><br><span class="line">laowang = new Hat(laowang);</span><br><span class="line"></span><br><span class="line">laowang.show();</span><br><span class="line">System.out.println(&quot;买单，老王总共消费：&quot;+laowang.cost());</span><br></pre></td></tr></table></figure><h2 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h2><p>观察者模式定义了对象之间的一对多依赖，这样一来，当一个对象改变状态时，它的所有依赖者都会收到通知并自动更新。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">观察者（客户）:</span><br><span class="line">public abstract class Customer &#123;</span><br><span class="line">    public abstract void update();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class CustomerA extends Customer &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void update() &#123;</span><br><span class="line">        System.out.println(&quot;我是客户A,我收到报纸啦&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class CustomerB extends Customer &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void update() &#123;</span><br><span class="line">        System.out.println(&quot;我是客户B,我收到报纸啦&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">被观察者（报社）：</span><br><span class="line">public class NewsOffice &#123;</span><br><span class="line"></span><br><span class="line">    private List&lt;Customer&gt; customers = new ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    public void addCustomer(Customer customer)&#123;</span><br><span class="line">        this.customers.add(customer);</span><br><span class="line">    &#125;</span><br><span class="line">    //模拟报纸来了</span><br><span class="line">    public void newspaperCome()&#123;</span><br><span class="line">        this.notifyAllObservers();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void notifyAllObservers()&#123;</span><br><span class="line">        for (Customer customer : customers)&#123;</span><br><span class="line">            customer.update();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">测试：</span><br><span class="line">NewsOffice office= new NewsOffice();</span><br><span class="line"></span><br><span class="line">Customer customerA = new CustomerA();</span><br><span class="line">Customer customerB = new CustomerB();</span><br><span class="line">//客户A订阅报纸</span><br><span class="line">office.addCustomer(customerA);</span><br><span class="line">//客户B订阅报纸</span><br><span class="line">office.addCustomer(customerB);</span><br><span class="line">//报纸来了</span><br><span class="line">office.newspaperCome();</span><br></pre></td></tr></table></figure><h2 id="适配器模式"><a href="#适配器模式" class="headerlink" title="适配器模式"></a>适配器模式</h2><p>适配器适合用于解决新旧系统（ 或新旧接口 ）之间的兼容问题，而不建议在一开始就直接使用。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">定义接口：</span><br><span class="line">public interface MusicPlayer &#123;</span><br><span class="line">    /**</span><br><span class="line">     * 播放音乐</span><br><span class="line">     * @param type 音乐格式</span><br><span class="line">     * @param filename 文件</span><br><span class="line">     */</span><br><span class="line">    public void play(String type, String filename);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">现成的库：</span><br><span class="line">public class ExistPlayer &#123;</span><br><span class="line"></span><br><span class="line">    public void playMp3(String filename)&#123;</span><br><span class="line">        System.out.println(&quot;play mp3 : &quot;+filename);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void playWma(String filename)&#123;</span><br><span class="line">        System.out.println(&quot;play wma : &quot;+filename);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public class PlayerAdapter implements MusicPlayer</span><br><span class="line">&#123;</span><br><span class="line">    //在适配器中使用旧接口</span><br><span class="line">    private ExistPlayer player;</span><br><span class="line"></span><br><span class="line">    public PlayerAdapter()&#123;</span><br><span class="line">        player = new ExistPlayer();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void play(String type, String filename) &#123;</span><br><span class="line">        if(type == &quot;mp3&quot;)&#123;</span><br><span class="line">            player.playMp3(filename);</span><br><span class="line">        &#125;else if(type == &quot;wma&quot;)&#123;</span><br><span class="line">            player.playWma(filename);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">测试：</span><br><span class="line"> MusicPlayer player = new PlayerAdapter();</span><br><span class="line"> player.play(&quot;mp3&quot;,&quot;xxx.mp3&quot;);</span><br><span class="line"> player.play(&quot;mp4&quot;,&quot;xxx.mp4&quot;);</span><br></pre></td></tr></table></figure><h2 id="单例模式与工厂模式"><a href="#单例模式与工厂模式" class="headerlink" title="单例模式与工厂模式"></a>单例模式与工厂模式</h2><h3 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h3><p>懒汉式：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public class SingleObject &#123;</span><br><span class="line"></span><br><span class="line">    private static SingleObject instance;</span><br><span class="line"></span><br><span class="line">    private SingleObject()&#123;&#125;</span><br><span class="line"></span><br><span class="line">    public static SingleObject getInstance()&#123;</span><br><span class="line">        if(instance == null)&#123;</span><br><span class="line">            instance = new SingleObject();</span><br><span class="line">        &#125;</span><br><span class="line">        return instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>解决线程安全问题：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public class SingleObject &#123;</span><br><span class="line"></span><br><span class="line">    private static SingleObject instance;</span><br><span class="line"></span><br><span class="line">    private SingleObject()&#123;&#125;</span><br><span class="line"></span><br><span class="line">    public static synchronized SingleObject getInstance()&#123;</span><br><span class="line">        if(instance == null)&#123;</span><br><span class="line">            instance = new SingleObject();</span><br><span class="line">        &#125;</span><br><span class="line">        return instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>Not Lazy Loading：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public class SingleObject &#123;</span><br><span class="line"></span><br><span class="line">    private static SingleObject instance = new SingleObject();</span><br><span class="line"></span><br><span class="line">    private SingleObject()&#123;&#125;</span><br><span class="line"></span><br><span class="line">    public static  SingleObject getInstance()&#123;</span><br><span class="line">        return instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h3><p>简单工厂模式<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public class Factory &#123;</span><br><span class="line"></span><br><span class="line">    public Girl createGirl(String whatYouLike)&#123;</span><br><span class="line"></span><br><span class="line">        Girl girl = null;</span><br><span class="line"></span><br><span class="line">        if(whatYouLike == &quot;fat&quot;)&#123;</span><br><span class="line">            girl = new FatGirl();</span><br><span class="line">        &#125;else if(whatYouLike == &quot;thin&quot;)&#123;</span><br><span class="line">            girl = new ThinGirl();</span><br><span class="line">        &#125;</span><br><span class="line">        return girl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">测试:</span><br><span class="line">Girl girl = (new GirlFactory()).createGirl(&quot;fat&quot;);</span><br></pre></td></tr></table></figure><p>工厂提供者<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public class GirlStore &#123;</span><br><span class="line"></span><br><span class="line">    GirlFactory factory;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 可以动态选择工厂</span><br><span class="line">     * @param factory</span><br><span class="line">     */</span><br><span class="line">    public GirlStore(GirlFactory factory)&#123;</span><br><span class="line">        this.factory = factory;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Girl createGirl(String whatYouLike)&#123;</span><br><span class="line">        return factory.createGirl(whatYouLike);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">测试：</span><br><span class="line">GirlStore store = new GirlStore(new GirlFactory());</span><br><span class="line">store.createGirl(&quot;thin&quot;);</span><br></pre></td></tr></table></figure><p>抽象工厂模式</p><p>某某程序猿现在不满足于选择 Girl 的胖瘦，他的口味有点特殊，喜欢美国产的长发姑娘，遵循开闭原则，我们需要使用抽象工厂</p><p>抽象工厂：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public abstract class AbstractGirlFactory &#123;</span><br><span class="line">    /**</span><br><span class="line">     *</span><br><span class="line">     * @param whatYouLike 高矮胖瘦等类型</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    public abstract Girl createGirl(String whatYouLike);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>美国工厂：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public class AmericanGirlFactory extends AbstractGirlFactory&#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public Girl createGirl(String whatYouLike) &#123;</span><br><span class="line">        Girl girl = null;</span><br><span class="line"></span><br><span class="line">        if(whatYouLike == &quot;fat&quot;)&#123;</span><br><span class="line">            girl = new FatGirl();</span><br><span class="line">        &#125;else if(whatYouLike == &quot;thin&quot;)&#123;</span><br><span class="line">            girl = new ThinGirl();</span><br><span class="line">        &#125;</span><br><span class="line">        return girl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>中国工厂：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public class ChineseGirlFactory extends AbstractGirlFactory&#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public Girl createGirl(String whatYouLike) &#123;</span><br><span class="line">        Girl girl = null;</span><br><span class="line">        if(whatYouLike.equals(&quot;longhair&quot;))&#123;</span><br><span class="line">            //girl = new LongHairGirl();</span><br><span class="line">        &#125;</span><br><span class="line">        return girl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>工厂提供者：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public class GirlStore &#123;</span><br><span class="line"></span><br><span class="line">    AbstractGirlFactory factory;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 可以动态选择工厂</span><br><span class="line">     * @param factory</span><br><span class="line">     */</span><br><span class="line">    public GirlStore(AbstractGirlFactory factory)&#123;</span><br><span class="line">        this.factory = factory;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Girl createGirl(String whatYouLike)&#123;</span><br><span class="line">        return factory.createGirl(whatYouLike);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //也可以返回工厂，让客户端自己去createGirl()</span><br><span class="line">    //public abstract AbstractGirlFactory createFactory(String country);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>客户端调用：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">GirlStore store = new GirlStore(new AmericanGirlFactory());</span><br><span class="line">Girl girl = store.createGirl(&quot;longhair&quot;);</span><br></pre></td></tr></table></figure></p><h2 id="外观模式"><a href="#外观模式" class="headerlink" title="外观模式"></a>外观模式</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">//CPU</span><br><span class="line">public class CPU &#123;</span><br><span class="line">    public void start()&#123;</span><br><span class="line">        System.out.println(&quot;启动CPU&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">//硬盘</span><br><span class="line">public class Disk &#123;</span><br><span class="line">    public void start()&#123;</span><br><span class="line">        System.out.println(&quot;启动硬盘&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">//内存</span><br><span class="line">public class Memory &#123;</span><br><span class="line">    public void start()&#123;</span><br><span class="line">        System.out.println(&quot;启动内存&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">//开机键</span><br><span class="line">public class StartBtn &#123;</span><br><span class="line"></span><br><span class="line">    public void start()&#123;</span><br><span class="line">        new CPU().start();</span><br><span class="line">        new Disk().start();</span><br><span class="line">        new Memory().start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">new StartBtn().start();</span><br></pre></td></tr></table></figure><h2 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">public class LazyLoadList&lt;E&gt; implements List &#123;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 关联外键</span><br><span class="line">     */</span><br><span class="line">    private Integer key;</span><br><span class="line"></span><br><span class="line">    private boolean hasSelect = false;</span><br><span class="line"></span><br><span class="line">    public LazyLoadList(Integer key)&#123;</span><br><span class="line">        this.key = key;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private List list = new ArrayList();</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 真正查询数据库</span><br><span class="line">     */</span><br><span class="line">    private void doSelect()&#123;</span><br><span class="line">        //已查询过不用再查询</span><br><span class="line">        if(hasSelect) return;</span><br><span class="line"></span><br><span class="line">        System.out.println(&quot;开始查询&quot;);</span><br><span class="line">        String sql = &quot; select * from address where user_id = &quot; + this.key;</span><br><span class="line"></span><br><span class="line">        // sql查询</span><br><span class="line"></span><br><span class="line">        //使用反射，注解等机制组装查询结果，此处模拟一下即可</span><br><span class="line">        list.add(new Address(&quot;地址1&quot;));</span><br><span class="line">        list.add(new Address(&quot;地址2&quot;));</span><br><span class="line"></span><br><span class="line">        hasSelect = true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public int size() &#123;</span><br><span class="line">        this.doSelect();</span><br><span class="line">        return list.size();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public Object get(int index) &#123;</span><br><span class="line">        this.doSelect();</span><br><span class="line">        return list.get(index);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="责任链模式"><a href="#责任链模式" class="headerlink" title="责任链模式"></a>责任链模式</h2><p>论坛用户发表帖子，但是常常会有用户发一些不良的信息，如广告信息、涉黄信息、涉及政治的敏感词等。这时我们就可以使用责任链模式来过滤用户发表的信息。</p><p>父类：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 帖子处理器</span><br><span class="line"> */</span><br><span class="line">public abstract class PostHandler &#123;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 后继者</span><br><span class="line">     */</span><br><span class="line">    protected PostHandler successor;</span><br><span class="line"></span><br><span class="line">    public void setSuccessor(PostHandler handler)&#123;</span><br><span class="line">        this.successor = handler;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public abstract void handlerRequest(Post post);</span><br><span class="line"></span><br><span class="line">    protected final void next(Post post)&#123;</span><br><span class="line">        if(this.successor != null)&#123;</span><br><span class="line">            this.successor.handlerRequest(post);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 广告处理器</span><br><span class="line"> */</span><br><span class="line">public class AdHandler extends PostHandler &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void handlerRequest(Post post) &#123;</span><br><span class="line">        //屏蔽广告内容</span><br><span class="line">        String content = post.getContent();</span><br><span class="line">        //.....</span><br><span class="line">        content = content.replace(&quot;广告&quot;,&quot;**&quot;);</span><br><span class="line">        post.setContent(content);</span><br><span class="line"></span><br><span class="line">        System.out.println(&quot;过滤广告...&quot;);</span><br><span class="line">        //传递给下一个处理器</span><br><span class="line">        next(post);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 涉黄处理器</span><br><span class="line"> */</span><br><span class="line">public class YellowHandler extends PostHandler &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void handlerRequest(Post post) &#123;</span><br><span class="line">        //屏蔽涉黄内容</span><br><span class="line">        String content = post.getContent();</span><br><span class="line">        //.....</span><br><span class="line">        content = content.replace(&quot;涉黄&quot;,&quot;**&quot;);</span><br><span class="line">        post.setContent(content);</span><br><span class="line"></span><br><span class="line">        System.out.println(&quot;过滤涉黄内容...&quot;);</span><br><span class="line">        //传递给下一个处理器</span><br><span class="line">        next(post);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">//创建责任对象</span><br><span class="line">PostHandler adHandler = new AdHandler();</span><br><span class="line">PostHandler yellowHandler = new YellowHandler();</span><br><span class="line">PostHandler swHandler = new SensitiveWordsHandler();</span><br><span class="line"></span><br><span class="line">//形成责任链</span><br><span class="line">yellowHandler.setSuccessor(swHandler);</span><br><span class="line">adHandler.setSuccessor(yellowHandler);</span><br><span class="line"></span><br><span class="line">Post post = new Post();</span><br><span class="line">post.setContent(&quot;我是正常内容，我是广告，我是涉黄，我是敏感词，我是正常内容&quot;);</span><br><span class="line"></span><br><span class="line">System.out.println(&quot;过滤前的内容为：&quot;+post.getContent());</span><br><span class="line"></span><br><span class="line">post = adHandler.handlerRequest(post);</span><br><span class="line"></span><br><span class="line">System.out.println(&quot;过滤后的内容为：&quot;+post.getContent());</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;策略模式&quot;&gt;&lt;a href=&quot;#策略模式&quot; class=&quot;headerlink&quot; title=&quot;策略模式&quot;&gt;&lt;/a&gt;策略模式&lt;/h2&gt;&lt;p&gt;策略模式定义了算法族，分别封装起来，让他们之间可以互相替换，此模式让算法的变化独立于使用算法的客户。&lt;/p&gt;

&lt;h2 id
      
    
    </summary>
    
      <category term="设计模式" scheme="http://twh233.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="设计模式" scheme="http://twh233.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>http</title>
    <link href="http://twh233.github.io/2020/09/26/http/"/>
    <id>http://twh233.github.io/2020/09/26/http/</id>
    <published>2020-09-26T09:05:33.000Z</published>
    <updated>2020-09-26T11:11:20.807Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>HTTP 协议，即超文本传输协议(Hypertext transfer protocol)。是一种详细规定了浏览器和<br>万维网(WWW = World Wide Web)服务器之间互相通信的规则，通过因特网传送万维网文档<br>的数据传送协议，可以传输文本，图片，视频等。  </p><img src="/2020/09/26/http/1.png"><p>简单快速：协议简单，通信速度快；<br>灵活：HTTP 允许传输任意类型的数据对象。正在传输的类型由 Content-Type 加以标记；<br>无状态：：HTTP 协议是无状态协议。无状态是指协议对于事务处理没有记忆能力。缺少状<br>态意味着如果后续处理需要前面的信息，则它必须重传，这样可能导致每次连接传送的数据<br>量增大。另一方面，在服务器不需要先前信息时它的应答就较快。</p><h2 id="http工作原理"><a href="#http工作原理" class="headerlink" title="http工作原理"></a>http工作原理</h2><p>以下是 HTTP 请求/响应的步骤：<br>1、客户端连接到 Web 服务器<br>一个 HTTP 客户端，通常是浏览器，与 Web 服务器的 HTTP 端口（默认为 80）建立一个 TCP<br>套接字连接。例如，<a href="http://www.0voice.com。" target="_blank" rel="noopener">http://www.0voice.com。</a><br>2、发送 HTTP 请求<br>通过 TCP 套接字，客户端向 Web 服务器发送一个文本的请求报文，一个请求报文由请求行、<br>请求头部、空行和请求数据 4 部分组成。<br>3、服务器接受请求并返回 HTTP 响应<br>Web 服务器解析请求，定位请求资源。服务器将资源复本写到 TCP 套接字，由客户端读取。<br>一个响应由状态行、响应头部、空行和响应数据 4 部分组成。<br>4、释放连接 TCP 连接<br>若 connection 模式为 close，则服务器主动关闭 TCP 连接，客户端被动关闭连接，释放 TCP<br>连接;若 connection 模式为 keepalive，则该连接会保持一段时间，在该时间内可以继续接收<br>请求;<br>5、客户端浏览器解析 HTML 内容<br>客户端浏览器首先解析状态行，查看表明请求是否成功的状态代码。然后解析每一个响应头，<br>响应头告知以下为若干字节的 HTML 文档和文档的字符集。客户端浏览器读取响应数据<br>HTML，根据 HTML 的语法对其进行格式化，并在浏览器窗口中显示。  </p><h2 id="http请求方法"><a href="#http请求方法" class="headerlink" title="http请求方法"></a>http请求方法</h2><p>根据 HTTP 标准，HTTP 请求可以使用多种请求方法。<br>HTTP1.0 定义了三种请求方法: GET、POST 和 HEAD 方法。<br>HTTP1.1 新增了六种请求方法: OPTIONS、PUT、PATCH、DELETE、TRACE 和 CONNECT 方法。  </p><p>1 GET 请求指定的页面信息，并返回实体主体。<br>2 HEAD 类似于 GET 请求，只不过返回的响应中没有具体的内容，用于获取<br>报头<br>3 POST 向指定资源提交数据进行处理请求（例如提交表单或者上传文件）。<br>数据被包含在请求体中。POST 请求可能会导致新的资源的建立和/<br>或已有资源的修改。<br>4 PUT 从客户端向服务器传送的数据取代指定的文档的内容。<br>5 DELETE 请求服务器删除指定的页面。<br>6 CONNECT HTTP/1.1 协议中预留给能够将连接改为管道方式的代理服务器。<br>7 OPTIONS 允许客户端查看服务器的性能。<br>8 TRACE 回显服务器收到的请求，主要用于测试或诊断。<br>9 PATCH 是对 PUT 方法的补充，用来对已知资源进行局部更新 。  </p><h2 id="GET和POST区别"><a href="#GET和POST区别" class="headerlink" title="GET和POST区别"></a>GET和POST区别</h2><p>1、GET 提交的数据会放在 URL 之后，以?分割 URL 和传输数据，参数之间以&amp;相连，<br>如<a href="http://localhost:8600/user?name=test1&amp;id=123456" target="_blank" rel="noopener">http://localhost:8600/user?name=test1&amp;id=123456</a>. POST 方法是把提交的数据放在 HTTP<br>包的 Body 中。<br>2、GET 提交的数据大小有限制（因为浏览器对 URL 的长度有限制），而 POST 方法提交的<br>数据没有限制。<br>3、GET 方式需要使用 Request.QueryString 来取得变量的值，而 POST 方式通过 Request.Form<br>来获取变量的值。<br>4、GET 方式提交数据，会带来安全问题，比如一个登录页面，通过 GET 方式提交数据时，<br>用户名和密码将出现在 URL 上，如果页面可以被缓存或者其他人可以访问这台机器，就可<br>以从历史记录获得该用户的账号和密码。</p><h2 id="http响应头信息"><a href="#http响应头信息" class="headerlink" title="http响应头信息"></a>http响应头信息</h2><img src="/2020/09/26/http/2.png"><img src="/2020/09/26/http/3.png"><img src="/2020/09/26/http/4.png"><h2 id="http状态码"><a href="#http状态码" class="headerlink" title="http状态码"></a>http状态码</h2><p>状态代码有三位数字组成，第一个数字定义了响应的类别，共分五种类别:<br>1xx：指示信息–表示请求已接收，继续处理<br>2xx：成功–表示请求已被成功接收、理解、接受<br>3xx：重定向–要完成请求必须进行更进一步的操作<br>4xx：客户端错误–请求有语法错误或请求无法实现<br>5xx：服务器端错误–服务器未能实现合法的请求  </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h2&gt;&lt;p&gt;HTTP 协议，即超文本传输协议(Hypertext transfer protocol)。是一种详细规定了浏览器和&lt;br&gt;万维网(WWW 
      
    
    </summary>
    
      <category term="http" scheme="http://twh233.github.io/categories/http/"/>
    
    
      <category term="http" scheme="http://twh233.github.io/tags/http/"/>
    
  </entry>
  
  <entry>
    <title>nginx</title>
    <link href="http://twh233.github.io/2020/09/24/nginx/"/>
    <id>http://twh233.github.io/2020/09/24/nginx/</id>
    <published>2020-09-24T15:20:20.000Z</published>
    <updated>2020-09-24T15:25:23.672Z</updated>
    
    <content type="html"><![CDATA[<p>负载均衡可以在多个层上去做，nginx只是在应用层上面的负载均衡。</p><h2 id="初识"><a href="#初识" class="headerlink" title="初识"></a>初识</h2><p>从配置入手</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">worker_processes 4; ##进程数</span><br><span class="line"></span><br><span class="line">events &#123;</span><br><span class="line">worker_connections 1024;  #连接数</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">http &#123;</span><br><span class="line"></span><br><span class="line">upstream backend &#123; #负载均衡</span><br><span class="line">server 192.168.142.128 weight=2;</span><br><span class="line">server 192.168.142.129 weight=1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">server &#123;</span><br><span class="line">listen 8888;</span><br><span class="line">server_name localhost;</span><br><span class="line"></span><br><span class="line">client_max_body_size 100m; #客户端最大包体</span><br><span class="line"></span><br><span class="line">location / &#123;</span><br><span class="line">#root /usr/local/nginx/html/;</span><br><span class="line">#proxy_pass http://192.168.142.128;</span><br><span class="line">proxy_pass http://backend;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">location /images/ &#123;</span><br><span class="line">root /usr/local/nginx/; #静态资源映射</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">location ~ \.(mp3|mp4) &#123;</span><br><span class="line">root /usr/local/nginx/media/;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">server &#123;</span><br><span class="line">listen 9000;</span><br><span class="line"></span><br><span class="line">location ~ \.cgi &#123;</span><br><span class="line">fastcgi_pass 127.0.0.1:9001;</span><br><span class="line">fastcgi_index index.cgi;</span><br><span class="line">fastcgi_param SCRIPT_FILENAME cgi$fastcgi_script_name;</span><br><span class="line">include ../conf/fastcgi_params;</span><br><span class="line">&#125;</span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>cgi应用于在线编程工具，通过nginx映射到cgi端口，实际上并没有进入Server服务器，只是在cgi进程做的处理。<br>fastcgi用进程池去处理。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;负载均衡可以在多个层上去做，nginx只是在应用层上面的负载均衡。&lt;/p&gt;
&lt;h2 id=&quot;初识&quot;&gt;&lt;a href=&quot;#初识&quot; class=&quot;headerlink&quot; title=&quot;初识&quot;&gt;&lt;/a&gt;初识&lt;/h2&gt;&lt;p&gt;从配置入手&lt;/p&gt;
&lt;figure class=&quot;high
      
    
    </summary>
    
      <category term="nginx" scheme="http://twh233.github.io/categories/nginx/"/>
    
    
      <category term="nginx" scheme="http://twh233.github.io/tags/nginx/"/>
    
  </entry>
  
  <entry>
    <title>mysql</title>
    <link href="http://twh233.github.io/2020/09/22/mysql/"/>
    <id>http://twh233.github.io/2020/09/22/mysql/</id>
    <published>2020-09-22T12:57:48.000Z</published>
    <updated>2020-09-23T15:44:39.610Z</updated>
    
    <content type="html"><![CDATA[<h2 id="数值类型"><a href="#数值类型" class="headerlink" title="数值类型"></a>数值类型</h2><img src="/2020/09/22/mysql/2.png"><h2 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h2><h3 id="特征"><a href="#特征" class="headerlink" title="特征"></a>特征</h3><p>事务四大特征：<br>原子性（Atomicity，或称不可分割性）、<br>一致性（Consistency）、<br>隔离性（Isolation，又称独立性）、<br>持久性（Durability）。<br>一致性：数据库在操作前和操作后，完整性不被破坏。<br>隔离性：多个事务可以同时执行，防止多个事务并发执行引起交叉执行数据不一致。<br>持久性：事务结束后，对数据的修改是永久的。</p><h3 id="隔离级别"><a href="#隔离级别" class="headerlink" title="隔离级别"></a>隔离级别</h3><p>（1）读未提交：read uncommitted（2）读已提交：read committed<br>（3）可重复读：repeatable read（4）串行化：serializable  </p><img src="/2020/09/22/mysql/1.png"><h3 id="undolog"><a href="#undolog" class="headerlink" title="undolog"></a>undolog</h3><p>每一个事务都有undolog，事务开启时一个临时表存事务的操作，这个临时表就是undolog，一旦有错误就X掉这次事务。</p><h2 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h2><p>四条从效果上第一条影响最大，后面越来越小。<br>① SQL语句及索引的优化 ② 数据库表结构的优化<br>③ 系统配置的优化<br>④ 硬件的优化</p><h2 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h2><p>表级锁<br>行级锁<br>页级锁  </p><h2 id="引擎"><a href="#引擎" class="headerlink" title="引擎"></a>引擎</h2><p>Myisam(表级锁) Innodb(行级锁)<br>1.为什么Myisam快？<br>因为Myisam B+树存的是引用，加载到内存快。 等Innodb加载完，Myisam都查完了<br>2.为什么Innodb不支持全文索引？<br>数据直接在叶子结点上，如果要全文索引，相当于复制了一份数据库，浪费空间  </p><h2 id="binlog"><a href="#binlog" class="headerlink" title="binlog"></a>binlog</h2><img src="/2020/09/22/mysql/3.png"><p>binlog实际是除了select以外所有操作数据库动作的记录，方便恢复数据库。master主动推送到slave结点的relay log，从结点io线程去读relay log然后在sql线程去更新数据库。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;数值类型&quot;&gt;&lt;a href=&quot;#数值类型&quot; class=&quot;headerlink&quot; title=&quot;数值类型&quot;&gt;&lt;/a&gt;数值类型&lt;/h2&gt;&lt;img src=&quot;/2020/09/22/mysql/2.png&quot;&gt;
&lt;h2 id=&quot;事务&quot;&gt;&lt;a href=&quot;#事务&quot; cla
      
    
    </summary>
    
      <category term="mysql" scheme="http://twh233.github.io/categories/mysql/"/>
    
    
      <category term="mysql" scheme="http://twh233.github.io/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>redis补充</title>
    <link href="http://twh233.github.io/2020/09/20/redis%E8%A1%A5%E5%85%85/"/>
    <id>http://twh233.github.io/2020/09/20/redis补充/</id>
    <published>2020-09-20T12:04:18.000Z</published>
    <updated>2020-09-26T08:39:49.879Z</updated>
    
    <content type="html"><![CDATA[<h2 id="扩容与缩容"><a href="#扩容与缩容" class="headerlink" title="扩容与缩容"></a>扩容与缩容</h2><p>扩容<br>当used &gt; size 的时候扩容，当进行持久化aof,rdb,script(lua事务) block的时候，如果used &gt; 5size 翻倍扩容<br>缩容<br>当used &lt; size * 0.1的时候缩容<br>扩容和缩容导致rehash<br>scan<br>遇到扩充时</p><h2 id="io多线程"><a href="#io多线程" class="headerlink" title="io多线程"></a>io多线程</h2><img src="/2020/09/20/redis补充/1.png"> <h2 id="zset"><a href="#zset" class="headerlink" title="zset"></a>zset</h2><p>当数据量少的时候用压缩列表<br>当数据量大于128用跳表实现</p><h2 id="redis与mongo的区别"><a href="#redis与mongo的区别" class="headerlink" title="redis与mongo的区别"></a>redis与mongo的区别</h2><img src="/2020/09/20/redis补充/2.png"><h2 id="协议"><a href="#协议" class="headerlink" title="协议"></a>协议</h2><img src="/2020/09/20/redis补充/3.png"><h2 id="C语言使用Redis"><a href="#C语言使用Redis" class="headerlink" title="C语言使用Redis"></a>C语言使用Redis</h2><h3 id="编译hiredis"><a href="#编译hiredis" class="headerlink" title="编译hiredis"></a>编译hiredis</h3><p>进入 redis-6.0.3/deps/hiredis<br>$ make<br>$ sudo make install<br>mkdir -p /usr/local/include/hiredis /usr/local/include/hiredis/adapters /usr/local/lib<br>cp -pPR hiredis.h async.h read.h sds.h /usr/local/include/hiredis<br>cp -pPR adapters/*.h /usr/local/include/hiredis/adapters<br>cp -pPR libhiredis.so /usr/local/lib/libhiredis.so.0.14<br>cd /usr/local/lib &amp;&amp; ln -sf libhiredis.so.0.14 libhiredis.so<br>cp -pPR libhiredis.a /usr/local/lib<br>mkdir -p /usr/local/lib/pkgconfig<br>cp -pPR hiredis.pc /usr/local/lib/pkgconfig<br>可以看到头文件、和库文件的安装目录  </p><h3 id="连接Redis服务"><a href="#连接Redis服务" class="headerlink" title="连接Redis服务"></a>连接Redis服务</h3><img src="/2020/09/20/redis补充/4.png"><h3 id="授权-Auth"><a href="#授权-Auth" class="headerlink" title="授权 Auth"></a>授权 Auth</h3><img src="/2020/09/20/redis补充/5.png"><h3 id="redisCommand-详解"><a href="#redisCommand-详解" class="headerlink" title="redisCommand 详解"></a>redisCommand 详解</h3><p>原型<br>void <em>redisCommand(redisContext </em>c, const char *format, …);  </p><p>参数说明<br>这个函数是一个带有不定参数的。可以按着 format 格式给出对应的参数，这就和 printf 函数类似。<br>c 是一个 reidsConnect 函数返回的一个对象。  </p><p>返回值<br>返回值是一个 void 类型的指针，实际为指向一个 redisReply 类型的指针。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">redisReply 的定义</span><br><span class="line">/* This is the reply object returned by redisCommand() */</span><br><span class="line">typedef struct redisReply &#123;</span><br><span class="line"> /*命令执行结果的返回类型*/</span><br><span class="line"> int type; /* REDIS_REPLY_* */</span><br><span class="line"> /*存储执行结果返回为整数*/</span><br><span class="line"> long long integer; /* The integer when type is REDIS_REPLY_INTEGER */</span><br><span class="line"> /*字符串值的长度*/</span><br><span class="line"> size_t len; /* Length of string */</span><br><span class="line"> /*存储命令执行结果返回是字符串*/</span><br><span class="line"> char *str; /* Used for both REDIS_REPLY_ERROR and REDIS_REPLY_STRING */</span><br><span class="line"> /*返回结果是数组的大小*/</span><br><span class="line"> size_t elements; /* number of elements, for REDIS_REPLY_ARRAY */</span><br><span class="line"> /*存储执行结果返回是数组*/</span><br><span class="line"> struct redisReply **element; /* elements vector for REDIS_REPLY_ARRAY */</span><br><span class="line">&#125; redisReply;</span><br></pre></td></tr></table></figure></p><p>返回结果的类型 reply-&gt;type,reply 为 redisReply* 类型。<br>• REDIS_REPLY_STRING == 1:返回值是字符串,字符串储存在 redis-&gt;str 当中,字符串长度<br>为 redis-&gt;len。<br>• REDIS_REPLY_ARRAY == 2：返回值是数组，数组大小存在 redis-&gt;elements 里面，数组<br>值存储在 redis-&gt;element[i]里面。数组里面存储的是指向 redisReply 的指针，数组里<br>面的返回值可以通过 redis-&gt;element[i]-&gt;str 来访问，数组的结果里全是<br>type==REDIS_REPLY_STRING 的 redisReply 对象指针。<br>• REDIS_REPLY_INTEGER == 3：返回值为整数 long long。<br>• REDIS_REPLY_NIL==4：返回值为空表示执行结果为空。<br>• REDIS_REPLY_STATUS ==5：返回命令执行的状态，比如 set foo bar 返回的状态为 OK，<br>存储在 str 当中 reply-&gt;str == “OK”。<br>• REDIS_REPLY_ERROR ==6 ：命令执行错误,错误信息存放在 reply-&gt;str 当中。  </p><img src="/2020/09/20/redis补充/6.png">]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;扩容与缩容&quot;&gt;&lt;a href=&quot;#扩容与缩容&quot; class=&quot;headerlink&quot; title=&quot;扩容与缩容&quot;&gt;&lt;/a&gt;扩容与缩容&lt;/h2&gt;&lt;p&gt;扩容&lt;br&gt;当used &amp;gt; size 的时候扩容，当进行持久化aof,rdb,script(lua事务) bl
      
    
    </summary>
    
      <category term="redis" scheme="http://twh233.github.io/categories/redis/"/>
    
    
      <category term="redis" scheme="http://twh233.github.io/tags/redis/"/>
    
  </entry>
  
</feed>
