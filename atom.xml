<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Twh233&#39;s Blog</title>
  
  <subtitle>Love Coding,Enjoy Life</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://twh233.github.io/"/>
  <updated>2020-11-10T13:22:22.296Z</updated>
  <id>http://twh233.github.io/</id>
  
  <author>
    <name>Twh233</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>内核空间和用户空间</title>
    <link href="http://twh233.github.io/2020/11/10/%E5%86%85%E6%A0%B8%E7%A9%BA%E9%97%B4%E5%92%8C%E7%94%A8%E6%88%B7%E7%A9%BA%E9%97%B4/"/>
    <id>http://twh233.github.io/2020/11/10/内核空间和用户空间/</id>
    <published>2020-11-10T13:17:02.000Z</published>
    <updated>2020-11-10T13:22:22.296Z</updated>
    
    <content type="html"><![CDATA[<img src="/2020/11/10/内核空间和用户空间/1.png"><p>内核空间与用户空间拷贝的时候，需要在用户空间找到物理地址，再拷贝到内核空间的物理地址中。如果物理地址刚好在一张页上，那么可以一次完成拷贝；但如果物理地址跨页，那么会进行跨页的拷贝，性能有所降低；再者，如果在内存中没有找到，那么会引发缺页中断，去对应磁盘地址上拷贝，性能会更低。</p><img src="/2020/11/10/内核空间和用户空间/2.png"><img src="/2020/11/10/内核空间和用户空间/3.png">]]></content>
    
    <summary type="html">
    
      
      
        &lt;img src=&quot;/2020/11/10/内核空间和用户空间/1.png&quot;&gt;
&lt;p&gt;内核空间与用户空间拷贝的时候，需要在用户空间找到物理地址，再拷贝到内核空间的物理地址中。如果物理地址刚好在一张页上，那么可以一次完成拷贝；但如果物理地址跨页，那么会进行跨页的拷贝，性能有所降低；
      
    
    </summary>
    
      <category term="linux" scheme="http://twh233.github.io/categories/linux/"/>
    
    
      <category term="linux" scheme="http://twh233.github.io/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>skynet</title>
    <link href="http://twh233.github.io/2020/11/08/skynet/"/>
    <id>http://twh233.github.io/2020/11/08/skynet/</id>
    <published>2020-11-08T11:35:34.000Z</published>
    <updated>2020-11-08T12:25:31.920Z</updated>
    
    <content type="html"><![CDATA[<h2 id="多核开发与actor模型"><a href="#多核开发与actor模型" class="headerlink" title="多核开发与actor模型"></a>多核开发与actor模型</h2><ol><li><p>多进程<br> a) 消息队列  </p><pre><code>i. 协议问题  ii. 断线重连  iii. 进程启动顺序问题  iv. 负载均衡问题  v. 数据同步问题  </code></pre><p> b) RPC  </p><pre><code>i. 两个系统保持同步问题   </code></pre><p> c) zk    </p><pre><code>i. 配置项管理问题  ii. 集群管理   iii. 统一命名问题  iv. 状态同步问题  v. 分布式锁问题    </code></pre><p> d) 拆分  </p><pre><code>i. 功能拆分  ii. 热点拆分  </code></pre></li><li><p>多线程  </p></li><li>并发模型：CSP 模型 与 actor 模型  </li><li>结论：多进程并发实体是进程，多线程并发实体是线程，go 并发实体是 goroutine（协程），actor 并发实体是 actor（语言层面抽象出来的“进程”）。它们都是在隔离性（运行环境）与统一性（数据统一）之间作取舍平衡，而 actor 模型在语言层面做运行环境的隔离，数据同步依然需要通过消息来同步。actor 模型是加强版的多进程解决方案，进程间通信由<br>socket 转为指针的传递，从而通信变得更加可靠，同时多进程解决方案中，公共开源组件（消息队列，rpc，zookeeper）解决的问题，在 actor 模型中处理起来更方便。  </li><li>actor 定义：<br> a) 用于并行计算<br> b) actor 是最基本的计算单元<br> c) 基于消息计算<br> d) actor 之间通过消息沟通并且相互隔离  </li></ol><h2 id="skynet中的actor模型"><a href="#skynet中的actor模型" class="headerlink" title="skynet中的actor模型"></a>skynet中的actor模型</h2><ol><li>结构组成<br> a) 隔离的环境（内存块或 lua 虚拟机）<br> b) 消息队列<br> c) 回调函数  </li><li>实现<br> a) logger 服务 service-src/service_logger.c<br> b) lua 服务启动器 service-src/service_snlua.c  </li></ol><h2 id="actor运行以及消息调度"><a href="#actor运行以及消息调度" class="headerlink" title="actor运行以及消息调度"></a>actor运行以及消息调度</h2><img src="/2020/11/08/skynet/1.png"><ol><li>消息队列<br> a) 全局消息队列<br> b) actor 消息队列   </li><li>skynet 中锁的使用<br> a) 互斥锁  <pre><code>{% asset_img 2.png %}  </code></pre> b) 自旋锁  <pre><code>worker 轮询消息队列  {% asset_img 3.png %} </code></pre> c) 读写锁  <pre><code>handle_storage  </code></pre> d) 条件变量  <pre><code>worker 线程的休眠  </code></pre></li><li>skynet 中线程<br> a) timer<br> b) socket<br> c) worker<pre><code>i. “权重”来定制消费消息的数量（-1 消费一个，0 全部消费，1 消费一半）  ii. 休眠（条件变量）与唤醒（timer 和 socket）</code></pre> d) monitor  <pre><code>i. 检查服务消息过载</code></pre></li></ol><img src="/2020/11/08/skynet/5.png">  <img src="/2020/11/08/skynet/6.png"><h2 id="skynet网络层"><a href="#skynet网络层" class="headerlink" title="skynet网络层"></a>skynet网络层</h2><h3 id="actor-需要网络事件绑定？"><a href="#actor-需要网络事件绑定？" class="headerlink" title="actor 需要网络事件绑定？"></a>actor 需要网络事件绑定？</h3><p>1.connetfd 跟 redis  接受redis的数据<br>2.clientfd<br>3.listenfd clientfd = accept(); skynet作为客户端连接其他服务fd<br>4.管道fd 管道读端  work 线程往管道写端写数据  socket线程在管道读端读数据</p><p>worker在发送数据的时候 try_spinlock() 拿到锁，直接在worker线程将数据发送出去，其他情况在socket线程</p><img src="/2020/11/08/skynet/4.jpg"> <h3 id="阻塞IO与非阻塞IO的区别"><a href="#阻塞IO与非阻塞IO的区别" class="headerlink" title="阻塞IO与非阻塞IO的区别"></a>阻塞IO与非阻塞IO的区别</h3><ol><li>阻塞网络线程</li><li>在于没有数据到达的时候是否立刻返回</li><li>fnctl fd noblock(recv/send  read/write)决定了IO是否阻塞</li></ol><p>read(fd,buf,sz)<br>recv(fd,buf,sz,0)</p><h2 id="lua-与-c-接口编程"><a href="#lua-与-c-接口编程" class="headerlink" title="lua 与 c 接口编程"></a>lua 与 c 接口编程</h2><ol><li>元表<br> a) 定制行为 <strong>index, </strong>newindex<br> b) 只有 table 和 userdata 对象有独自的元表，其他类型只有类型元表<br> c) 只有 table 可以在 lua 中修改设置元表<br> d) userdata 只能在 c 中修改设置元表，lua 中不能修改 userdata 元表  </li><li>协程<br> a) 一段独立的执行线程<br> b) 一个 lua 虚拟机中同时只能有一个协程在运行<br> c) 目的：写的时候是同步的书写方式，而实际内部是异步非阻塞的实现   <img src="/2020/11/08/skynet/8.png"> </li><li>闭包<br> a) 表现  <pre><code>i. 函数内部可以访问函数外部的变量  ii. lua 文件是一个匿名函数  </code></pre> b) 实现  <pre><code>i. c 函数以及绑定在 c 函数上的 upvalues(上值)  </code></pre> c) 用 lua_pushcclosure 用来创建 c 闭包<br> d) 通过 lua_upvalueindex 伪索引来获取上值  </li><li>虚拟栈<br> 通过虚拟栈实现两者的读写数据操作   <img src="/2020/11/08/skynet/7.png"> </li><li>注册表<br> a) 预定义的表，用来保存任何 c 代码想保存的 lua 值<br> b) 使用 LUA_REGISTRYINDEX 来索引  </li></ol><h2 id="actor-通信"><a href="#actor-通信" class="headerlink" title="actor 通信"></a>actor 通信</h2><ol><li>skynet.send/skynet.call  </li><li>skynet.redirect  </li><li>skynet.response  </li><li>skynet.ret  </li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;多核开发与actor模型&quot;&gt;&lt;a href=&quot;#多核开发与actor模型&quot; class=&quot;headerlink&quot; title=&quot;多核开发与actor模型&quot;&gt;&lt;/a&gt;多核开发与actor模型&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;多进程&lt;br&gt; a) 消息队列  &lt;/p&gt;
      
    
    </summary>
    
      <category term="skynet" scheme="http://twh233.github.io/categories/skynet/"/>
    
    
      <category term="skynet" scheme="http://twh233.github.io/tags/skynet/"/>
    
  </entry>
  
  <entry>
    <title>工作中遇到的问题</title>
    <link href="http://twh233.github.io/2020/11/04/%E5%B7%A5%E4%BD%9C%E4%B8%AD%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98/"/>
    <id>http://twh233.github.io/2020/11/04/工作中遇到的问题/</id>
    <published>2020-11-04T14:15:10.000Z</published>
    <updated>2020-11-05T13:40:24.176Z</updated>
    
    <content type="html"><![CDATA[<p>1.result 等字段可重用的可以考虑重用节约内存<br>2.不要在客户端请求的时候处理数据，提前处理好，客户端请求直接返回<br>3.从数据库拿出来的数据都是数组，需要取ret[1]<br>4.可以从过参数传递函数，做定时器处理<br>5.数据库日志分得越详细越好，不同功能的表尽量分开<br>6.节点与节点间尽量一次性调用，避免绕圈调用<br>7.逻辑不与客户端同步，尽量保持单请求也能有反馈<br>8.在agent的监听，下线记得清除或者在task_msg_center.lua去统一<br>9.lua是协程，有的情况也得考虑下锁的问题<br>10.mysql中，<br>varchar 存储变长的字符串，但需要1个或2个额外字节记录字符串长度；<br>char 存储定长的字符串。<br>DataTime 8字节，TimeStamp 4字节。<br>能用TinyInt的话不要用Int。<br>索引在where条件查询和group by查询的时候特别有效。<br>11.查询优化：<br>(1 避免查找无关列<br>(2 分解关联查询，减少锁竞争<br>(3 用=不用&lt;&gt;，”=” 增加了索引使用几率<br>(4 UNION ALL 不去重，效率高于UNION<br>(5 数据行长度不要超过8020字节，超过这个长度会占用两行<br>(6 能用数字类型的字段尽量选择数字类型而不用字符串类型（电话号码），这会降低查询和连接性能，并会增加存储开销<br>(7 对于不可变char和可变varchar，char查询快，但是耗空间，varchar慢一些，但是节省存储空间<br>(8 避免在where子句进行null判断或者用or来连接条件<br>select id from t where num = 10 or num = 20;<br>select id from t where num = 10 union all select id from t where num = 20;<br>(9 in 和 not in 慎用。对于连续的数值能用between就不要用in<br>select id from t where num in (1,2,3);<br>select id from t where num between 1 and 3;<br>(10 避免在where子句中对字段进行操作<br>select id from t where substring(name,1,3) = ‘abc’;<br>select <em> from T1 where F1 = 100 </em> 2;<br>12.DATA.match_config.signup_data_config.signup_dur 变量过长用简写local变量代替<br>13.数据结构先行，不能到后面再来补数据结构<br>14.有些数据可以考虑不写数据库<br>15.lua for k,v in pairs(table)  如果v是普通类型，直接修改v不会导致table的数据变化，如果v也是table 修改v同时会修改table<br>16.用local变量等于一张表的时候，对local变量修改之后，最后把变量重新赋值给表  </p><pre><code>local s = _table or {}s.v = 1  _table = s  </code></pre><p>17.设计功能时，考虑多方面情况，例如托管节点崩溃，上一场的崩溃是否影响下一场，避免这种情况<br>18.脑里构建模块化，无论是函数还是功能，可以分函数，分文件来写<br>19.做完功能，设计好处理崩溃的函数，例如查询在比赛里的人或者PUBLIC.exit()  </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;1.result 等字段可重用的可以考虑重用节约内存&lt;br&gt;2.不要在客户端请求的时候处理数据，提前处理好，客户端请求直接返回&lt;br&gt;3.从数据库拿出来的数据都是数组，需要取ret[1]&lt;br&gt;4.可以从过参数传递函数，做定时器处理&lt;br&gt;5.数据库日志分得越详细越好，不同
      
    
    </summary>
    
      <category term="基础" scheme="http://twh233.github.io/categories/%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="基础" scheme="http://twh233.github.io/tags/%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>Nginx添加Handle模块</title>
    <link href="http://twh233.github.io/2020/11/03/Nginx%E6%B7%BB%E5%8A%A0Handle%E6%A8%A1%E5%9D%97/"/>
    <id>http://twh233.github.io/2020/11/03/Nginx添加Handle模块/</id>
    <published>2020-11-03T15:01:42.000Z</published>
    <updated>2020-11-03T15:17:12.408Z</updated>
    
    <content type="html"><![CDATA[<p>nginx 三种类型</p><p>1.upstream 负载均衡，只转发不返回<br>2.handle 接受请求，直接可以处理<br>3.filter 服务器reponse 验证  </p><p>ngx_http_pagecount_module.c</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">#include &lt;ngx_http.h&gt;</span><br><span class="line">#include &lt;ngx_config.h&gt;</span><br><span class="line">#include &lt;ngx_core.h&gt;</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">#include &lt;arpa/inet.h&gt;</span><br><span class="line">#include &lt;netinet/in.h&gt;</span><br><span class="line">*/</span><br><span class="line">#define ENABLE_RBTREE1</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">static char *ngx_http_count_module_set(ngx_conf_t *cf, ngx_command_t *cmd, void *conf);</span><br><span class="line">static ngx_int_t ngx_http_count_module_handler(ngx_http_request_t *r);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">static ngx_command_t count_commands[] = &#123;</span><br><span class="line">&#123;</span><br><span class="line">ngx_string(&quot;count&quot;),</span><br><span class="line">NGX_HTTP_LOC_CONF | NGX_CONF_NOARGS,</span><br><span class="line">ngx_http_count_module_set,</span><br><span class="line">NGX_HTTP_LOC_CONF_OFFSET,</span><br><span class="line">0, NULL</span><br><span class="line">&#125;,</span><br><span class="line">ngx_null_command</span><br><span class="line">&#125;;</span><br><span class="line">// 8个NULL</span><br><span class="line">static ngx_http_module_t count_ctx = &#123;</span><br><span class="line">NULL,</span><br><span class="line">NULL,</span><br><span class="line"></span><br><span class="line">NULL,</span><br><span class="line">NULL,</span><br><span class="line"></span><br><span class="line">NULL,</span><br><span class="line">NULL,</span><br><span class="line"></span><br><span class="line">NULL,</span><br><span class="line">NULL,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">//ngx_http_count_module </span><br><span class="line">ngx_module_t ngx_http_count_module = &#123;</span><br><span class="line">NGX_MODULE_V1,</span><br><span class="line">&amp;count_ctx,</span><br><span class="line">count_commands,</span><br><span class="line">NGX_HTTP_MODULE,</span><br><span class="line">NULL,</span><br><span class="line">NULL,</span><br><span class="line">NULL,</span><br><span class="line">NULL,</span><br><span class="line">NULL,</span><br><span class="line">NULL,</span><br><span class="line">NULL,</span><br><span class="line">NGX_MODULE_V1_PADDING</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">typedef struct &#123;</span><br><span class="line">int count; //count</span><br><span class="line">struct in_addr addr; //ip</span><br><span class="line">&#125; ngx_pv_table;</span><br><span class="line"></span><br><span class="line">ngx_pv_table pv_table[256];</span><br><span class="line"></span><br><span class="line">#if ENABLE_RBTREE</span><br><span class="line">ngx_rbtree_t ngx_pv_tree; // 红黑树</span><br><span class="line">ngx_rbtree_node_t sentinel; // 哨兵结点</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">static void</span><br><span class="line">ngx_pagecount_rbtree_insert_value(ngx_rbtree_node_t *temp,</span><br><span class="line">    ngx_rbtree_node_t *node, ngx_rbtree_node_t *sentinel)</span><br><span class="line">&#123;</span><br><span class="line">    ngx_rbtree_node_t    **p;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    for ( ;; ) &#123;</span><br><span class="line"></span><br><span class="line">        if (node-&gt;key &lt; temp-&gt;key) &#123;</span><br><span class="line"></span><br><span class="line">            p = &amp;temp-&gt;left;</span><br><span class="line"></span><br><span class="line">        &#125; else if (node-&gt;key &gt; temp-&gt;key) &#123;</span><br><span class="line"></span><br><span class="line">            p = &amp;temp-&gt;right;</span><br><span class="line"></span><br><span class="line">        &#125; else &#123; /* node-&gt;key == temp-&gt;key */</span><br><span class="line"></span><br><span class="line">           return ;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (*p == sentinel) &#123;</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        temp = *p;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    *p = node;</span><br><span class="line">    node-&gt;parent = temp;</span><br><span class="line">    node-&gt;left = sentinel;</span><br><span class="line">    node-&gt;right = sentinel;</span><br><span class="line">    ngx_rbt_red(node);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">static char *ngx_http_count_module_set(ngx_conf_t *cf, ngx_command_t *cmd, void *conf) &#123;</span><br><span class="line">#if ENABLE_RBTREE</span><br><span class="line">ngx_rbtree_init(&amp;ngx_pv_tree, &amp;sentinel, ngx_pagecount_rbtree_insert_value); //初始化红黑树</span><br><span class="line">#endif</span><br><span class="line">ngx_http_core_loc_conf_t *corecf = ngx_http_conf_get_module_loc_conf(cf, ngx_http_core_module);</span><br><span class="line">corecf-&gt;handler = ngx_http_count_module_handler; //注册handler</span><br><span class="line"></span><br><span class="line">return NGX_CONF_OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#if ENABLE_RBTREE</span><br><span class="line"></span><br><span class="line">//char content[1024];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//回调html组装函数</span><br><span class="line">void ngx_http_count_rbtree_iterator(ngx_rbtree_node_t *node, char *html) &#123;</span><br><span class="line"></span><br><span class="line">char buffer[128] = &#123;0&#125;;</span><br><span class="line"></span><br><span class="line">struct in_addr addr = &#123;0&#125;;</span><br><span class="line">memcpy(&amp;addr, &amp;node-&gt;key, sizeof(struct in_addr));</span><br><span class="line"></span><br><span class="line">sprintf(buffer, &quot;req from : %s, count: %d &lt;br/&gt;&quot;,</span><br><span class="line">inet_ntoa(addr), node-&gt;value);</span><br><span class="line"></span><br><span class="line">strcat(html, buffer);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">static int ngx_encode_http_page_rb(char *html) &#123;</span><br><span class="line"></span><br><span class="line">sprintf(html, &quot;&lt;h1&gt;Source Insight &lt;/h1&gt;&quot;);</span><br><span class="line">strcat(html, &quot;&lt;h2&gt;&quot;);</span><br><span class="line"></span><br><span class="line">ngx_rbtree_traversal(&amp;ngx_pv_tree, ngx_pv_tree.root, ngx_http_count_rbtree_iterator, html);</span><br><span class="line"></span><br><span class="line">strcat(html, &quot;&lt;/h2&gt;&quot;);</span><br><span class="line"></span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#else</span><br><span class="line"></span><br><span class="line">#if 1</span><br><span class="line">static int ngx_encode_http_page(char *html) &#123;</span><br><span class="line">sprintf(html, &quot;&lt;h1&gt;Source Insight &lt;/h1&gt;&quot;);</span><br><span class="line">strcat(html, &quot;&lt;h2&gt;&quot;);</span><br><span class="line"></span><br><span class="line">int i = 0;</span><br><span class="line">for (i = 0;i &lt; 256;i ++) &#123;</span><br><span class="line">if (pv_table[i].count != 0) &#123;</span><br><span class="line"></span><br><span class="line">char str[INET_ADDRSTRLEN] = &#123;0&#125;;</span><br><span class="line">char buffer[128] = &#123;0&#125;;</span><br><span class="line"></span><br><span class="line">sprintf(buffer, &quot;req from : %s, count: %d &lt;br/&gt;&quot;,</span><br><span class="line">inet_ntop(AF_INET, &amp;pv_table[i].addr, str, sizeof(str)), pv_table[i].count);</span><br><span class="line"></span><br><span class="line">strcat(html, buffer);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">strcat(html, &quot;&lt;/h2&gt;&quot;);</span><br><span class="line"></span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">static ngx_int_t ngx_http_count_module_handler(ngx_http_request_t *r) &#123;</span><br><span class="line">#if 0</span><br><span class="line">u_char html[1024] = &quot;&lt;h1&gt; bailang, Reese, feifei, qizhewoniuqukandahai, huihuisasa, magic, jianyuebujiandan, yuan &lt;/h1&gt;&quot;;</span><br><span class="line">int len = sizeof(html);</span><br><span class="line">#elif 1</span><br><span class="line"></span><br><span class="line">u_char html[1024] = &#123;0&#125;;</span><br><span class="line">int len = sizeof(html);</span><br><span class="line"></span><br><span class="line">#if ENABLE_RBTREE</span><br><span class="line">ngx_rbtree_node_t *node = NULL;</span><br><span class="line">ngx_rbtree_key_t key = 0;</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">struct sockaddr_in *client_addr =  (struct sockaddr_in*)r-&gt;connection-&gt;sockaddr;</span><br><span class="line">//rbtree &lt;key, value&gt;  --&gt; &lt;addr, count&gt;</span><br><span class="line"></span><br><span class="line">int idx = client_addr-&gt;sin_addr.s_addr &gt;&gt; 24;</span><br><span class="line"></span><br><span class="line">//rbtree --&gt; (key, value)</span><br><span class="line">pv_table[idx].count ++;</span><br><span class="line">memcpy(&amp;pv_table[idx].addr, &amp;client_addr-&gt;sin_addr, sizeof(client_addr-&gt;sin_addr));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#if ENABLE_RBTREE</span><br><span class="line"></span><br><span class="line">key = (ngx_rbtree_key_t)client_addr-&gt;sin_addr.s_addr;</span><br><span class="line">ngx_log_error(NGX_LOG_EMERG, r-&gt;connection-&gt;log, ngx_errno, &quot; ngx_http_count_module_handler --&gt; %x\n&quot;, key);</span><br><span class="line">node = ngx_rbtree_search(&amp;ngx_pv_tree, key); // 从红黑树中找</span><br><span class="line">ngx_log_error(NGX_LOG_EMERG, r-&gt;connection-&gt;log, ngx_errno, &quot; 11111 --&gt; %x\n&quot;, key);</span><br><span class="line"></span><br><span class="line">// 处理红黑树存储结点</span><br><span class="line">if (node == &amp;sentinel) &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">ngx_log_error(NGX_LOG_EMERG, r-&gt;connection-&gt;log, ngx_errno, &quot; new node insert rbtree\n&quot;, key);</span><br><span class="line">node = ngx_pcalloc(r-&gt;pool, sizeof(ngx_rbtree_node_t));</span><br><span class="line">node-&gt;key = (ngx_rbtree_key_t)client_addr-&gt;sin_addr.s_addr;</span><br><span class="line">node-&gt;value = 1;</span><br><span class="line"></span><br><span class="line">ngx_rbtree_insert(&amp;ngx_pv_tree, node);</span><br><span class="line">&#125; else &#123;</span><br><span class="line">node-&gt;value ++;</span><br><span class="line"></span><br><span class="line">ngx_log_error(NGX_LOG_EMERG, r-&gt;connection-&gt;log, ngx_errno, &quot; node is exist, value:%d\n&quot;, node-&gt;value);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//memset(content, 0, 1024);</span><br><span class="line"></span><br><span class="line">ngx_encode_http_page_rb((char*)html);</span><br><span class="line"></span><br><span class="line">ngx_log_error(NGX_LOG_EMERG, r-&gt;connection-&gt;log, ngx_errno, &quot; html: %s\n&quot;, html);</span><br><span class="line"></span><br><span class="line">//memcpy(html, content, len);</span><br><span class="line">#else</span><br><span class="line"></span><br><span class="line">ngx_encode_http_page((char*)html);</span><br><span class="line"></span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">#else</span><br><span class="line"></span><br><span class="line">// ---------------------------- 下面组装 http response -------------------------</span><br><span class="line"></span><br><span class="line">struct sockaddr_in *client_addr =  (struct sockaddr_in*)r-&gt;connection-&gt;sockaddr;</span><br><span class="line">ngx_rbtree_node_t *node = ngx_pcalloc(r-&gt;pool,  sizeof(ngx_rbtree_node_t));</span><br><span class="line"></span><br><span class="line">memcpy(&amp;node-&gt;key, &amp;client_addr-&gt;sin_addr.s_addr, sizeof(node-&gt;key));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#endif</span><br><span class="line">//header</span><br><span class="line">r-&gt;headers_out.status = 200;</span><br><span class="line">ngx_str_set(&amp;r-&gt;headers_out.content_type, &quot;text/html&quot;);</span><br><span class="line">ngx_http_send_header(r);</span><br><span class="line"></span><br><span class="line">//body</span><br><span class="line">ngx_buf_t *b = ngx_pcalloc(r-&gt;pool,  sizeof(ngx_buf_t)); // 从内存池中malloc</span><br><span class="line"></span><br><span class="line">ngx_chain_t out;</span><br><span class="line">out.buf = b;</span><br><span class="line">out.next = NULL;</span><br><span class="line"></span><br><span class="line">b-&gt;pos = html;</span><br><span class="line">b-&gt;last = html+len;</span><br><span class="line">b-&gt;memory = 1;</span><br><span class="line">b-&gt;last_buf = 1;</span><br><span class="line"></span><br><span class="line">return ngx_http_output_filter(r, &amp;out); //http response</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>config </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ngx_addon_name=ngx_http_pagecount_module</span><br><span class="line">HTTP_MODULES=&quot;$HTTP_MODULES ngx_http_pagecount_module&quot;</span><br><span class="line">NGX_ADDON_SRCS=&quot;$NGX_ADDON_SRCS $ngx_addon_dir/pagecount_module.c&quot;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;nginx 三种类型&lt;/p&gt;
&lt;p&gt;1.upstream 负载均衡，只转发不返回&lt;br&gt;2.handle 接受请求，直接可以处理&lt;br&gt;3.filter 服务器reponse 验证  &lt;/p&gt;
&lt;p&gt;ngx_http_pagecount_module.c&lt;/p&gt;
&lt;figu
      
    
    </summary>
    
      <category term="nginx" scheme="http://twh233.github.io/categories/nginx/"/>
    
    
      <category term="nginx" scheme="http://twh233.github.io/tags/nginx/"/>
    
  </entry>
  
  <entry>
    <title>mysql面试前看</title>
    <link href="http://twh233.github.io/2020/11/02/mysql%E9%9D%A2%E8%AF%95%E5%89%8D%E7%9C%8B/"/>
    <id>http://twh233.github.io/2020/11/02/mysql面试前看/</id>
    <published>2020-11-02T15:42:49.000Z</published>
    <updated>2020-11-02T15:43:13.585Z</updated>
    
    <content type="html"><![CDATA[<h2 id="InnoDB-MyISAM-区别"><a href="#InnoDB-MyISAM-区别" class="headerlink" title="InnoDB MyISAM 区别"></a>InnoDB MyISAM 区别</h2><p>InnoDB 支持崩溃后安全恢复，MyISAM 不支持崩溃后安全恢复；<br>InnoDB 支持行级锁，MyISAM 不支持行级锁，只支持到表锁；<br>InnoDB 支持外键，MyISAM 不支持外键；<br>MyISAM 性能比 InnoDB 高；<br>MyISAM 支持 FULLTEXT 类型的全文索引，InnoDB 不支持 FULLTEXT 类型的全文索引，但是 InnoDB 可以使用 sphinx 插件支持全文索引，并且效果更好；<br>InnoDB 主键查询性能高于 MyISAM。</p><h3 id="InnoDB"><a href="#InnoDB" class="headerlink" title="InnoDB"></a>InnoDB</h3><p>1）插入缓冲<br>2）两次写<br>两次写给 InnoDB 带来的是可靠性，主要用来解决部分写失败</p><p>3）自适应哈希索引</p><p>InnoDB 自增主键持久化 Mysql重启后在redo log日志中恢复<br>InnoDB 使用事务实现，而事务的设计使用了多版本并发控制，不能把总条数记录下来。</p><p>在 InnoDB 引擎中 count(<em>)、count(1)、count(主键)、count(字段) 哪个性能最高？<br>count(字段)&lt;count(主键 id)&lt;count(1)≈count(</em>) 题目解析：</p><p>对于 count(主键 id) 来说，InnoDB 引擎会遍历整张表，把每一行的 id 值都取出来，返回给 server 层。server 层拿到 id 后，判断是不可能为空的，就按行累加。<br>对于 count(1) 来说，InnoDB 引擎遍历整张表，但不取值。server 层对于返回的每一行，放一个数字“1”进去，判断是不可能为空的，按行累加。<br>对于 count(字段) 来说，如果这个“字段”是定义为 not null 的话，一行行地从记录里面读出这个字段，判断不能为 null，按行累加；如果这个“字段”定义允许为 null，那么执行的时候，判断到有可能是 null，还要把值取出来再判断一下，不是 null 才累加。<br>对于 count(*) 来说，并不会把全部字段取出来，而是专门做了优化，不取值，直接按行累加。  </p><h2 id="重建表的执行流程"><a href="#重建表的执行流程" class="headerlink" title="重建表的执行流程"></a>重建表的执行流程</h2><p>建立一个临时文件，扫描表 t 主键的所有数据页；<br>用数据页中表 t 的记录生成 B+ 树，存储到临时文件中；<br>生成临时文件的过程中，将所有对 t 的操作记录在一个日志文件（row log）中；<br>临时文件生成后，将日志文件中的操作应用到临时文件，得到一个逻辑数据上与表 t相同的数据文件；<br>用临时文件替换表 t 的数据文件。  </p><h2 id="并发事务带来哪些问题"><a href="#并发事务带来哪些问题" class="headerlink" title="并发事务带来哪些问题"></a>并发事务带来哪些问题</h2><p>脏读 修改丢失 不可重复读 幻读</p><h3 id="什么是脏读和幻读？"><a href="#什么是脏读和幻读？" class="headerlink" title="什么是脏读和幻读？"></a>什么是脏读和幻读？</h3><p>脏读是一个事务在处理过程中读取了另外一个事务未提交的数据；幻读是指同一个事务内多次查询返回的结果集不一样（比如增加了或者减少了行记录）。</p><h3 id="如何避免幻读"><a href="#如何避免幻读" class="headerlink" title="如何避免幻读"></a>如何避免幻读</h3><p>使用间隙锁的方式来避免出现幻读。间隙锁，是专门用于解决幻读这种问题的锁，它锁的了行与行之间的间隙，能够阻塞新插入的操作 间隙锁的引入也带来了一些新的问题，比如：降低并发度，可能导致死锁。</p><h2 id="delete-和-truncate-区别"><a href="#delete-和-truncate-区别" class="headerlink" title="delete 和 truncate 区别"></a>delete 和 truncate 区别</h2><p>delete 可以添加 where 条件删除部分数据，truncate 不能添加 where 条件只能删除整张表；<br>delete 的删除信息会在 MySQL 的日志中记录，而 truncate 的删除信息不被记录在 MySQL 的日志中，因此 detele 的信息可以被找回而 truncate 的信息无法被找回；<br>truncate 因为不记录日志所以执行效率比 delete 快。  </p><h2 id="视图"><a href="#视图" class="headerlink" title="视图"></a>视图</h2><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><p>获取数据更容易，相对于多表查询来说；<br>视图能够对机密数据提供安全保护；<br>视图的修改不会影响基本表，提供了独立的操作单元，比较轻量。  </p><h2 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h2><h3 id="唯一索引和普通索引哪个性能更好？"><a href="#唯一索引和普通索引哪个性能更好？" class="headerlink" title="唯一索引和普通索引哪个性能更好？"></a>唯一索引和普通索引哪个性能更好？</h3><p>对于查询操作来说：普通索引和唯一索引的性能相近，都是从索引树中进行查询；<br>对于更新操作来说：唯一索引要比普通索引执行的慢，因为唯一索引需要先将数据读取到内存中，再在内存中进行数据的唯一效验，所以执行起来要比普通索引更慢。  </p><h3 id="如何优化身份证的索引？"><a href="#如何优化身份证的索引？" class="headerlink" title="如何优化身份证的索引？"></a>如何优化身份证的索引？</h3><p>在中国因为前 6 位代表的是地区，所以很多人的前六位都是相同的，如果我们使用前缀索引为 6 位的话，性能提升也并不是很明显，但如果设置的位数过长，那么占用的磁盘空间也越大，数据页能放下的索引值就越少，搜索效率也越低。针对这种情况优化方案有以下两种：  </p><p>使用身份证倒序存储，这样设置前六位的意义就很大了；<br>使用 hash 值，新创建一个字段用于存储身份证的 hash 值。  </p><h2 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h2><p>原子性（Atomic）：要么全部执行，要么全部不执行；<br>一致性（Consistency）：事务的执行使得数据库从一种正确状态转化为另一种正确状态；<br>隔离性（Isolation）：在事务正确提交之前，不允许把该事务对数据的任何改变提供给其他事务；<br>持久性（Durability）：事务提交后，其结果永久保存在数据库中。  </p><h3 id="四种事务隔离级别"><a href="#四种事务隔离级别" class="headerlink" title="四种事务隔离级别"></a>四种事务隔离级别</h3><p>read uncommited：未提交读，读到未提交数据；<br>read committed：读已提交，也叫不可重复读，两次读取到的数据不一致；<br>repetable read：可重复读；<br>serializable：串行化，读写数据都会锁住整张表，数据操作不会出错，但并发性能极低，开发中很少用到。  </p><h3 id="MVCC"><a href="#MVCC" class="headerlink" title="MVCC"></a>MVCC</h3><p>MVCC 全称是多版本并发控制系统，InnoDB 和 Falcon 存储引擎通过多版本并发控制（MVCC，Multiversion Concurrency Control）机制解决幻读问题。</p><p>InnoDB 的 MVCC 是通过在每行记录后面保存两个隐藏的列来实现，这两个列一个保存了行的创建时间，一个保存行的过期时间（删除时间）。当然存储的并不是真实的时间而是系统版本号（system version number）。每开始一个新的事务，系统版本号都会自动新增，事务开始时刻的系统版本号会作为事务的版本号，用来查询到每行记录的版本号进行比较。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;InnoDB-MyISAM-区别&quot;&gt;&lt;a href=&quot;#InnoDB-MyISAM-区别&quot; class=&quot;headerlink&quot; title=&quot;InnoDB MyISAM 区别&quot;&gt;&lt;/a&gt;InnoDB MyISAM 区别&lt;/h2&gt;&lt;p&gt;InnoDB 支持崩溃后安全
      
    
    </summary>
    
      <category term="mysql" scheme="http://twh233.github.io/categories/mysql/"/>
    
    
      <category term="mysql" scheme="http://twh233.github.io/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>云盘项目</title>
    <link href="http://twh233.github.io/2020/11/02/%E4%BA%91%E7%9B%98%E9%A1%B9%E7%9B%AE/"/>
    <id>http://twh233.github.io/2020/11/02/云盘项目/</id>
    <published>2020-11-02T15:40:21.000Z</published>
    <updated>2020-11-02T15:41:45.145Z</updated>
    
    <content type="html"><![CDATA[<p>待补…..</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;待补…..&lt;/p&gt;

      
    
    </summary>
    
      <category term="项目" scheme="http://twh233.github.io/categories/%E9%A1%B9%E7%9B%AE/"/>
    
    
      <category term="项目" scheme="http://twh233.github.io/tags/%E9%A1%B9%E7%9B%AE/"/>
    
  </entry>
  
  <entry>
    <title>FastDFS</title>
    <link href="http://twh233.github.io/2020/10/28/FastDFS/"/>
    <id>http://twh233.github.io/2020/10/28/FastDFS/</id>
    <published>2020-10-28T15:39:05.000Z</published>
    <updated>2020-10-28T15:49:49.314Z</updated>
    
    <content type="html"><![CDATA[<p>FastDFS 是一个开源的分布式文件系统，它对文件进行管理，功能包括：文件存储、文件同<br>步、文件访问（文件上传、文件下载）等，解决了大容量存储和负载均衡的问题。特别适合<br>以文件为载体的在线服务，如相册网站、视频网站等等。</p><h2 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h2><ol><li>fastDFS 概述：<br>○ 是用 c 语言编写的一款开源的分布式文件系统。<br>○ 为互联网量身定制，充分考虑了冗余备份、负载均衡、线性扩容等机制，并注<br>重高可用、高性能等指标<br>○ 可以很容易搭建一套高性能的文件服务器集群提供文件上传、下载等服务。  </li><li>fastDFS 特点:<br>○ 应用层级的文件系统<br>○ 不能挂载和卸载，也就是不能进行 mount 操作  </li><li>fastDFS 框架中的三个角色<br>○ 追踪器 - tracker<br>○ 存储节点 - storage<br>○ 客户端 - client  </li><li>fastDFS 三个角色之间的关系<br>○ Client 和 Storage 主动连接 Tracker。<br>○ Storage 主动向 Tracker 报告其状态信息<br>§ 磁盘剩余空间<br>§ 文件同步状况<br>§ 文件上传下载次数<br>○ Storage 会启动一个单独的线程来完成对一台 Tracker 的连接和定时报告。<br>一个组包含的 Storage 不是通过配置文件设定的，而是通过 Tracker 获取到的。</li></ol><img src="/2020/10/28/FastDFS/6.png"><h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><ol><li>默认配置文件位置：<br>○ /etc/fdfs  </li><li>Tracker（追踪器）<br>○ 修改配置文件<br>§ bind_addr=192.168.52.139<br>□ 当前主机的 IP<br>§ port=22122<br>□ 绑定的端口<br>§ base_path=/home/milo/fastDFS/tracker<br>□ log 目录<br>○ 启动 Tracker 服务<br>§ fdfs_trackerd /etc/fdfs/tracker.conf<br>§ sudo fdfs_trackerd /etc/fdfs/tracker.conf restart<br>§ sudo fdfs_trackerd /etc/fdfs/tracker.conf stop  </li><li>Storage（存储节点）<br>○ 修改配置文件<br>§ group_name=group1<br>□ 存储节点所属的组<br>§ bind_addr=192.168.52.139<br>□ 存储节点绑定的 IP<br>§ port=23000<br>□ 绑定的端口<br>§ base_path=/home/milo/fastDFS/storage<br>□ 存储日志文件的目录<br>§ store_path_count=1<br>□ 存储目录的个数<br>§ store_path0=/home/milo/fastDFS/storage<br>□ 配置具体的存储目录<br>§ tracker_server=192.168.52.139:22122<br>□ 连接 tracker 的时候使用的 IP 和端口<br>○ 启动 Stroage 服务<br>§ fdfs_storaged /etc/fdfs/storage.conf<br>§ sudo fdfs_storaged /etc/fdfs/storage.conf restart<br>§ sudo fdfs_storaged /etc/fdfs/storage.conf stop  </li><li>Client<br>○ 修改配置文件<br>§ base_path=/home/milo/fastDFS/client<br>□ log 日志目录<br>§ tracker_server=192.168.52.139:22122<br>□ 连接 tracker 时候需要的 iP 和端口信息  </li><li>检测当前 fdfs 环境是否是通的  </li></ol><h2 id="Storage-server-同步过程"><a href="#Storage-server-同步过程" class="headerlink" title="Storage server 同步过程"></a>Storage server 同步过程</h2><p>从 fastdfs 文件同步原理中我们知道 Storage server 之间的同步都是由一个独立线程负责的，<br>这个线程中的所有操作都是以同步方式执行的。比如一组服务器有 A、B、C 三台机器，那<br>么在每台机器上都有两个线程负责同步，如 A 机器，线程 1 负责同步数据到 B，线程 2 负责<br>同步数据到 C。每个同步线程负责到一台 Storage 的同步，以阻塞方式进行。<br>以 IP 为 192.168.1.1 的 Storage server 的 服 务 器 为 例 ， 它 的 同 步 目 录 下 有<br>192.168.1.2_33450.mark 192.168.1.3_33450.mark binlog.100 等文件现在 Storage server 将会从<br>ip 为 192.168.1.2 的 Storage server 的存储里面同步数据。<br>1 ） 打 开 对 应 Storage server 的 mark 文 件 ， 如 负 责 到 192.168.1.1 的 同 步 则 打 开<br>192.168.1.2_33450.mark 文件，从中读取 binlog_index、binlog_offset 两个字段值，如取到值<br>为：100、1000，那么就打开 binlog.100 文件，seek 到 1000 这个位置。<br>2）进入一个 while 循环，尝试着读取一行，若读取不到则睡眠等待。若读取到一行，并且<br>该行的操作方式为源操作，如 C、A、D、T（大写的都是），则将该行指定的操作同步给对<br>方（非源操作不需要同步），同步成功后更新 binlog_offset 标志，该值会定期写入到<br>192.168.1.2_33450.mark 文件之中。<br>同步过程中可能因为同步较为缓慢，导致可能在同步一个文件之前，文件已经被客户端删除，<br>此时同步线程将打印一条日志，然后直接处理后面的 Binlog。</p><h2 id="代码实现-fastDFS-文件上传和下载"><a href="#代码实现-fastDFS-文件上传和下载" class="headerlink" title="代码实现 fastDFS 文件上传和下载"></a>代码实现 fastDFS 文件上传和下载</h2><ol><li>fastDFS api 实现  </li><li>进程方式实现<br>○ 创建匿名管道<br>○ 创建子进程<br>○ 子进程中执行 execlp<br>&nbsp;§ 关闭读端<br>&nbsp;§ 将得到的文件 ID 写入管道<br>○ 父进程<br>&nbsp;§ 读管道<br>&nbsp;&nbsp;&nbsp;□ 关闭写端<br>&nbsp;&nbsp;&nbsp;□ 将 fileID 读到内存<br>&nbsp;&nbsp;&nbsp;□ 回收子进程 pcb  </li></ol><img src="/2020/10/28/FastDFS/1.png"><p>1.execlp()/execl 的区别  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">int execlp(const char * file,const char * arg,....); 直接指定可执行程序的名字，在执行时会搜索环境变量。</span><br><span class="line">/use/bin/fdfs_upload_file  </span><br><span class="line"></span><br><span class="line">int execl(const char *path, const char *arg, ...); 用户自己生成的，绝对路径</span><br></pre></td></tr></table></figure><p>2 父子进程始终共享的东西  </p><p>○ 文件描述符<br>&nbsp;§ open<br>&nbsp;§ pipe<br>○ 内存映射区 - - mmap(函数)  </p><p>3.子进程写管道<br>父进程读管道  </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;FastDFS 是一个开源的分布式文件系统，它对文件进行管理，功能包括：文件存储、文件同&lt;br&gt;步、文件访问（文件上传、文件下载）等，解决了大容量存储和负载均衡的问题。特别适合&lt;br&gt;以文件为载体的在线服务，如相册网站、视频网站等等。&lt;/p&gt;
&lt;h2 id=&quot;简述&quot;&gt;&lt;a 
      
    
    </summary>
    
      <category term="分布式" scheme="http://twh233.github.io/categories/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
    
      <category term="FastDFS" scheme="http://twh233.github.io/tags/FastDFS/"/>
    
  </entry>
  
  <entry>
    <title>FastCGI</title>
    <link href="http://twh233.github.io/2020/10/27/FastCGI/"/>
    <id>http://twh233.github.io/2020/10/27/FastCGI/</id>
    <published>2020-10-27T15:17:55.000Z</published>
    <updated>2020-10-28T15:39:17.227Z</updated>
    
    <content type="html"><![CDATA[<h1 id="FastCGI"><a href="#FastCGI" class="headerlink" title="FastCGI"></a>FastCGI</h1><h2 id="CGI"><a href="#CGI" class="headerlink" title="CGI"></a>CGI</h2><p>公共网关接口<br>Common Gateway Interface， 简称 CGI<br>在物理层面上是一段程序， 运行在服务器上，提供同客户端 HTML 页面的接口</p><h2 id="浏览器请求流程"><a href="#浏览器请求流程" class="headerlink" title="浏览器请求流程"></a>浏览器请求流程</h2><img src="/2020/10/27/FastCGI/1.png"><h2 id="CGI-工作流程"><a href="#CGI-工作流程" class="headerlink" title="CGI 工作流程"></a>CGI 工作流程</h2><img src="/2020/10/27/FastCGI/2.png"><h2 id="FastCGI-1"><a href="#FastCGI-1" class="headerlink" title="FastCGI"></a>FastCGI</h2><p>CGI每次都需要fork一个进程去处理，导致浪费服务器资源。<br>于是有了FastCGI管理CGI</p><img src="/2020/10/27/FastCGI/3.png"><h2 id="FastCGI-进程管理器"><a href="#FastCGI-进程管理器" class="headerlink" title="FastCGI 进程管理器"></a>FastCGI 进程管理器</h2><p>fastcgi 可使用 spawn-fcgi 或者 php-fpm 来管理 (fastcgi 进程管理器，有很多不同类型的)<br>nginx 下 fastcgi 与服务器是分离的</p><h3 id="spawn-fcgi"><a href="#spawn-fcgi" class="headerlink" title="spawn-fcgi"></a>spawn-fcgi</h3><p>• 相当一个代理工具<br>• 角色完成 nginx 和 fastcgi 之间的进程间通信  </p><h3 id="环境配置"><a href="#环境配置" class="headerlink" title="环境配置"></a>环境配置</h3><p>nginx 处理不了的指令, 交给 fastcgi 处理<br>• 数据需要转发<br>• 数据需要发送到指定的端口<br>• 处理一个指令 test<br>• url: <a href="http://192.168.52.139/test" target="_blank" rel="noopener">http://192.168.52.139/test</a>  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">location /test&#123;</span><br><span class="line">#配置 fastcgi 模块</span><br><span class="line">fastcgi_pass 127.0.0.1:9001;</span><br><span class="line">#IP:</span><br><span class="line">#127.0.0.1/localhost/192.168.52.139</span><br><span class="line">#端口:</span><br><span class="line">#将要处理的数据发送到 9001 端口</span><br><span class="line">#9001 端口对应一个进程, 该进程可以收到 nginx 发送过来的数据</span><br><span class="line">include fastcgi.conf;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="fastCGI-协议、Spawn-fcgi、Nginx-三者关系"><a href="#fastCGI-协议、Spawn-fcgi、Nginx-三者关系" class="headerlink" title="fastCGI 协议、Spawn-fcgi、Nginx 三者关系"></a>fastCGI 协议、Spawn-fcgi、Nginx 三者关系</h3><p>Nginx 是 web 服务器，只提供 HTTP 协议的输入和输出。<br>spawn-fcgi 服务器，只支持 Fastcgi 协议的输入和输出。<br>它们 2 者直接由 Nginx 将 HTTP 协议转换为 Fastcgi 协议传输给 fastCGI 进程处理。  </p><img src="/2020/10/27/FastCGI/4.png"><h3 id="与Tomcat区别"><a href="#与Tomcat区别" class="headerlink" title="与Tomcat区别"></a>与Tomcat区别</h3><img src="/2020/10/27/FastCGI/5.png">]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;FastCGI&quot;&gt;&lt;a href=&quot;#FastCGI&quot; class=&quot;headerlink&quot; title=&quot;FastCGI&quot;&gt;&lt;/a&gt;FastCGI&lt;/h1&gt;&lt;h2 id=&quot;CGI&quot;&gt;&lt;a href=&quot;#CGI&quot; class=&quot;headerlink&quot; title=
      
    
    </summary>
    
      <category term="FastCGI" scheme="http://twh233.github.io/categories/FastCGI/"/>
    
    
      <category term="FastCGI" scheme="http://twh233.github.io/tags/FastCGI/"/>
    
  </entry>
  
  <entry>
    <title>Makefile</title>
    <link href="http://twh233.github.io/2020/10/22/Makefile/"/>
    <id>http://twh233.github.io/2020/10/22/Makefile/</id>
    <published>2020-10-22T14:19:42.000Z</published>
    <updated>2020-10-25T03:20:28.250Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Makefile"><a href="#Makefile" class="headerlink" title="Makefile"></a>Makefile</h2><p>就是在命令前加了⼀个‘@’。 这⼀符号告诉 make，<br>在运⾏时不要将这⼀⾏命令显示出来。</p><p>make 在检查⼀个规则时，采⽤的⽅法是：如果先决条件中相关的⽂<br>件的时间戳⼤于⽬标的时间戳，即先决条件中的⽂件⽐⽬标更新，则知道有变化，那么需要运⾏规则当中<br>的命令重新构建⽬标。</p><h3 id="假目标"><a href="#假目标" class="headerlink" title="假目标"></a>假目标</h3><p>.PHONY: clean</p><h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><h3 id="自动变量"><a href="#自动变量" class="headerlink" title="自动变量"></a>自动变量</h3><p>$@⽤于表示⼀个规则中的⽬标。当我们的⼀个规则中有多个⽬标时，$@所指的是其中任何造成命令被<br>运⾏的⽬标。<br>$^则表示的是规则中的所有先择条件。<br>$&lt;表示的是规则中的第⼀个先决条件。  </p><h3 id="变量类别"><a href="#变量类别" class="headerlink" title="变量类别"></a>变量类别</h3><p>“=”  可递归</p><p>“:=” make 只对其进⾏⼀次扫描和替换  </p><p>“?=” 条件赋值的意思是当变量以前没有定义时，就定义它并且将左边的值赋值给它，如果已<br>经定义了那么就不再改变其值。条件赋值类似于提供了给变量赋缺省值的功能。  </p><h3 id="引用替换"><a href="#引用替换" class="headerlink" title="引用替换"></a>引用替换</h3><p>Makefile<br>.PHONY: all<br>foo = a.o b.o c.o<br>bar := $(foo:.o=.c)<br>all:<br>@echo “bar = $(bar)”  </p><p>执⾏<br>$make<br>bar = a.c b.c c.c  </p><h3 id="override"><a href="#override" class="headerlink" title="override"></a>override</h3><p>手动替换</p><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><img src="/2020/10/22/Makefile/1.png"><img src="/2020/10/22/Makefile/2.png"><h2 id="包含文件"><a href="#包含文件" class="headerlink" title="包含文件"></a>包含文件</h2><p>include $(DEPS)</p><p>-include $(DEPS)  忽略文件</p><h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line">PHONY: all clean</span><br><span class="line">MKDIR = mkdir</span><br><span class="line">RM = rm</span><br><span class="line">RMFLAGS = -fr</span><br><span class="line">CC = gcc</span><br><span class="line">AR = ar</span><br><span class="line">ARFLAGS = crs</span><br><span class="line">DIR_OBJS = objs</span><br><span class="line">DIR_EXES = $(ROOT)/build/exes</span><br><span class="line">DIR_DEPS = deps</span><br><span class="line">DIR_LIBS = $(ROOT)/build/libs</span><br><span class="line">DIRS = $(DIR_DEPS) $(DIR_OBJS) $(DIR_EXES) $(DIR_LIBS)</span><br><span class="line">RMS = $(DIR_OBJS) $(DIR_DEPS)</span><br><span class="line">ifneq ($(EXE), &quot;&quot;)</span><br><span class="line">EXE := $(addprefix $(DIR_EXES)/, $(EXE))</span><br><span class="line">RMS += $(EXE)</span><br><span class="line">endif</span><br><span class="line">ifneq ($(LIB), &quot;&quot;)</span><br><span class="line">LIB := $(addprefix $(DIR_LIBS)/, $(LIB))</span><br><span class="line">RMS += $(LIB)</span><br><span class="line">endif</span><br><span class="line">SRCS = $(wildcard *.c)</span><br><span class="line">OBJS = $(SRCS:.c=.o)</span><br><span class="line">OBJS := $(addprefix $(DIR_OBJS)/, $(OBJS))</span><br><span class="line">DEPS = $(SRCS:.c=.dep)</span><br><span class="line">DEPS := $(addprefix $(DIR_DEPS)/, $(DEPS))</span><br><span class="line">ifneq ($(EXE), &quot;&quot;)</span><br><span class="line">all: $(EXE)</span><br><span class="line">endif</span><br><span class="line">ifneq ($(LIB), &quot;&quot;)</span><br><span class="line">all: $(LIB)</span><br><span class="line">endif</span><br><span class="line">ifneq ($(MAKECMDGOALS), clean)</span><br><span class="line">include $(DEPS)</span><br><span class="line">endif</span><br><span class="line">ifneq ($(INC_DIRS), &quot;&quot;)</span><br><span class="line">INC_DIRS := $(strip $(INC_DIRS))</span><br><span class="line">INC_DIRS := $(addprefix -I, $(INC_DIRS))</span><br><span class="line">endif</span><br><span class="line">ifneq ($(LINK_LIBS), &quot;&quot;)</span><br><span class="line">LINK_LIBS := $(strip $(LINK_LIBS))</span><br><span class="line">LINK_LIBS := $(addprefix -l, $(LINK_LIBS))</span><br><span class="line">endif</span><br><span class="line">$(DIRS):</span><br><span class="line">$(MKDIR) $@</span><br><span class="line">$(EXE): $(DIR_EXES) $(OBJS)</span><br><span class="line">$(CC) -L$(DIR_LIBS) -o $@ $(filter %.o, $^) $(LINK_LIBS)</span><br><span class="line">$(LIB): $(DIR_LIBS) $(OBJS)</span><br><span class="line">$(AR) $(ARFLAGS) $@ $(filter %.o, $^)</span><br><span class="line">$(DIR_OBJS)/%.o: $(DIR_OBJS) %.c</span><br><span class="line">$(CC) $(INC_DIRS) -o $@ -c $(filter %.c, $^)</span><br><span class="line">$(DIR_DEPS)/%.dep: $(DIR_DEPS) %.c</span><br><span class="line">@echo &quot;Making $@ ...&quot;</span><br><span class="line">set -e ; \</span><br><span class="line">$(RM) $(RMFLAGS) $@.tmp ; \</span><br><span class="line">$(CC) $(INC_DIRS) -E -MM $(filter %.c, $^) &gt; $@.tmp ; \</span><br><span class="line">sed &apos;s,\(.*\)\.o[ :]*,objs/\1.o $@: ,g&apos; &lt; $@.tmp &gt; $@ ; \</span><br><span class="line">$(RM) $(RMFLAGS) $@.tmp</span><br><span class="line">clean:</span><br><span class="line">$(RM) $(RMFLAGS) $(RMS)</span><br><span class="line">source/foo/src/Makefile</span><br><span class="line">EXE =</span><br><span class="line">LIB = libfoo.a</span><br><span class="line">INC_DIRS = $(ROOT)/source/foo/inc</span><br><span class="line">LINK_LIBS =</span><br><span class="line">include $(ROOT)/build/make.rule</span><br><span class="line">source/huge/src/Makefile</span><br><span class="line">EXE = huge</span><br><span class="line">LIB =</span><br><span class="line">INC_DIRS = $(ROOT)/source/foo/inc</span><br><span class="line">LINK_LIBS = foo</span><br><span class="line">include $(ROOT)/build/make.rule</span><br></pre></td></tr></table></figure><p>执行<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">⽬录 /Makefile/huge/source/huge/src</span><br><span class="line">$make</span><br><span class="line">/Makefile/huge/build/make.rule:43: deps/main.dep: No such file or directory</span><br><span class="line">mkdir deps</span><br><span class="line">Making deps/main.dep ...</span><br><span class="line">mkdir objs</span><br><span class="line">gcc -I/Makefile/huge/source/foo/inc -o objs/main.o -c main.c</span><br><span class="line">gcc -L/Makefile/huge/build/libs -o /Makefile/huge/build/exes/huge objs/main.o -lfoo</span><br><span class="line">⽬录 /Makefile/huge/source/huge/src</span><br><span class="line">$$ROOT/build/exes/huge</span><br><span class="line">This is foo ()!</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">source/build/Makefile</span><br><span class="line">.PHONY: all clean</span><br><span class="line">DIRS = $(ROOT)/source/foo/src \</span><br><span class="line">$(ROOT)/source/bar/src \</span><br><span class="line">$(ROOT)/source/huge/src</span><br><span class="line">RM = rm</span><br><span class="line">RMFLAGS = -fr</span><br><span class="line">RMS = $(ROOT)/build/exes $(ROOT)/build/libs</span><br><span class="line">all:</span><br><span class="line">@set -e; \</span><br><span class="line">for dir in $(DIRS); \</span><br><span class="line">do \</span><br><span class="line">cd $$dir &amp;&amp; $(MAKE) ; \</span><br><span class="line">done</span><br><span class="line">@echo &quot;&quot;</span><br><span class="line">@echo &quot;:-) Completed&quot;</span><br><span class="line">@echo &quot;&quot;</span><br><span class="line">clean:</span><br><span class="line">@set -e; \</span><br><span class="line">for dir in $(DIRS); \</span><br><span class="line">do \</span><br><span class="line">cd $$dir &amp;&amp; $(MAKE) clean;\</span><br><span class="line">done</span><br><span class="line">$(RM) $(RMFLAGS) $(RMS)</span><br><span class="line">@echo &quot;&quot;</span><br><span class="line">@echo &quot;:-) Completed&quot;</span><br><span class="line">@echo &quot;&quot;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">⽬录 /Makefile/build</span><br><span class="line">$make</span><br><span class="line">make[1]: Entering directory `/Makefile/huge/source/foo/src&apos;</span><br><span class="line">/Makefile/huge/build/make.rule:43: deps/foo.dep: No such file or directory</span><br><span class="line">mkdir deps</span><br><span class="line">Making deps/foo.dep ...</span><br><span class="line">make[1]: Leaving directory `/Makefile/huge/source/foo/src&apos;</span><br><span class="line">make[1]: Entering directory `/Makefile/huge/source/foo/src&apos;</span><br><span class="line">mkdir /Makefile/huge/build/libs</span><br><span class="line">mkdir objs</span><br><span class="line">gcc -I/Makefile/huge/source/foo/inc -o objs/foo.o -c foo.c</span><br><span class="line">ar crs /Makefile/huge/build/libs/libfoo.a objs/foo.o</span><br><span class="line">make[1]: Leaving directory `/Makefile/huge/source/foo/src&apos;</span><br><span class="line">make[1]: Entering directory `/Makefile/huge/source/bar/src&apos;</span><br><span class="line">/Makefile/huge/build/make.rule:43: deps/bar.dep: No such file or director</span><br><span class="line">mkdir deps</span><br><span class="line">Making deps/bar.dep ...</span><br><span class="line">make[1]: Leaving directory `/Makefile/huge/source/bar/src&apos;</span><br><span class="line">make[1]: Entering directory `/Makefile/huge/source/bar/src&apos;</span><br><span class="line">mkdir objs</span><br><span class="line">gcc -I/Makefile/huge/source/bar/inc -o objs/bar.o -c bar.c</span><br><span class="line">ar crs /Makefile/huge/build/libs/libbar.a objs/bar.o</span><br><span class="line">make[1]: Leaving directory `/Makefile/huge/source/bar/src&apos;</span><br><span class="line">make[1]: Entering directory `/Makefile/huge/source/huge/src&apos;</span><br><span class="line">/Makefile/huge/build/make.rule:43: deps/main.dep: No such file or directory</span><br><span class="line">mkdir deps</span><br><span class="line">Making deps/main.dep ...</span><br><span class="line">make[1]: Leaving directory `/Makefile/huge/source/huge/src&apos;</span><br><span class="line">make[1]: Entering directory `/Makefile/huge/source/huge/src&apos;</span><br><span class="line">mkdir /Makefile/huge/build/exes</span><br><span class="line">mkdir objs</span><br><span class="line">gcc -I/Makefile/huge/source/foo/inc -I/Makefile/huge/source/bar/inc -o objs/main.o -c</span><br><span class="line">main.c</span><br><span class="line">gcc -L/Makefile/huge/build/libs -o /Makefile/huge/build/exes/huge objs/main.o -lfoo -lbar</span><br><span class="line">make[1]: Leaving directory `/Makefile/huge/source/huge/src&apos;</span><br><span class="line">:-) Completed</span><br><span class="line">⽬录 /Makefile/build</span><br><span class="line">$make clean</span><br><span class="line">make[1]: Entering directory `/Makefile/huge/source/foo/src&apos;</span><br><span class="line">rm -fr objs deps /Makefile/huge/build/libs/libfoo.a</span><br><span class="line">make[1]: Leaving directory `/Makefile/huge/source/foo/src&apos;</span><br><span class="line">make[1]: Entering directory `/Makefile/huge/source/bar/src&apos;</span><br><span class="line">rm -fr objs deps /Makefile/huge/build/libs/libbar.a</span><br><span class="line">make[1]: Leaving directory `/Makefile/huge/source/bar/src&apos;</span><br><span class="line">make[1]: Entering directory `/Makefile/huge/source/huge/src&apos;</span><br><span class="line">rm -fr objs deps /Makefile/huge/build/exes/huge</span><br><span class="line">make[1]: Leaving directory `/Makefile/huge/source/huge/src&apos;</span><br><span class="line">rm -fr /Makefile/huge/build/exes /Makefile/huge/build/libs</span><br><span class="line">:-) Completed</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Makefile&quot;&gt;&lt;a href=&quot;#Makefile&quot; class=&quot;headerlink&quot; title=&quot;Makefile&quot;&gt;&lt;/a&gt;Makefile&lt;/h2&gt;&lt;p&gt;就是在命令前加了⼀个‘@’。 这⼀符号告诉 make，&lt;br&gt;在运⾏时不要将这⼀⾏命令显示出
      
    
    </summary>
    
      <category term="基础" scheme="http://twh233.github.io/categories/%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="makefile" scheme="http://twh233.github.io/tags/makefile/"/>
    
  </entry>
  
  <entry>
    <title>Linux系统命令</title>
    <link href="http://twh233.github.io/2020/10/19/Linux%E7%B3%BB%E7%BB%9F%E5%91%BD%E4%BB%A4/"/>
    <id>http://twh233.github.io/2020/10/19/Linux系统命令/</id>
    <published>2020-10-19T12:44:13.000Z</published>
    <updated>2020-10-19T13:05:53.831Z</updated>
    
    <content type="html"><![CDATA[<h2 id="grep"><a href="#grep" class="headerlink" title="grep"></a>grep</h2><img src="/2020/10/19/Linux系统命令/1.png"><p>grep login -r msg_server/<br>反向查找，查找文件中，不包含 hello 的行。  </p><p>grep -v login ImUser.cpp<br>找出文件中包含 login 的行，并打印出行号</p><p>grep -n login ImUser.cpp<br>找出文件中包含 login 的行，打印出行号，并显示前后 3 行</p><p>grep -C 3 -n login ImUser.cpp<br>找出文件中包含 login 的行，打印出行号，并显示前后 3 行，并忽略大小写</p><p>grep -C 3 -i -n login ImUser.cpp</p><h2 id="find"><a href="#find" class="headerlink" title="find"></a>find</h2><p>find . -name FILE_NAME<br>find . -iname FILE_NAME 忽略文件名称大小写</p><h2 id="scp"><a href="#scp" class="headerlink" title="scp"></a>scp</h2><p>scp <a href="mailto:liaoqingfu@122.152.222.180" target="_blank" rel="noopener">liaoqingfu@122.152.222.180</a>:/home/liaoqingfu/test.txt . //下载文件<br>scp mi9.aac <a href="mailto:liaoqingfu@122.152.222.180" target="_blank" rel="noopener">liaoqingfu@122.152.222.180</a>:/home/liaoqingfu/ //上传文件<br>scp ‐r <a href="mailto:liaoqingfu@122.152.222.180" target="_blank" rel="noopener">liaoqingfu@122.152.222.180</a>:/home/liaoqingfu/ . //下载目录<br>scp ‐r test <a href="mailto:liaoqingfu@122.152.222.180" target="_blank" rel="noopener">liaoqingfu@122.152.222.180</a>:/home/liaoqingfu/ //上传目录  </p><h2 id="ls"><a href="#ls" class="headerlink" title="ls"></a>ls</h2><p> -t 可以查看最新修改的时间<br> -l 每行显示一个条目<br> -h 可以结合显示文件的 GB，MB 等(human)；<br> -R 递归显示<br> -n 显示组 id 和 gid  </p><p>ls -lt 按最新修改的时间排序，新修改的在前面显示。<br>ls -ltR 按最新修改的时间排序，新修改的在前面显示，并显示子目录的文件信息<br>ls -lh 以单位显示文件大小  </p><h2 id="wc"><a href="#wc" class="headerlink" title="wc"></a>wc</h2><p>wc 命令用于计算字数。 利用 wc 指令我们可以计算文件的 Byte 数、字数、或是列<br>数，若不指定文件名称、或是所给予的文件名为”-“，则 wc 指令会从标准输入设备读<br>取数据。</p><p>语法<br>wc [-clw][–help][–version][文件…] </p><p>参数：<br>-c 或–bytes 或–chars 只显示 Bytes 数。<br>-l 或–lines 只显示行数。<br>-w 或–words 只显示字数。<br>–help 在线帮助。<br>–version 显示版本信息。  </p><h2 id="pidstat"><a href="#pidstat" class="headerlink" title="pidstat"></a>pidstat</h2><p>pidstat 用于监控全部或指定的进程占用系统资源的情况，包括 CPU、内存、磁盘 I/O、<br>程切换、线程数等数据。</p><p>• -u：表示查看 cpu 相关的性能指标<br>• -w：表示查看上下文切换情况<br>• -t：查看线程相关的信息，默认是进程的;常与-w 结合使用(cpu 的上下文切换包<br>括进程的切换、线程的切换、中断的切换)<br>• -d：展示磁盘 I/O 统计数据<br>• -p：指明进程号<br>使用方式：pidstat [option] interval [count]  </p><p>[root@VM_0_3_centos ~]# pidstat -urd -p 24615<br>Linux 3.10.0-957.5.1.el7.x86_64 (VM_0_3_centos) 08/22/2019 _x86_64_ (1<br>CPU)<br>输出 CPU 的使用信息 -u<br>03:48:12 PM UID PID %usr %system %guest %CPU CPU Command<br>03:48:12 PM 0 24615 0.00 0.00 0.00 0.00 0 nginx<br>输出内存的使用信息 -r<br>03:48:12 PM UID PID minflt/s majflt/s VSZ RSS %MEM<br>Command<br>03:48:12 PM 0 24615 0.00 0.00 58252 24940 1.32 nginx<br>输出磁盘 I/O 的使用信息 -d<br>03:48:12 PM UID PID kB_rd/s kB_wr/s kB_ccwr/s Command<br>03:48:12 PM 0 24615 0.07 0.00 0.00 nginx  </p><p>03:20:54 PM UID PID cswch/s nvcswch/s Command<br>03:20:54 PM 0 24615 0.03 0.00 nginx</p><h2 id="free"><a href="#free" class="headerlink" title="free"></a>free</h2><p>此命令用于显示系统内存的使用情况，包括总体内存、己经使用的内存；还可用于显<br>示系统内核使用的缓冲区，包括缓冲（buffer）和缓存（cache）等。<br>使用方式：free<br>命令输出：<br><img src="/2020/10/19/Linux系统命令/2.png"></p><p>buffer: 攒数据，然后批量写入，比如硬盘数据的写入</p><p>cache: 低速设备到高速设备的缓存（预读），比如从硬盘读取数据，读取100字节，但实际读了4K到cache里面，下次直接从cache里取</p><h2 id="mpstat"><a href="#mpstat" class="headerlink" title="mpstat"></a>mpstat</h2><p>此命令用于实时监控系统 CPU 的一些统计信息，这些信息存放在/proc/stat 文件中，在<br>多核 CPU 系统里，不但能查看所有 CPU 的平均使用信息，还能查看某个特定 CPU 的信息。<br>使用方式：mpstat [-P {cpu|ALL}] [internal [count]]<br>当 mpstat 不带参数时，输出为从系统启动以来的平均值。</p><h2 id="df"><a href="#df" class="headerlink" title="df"></a>df</h2><p>硬盘使用情况</p><p>df -h </p><img src="/2020/10/19/Linux系统命令/3.png"><h2 id="nc"><a href="#nc" class="headerlink" title="nc"></a>nc</h2><p>验证服务器端口有没有开放</p><p>参数<br>-l 用于指定 nc 将处于侦听模式。指定该参数，则意味着 nc 被当作 server，侦听并<br>接受连接，而非向其它地址发起连接。<br>-p 暂未用到（老版本的 nc 可能需要在端口号前加-p 参数，下面测试环境是<br>centos6.6，nc 版本是 nc-1.84，未用到-p 参数）<br>-s 指定发送数据的源 IP 地址，适用于多网卡机<br>-u 指定 nc 使用 UDP 协议，默认为 TCP<br>-v 输出交互或出错信息，新手调试时尤为有用<br>-w 超时秒数，后面跟数字  </p><img src="/2020/10/19/Linux系统命令/4.png"><h2 id="nslookup"><a href="#nslookup" class="headerlink" title="nslookup"></a>nslookup</h2><p>解析IP地址</p><p>nslookup sina.com</p><h2 id="tcpdump"><a href="#tcpdump" class="headerlink" title="tcpdump"></a>tcpdump</h2><p>tcpdump 是网络状况分析和跟踪工具，是可以用来抓包的实用命令，使用前需要对<br>TCP/IP 有所熟悉，因为过滤使用的信息都是 TCP/IP 格式。</p><img src="/2020/10/19/Linux系统命令/5.png"><h2 id="proc"><a href="#proc" class="headerlink" title="proc"></a>proc</h2><p>Linux 系统内核提供了通过/proc 文件系统查看运行时内核内部数据结构的能力，也可<br>以改变内核参数设置。  </p><p>显示 CPU 信息：<br>cat /proc/cpuinfo</p><p>显示内存信息：<br>cat /proc/meminfo</p><p>显示详细的内存映射信息：<br>cat /proc/zoneinfo</p><p>显示磁盘映射信息：<br>cat /proc/mounts</p><p>查看系统平均负载命令：<br>cat /proc/loadavg</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;grep&quot;&gt;&lt;a href=&quot;#grep&quot; class=&quot;headerlink&quot; title=&quot;grep&quot;&gt;&lt;/a&gt;grep&lt;/h2&gt;&lt;img src=&quot;/2020/10/19/Linux系统命令/1.png&quot;&gt;
&lt;p&gt;grep login -r msg_serv
      
    
    </summary>
    
      <category term="linux" scheme="http://twh233.github.io/categories/linux/"/>
    
    
      <category term="linux" scheme="http://twh233.github.io/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>Valgrind/gdb</title>
    <link href="http://twh233.github.io/2020/10/15/Valgrind-gdb/"/>
    <id>http://twh233.github.io/2020/10/15/Valgrind-gdb/</id>
    <published>2020-10-15T06:47:03.000Z</published>
    <updated>2020-10-18T07:02:12.461Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Valgrind"><a href="#Valgrind" class="headerlink" title="Valgrind"></a>Valgrind</h1><p>Valgrind 是一套 Linux 下，开放源代码（ GPL V2）的仿真调试工具的集合。 Valgrind<br>由内核（ core）以及基于内核的其他调试工具组成。内核类似于一个框架（ framework），<br>它模拟了一个 CPU 环境，并提供服务给其他工具；而其他工具则类似于插件 (plug-in)，<br>利用内核提供的服务完成各种特定的内存调试任务。</p><p>1.编译安装 Valgrind<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">wget https://fossies.org/linux/misc/valgrind-3.15.0.tar.bz2</span><br><span class="line">tar -jxvf valgrind-3.15.0.tar.bz2</span><br><span class="line">cd valgrind-3.15.0</span><br><span class="line">./configure</span><br><span class="line">make</span><br><span class="line">sudo make install</span><br><span class="line">示例：</span><br><span class="line">alpha@alpha:~/share/gdb/valgrind$</span><br><span class="line">-g sample.c -o sample</span><br><span class="line">alpha@alpha:~/share/gdb/valgrind$ ls</span><br><span class="line">badacc.c badleak2.cpp badloop.c README.md sample.c valgrind-3.15.0</span><br><span class="line">badlap.c badleak.cpp badmac.cpp sample uninitial.c valgrind-3.15.0.tar.bz2</span><br><span class="line">alpha@alpha:~/share/gdb/valgrind$ valgrind ./sample</span><br><span class="line">==31558== Memcheck, a memory error detector</span><br><span class="line">==31558== LEAK SUMMARY:</span><br><span class="line">==31558== definitely lost: 40 bytes in 1 blocks</span><br><span class="line">==31558== indirectly lost: 0 bytes in 0 blocks</span><br><span class="line">==31558== possibly lost: 0 bytes in 0 blocks</span><br><span class="line">==31558== still reachable: 0 bytes in 0 blocks</span><br><span class="line">==31558== suppressed: 0 bytes in 0 blocks</span><br><span class="line">==31558== Rerun with --leak-check=full to see details of leaked memory</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">void fun( )</span><br><span class="line">&#123;</span><br><span class="line">int *p = (int *)malloc(10*sizeof(int));</span><br><span class="line">p[10] = 0;</span><br><span class="line">&#125;</span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">fun();</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>申请了空间，但是没有被释放<br>物理内存不一定连续，虚拟地址是连续的</p><h1 id="gdb"><a href="#gdb" class="headerlink" title="gdb"></a>gdb</h1><p>在编译时需要加上-g<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">–g –o hello_server hello_server.c</span><br><span class="line">alpha@alpha:~/share/gdb/gdb$ ls</span><br><span class="line">core_dump.c hello_server.c jump.c next.c redis-4.0.11.tar.gz step1.c watch.c</span><br><span class="line">alpha@alpha:~/share/gdb/gdb$</span><br><span class="line">-o hello_server hello_server.c</span><br><span class="line">alpha@alpha:~/share/gdb/gdb$ gdb hello_server</span><br><span class="line">GNU gdb (Ubuntu 7.7.1-0ubuntu5~14.04.3) 7.7.1</span><br><span class="line">Copyright (C) 2014 Free Software Foundation, Inc.</span><br><span class="line">License GPLv3+: GNU GPL version 3 or later &lt;http://gnu.org/licenses/gpl.html&gt;</span><br><span class="line">This is free software: you are free to change and redistribute it.</span><br><span class="line">There is NO WARRANTY, to the extent permitted by law. Type &quot;show copying&quot;</span><br><span class="line">and &quot;show warranty&quot; for details.</span><br><span class="line">This GDB was configured as &quot;x86_64-linux-gnu&quot;.</span><br><span class="line">Type &quot;show configuration&quot; for configuration details.</span><br><span class="line">For bug reporting instructions, please see:</span><br><span class="line">&lt;http://www.gnu.org/software/gdb/bugs/&gt;.</span><br><span class="line">Find the GDB manual and other documentation resources online at:</span><br><span class="line">&lt;http://www.gnu.org/software/gdb/documentation/&gt;.</span><br><span class="line">For help, type &quot;help&quot;.</span><br><span class="line">Type &quot;apropos word&quot; to search for commands related to &quot;word&quot;...</span><br><span class="line">Reading symbols from hello_server...(no debugging symbols found)...done.</span><br></pre></td></tr></table></figure></p><h2 id="调试-redis"><a href="#调试-redis" class="headerlink" title="调试 redis"></a>调试 redis</h2><p>安装 redis<br>1.下载源码并解压<br>wget <a href="http://download.redis.io/releases/redis-4.0.11.tar.gz" target="_blank" rel="noopener">http://download.redis.io/releases/redis-4.0.11.tar.gz</a><br>tar zxvf redis-4.0.11.tar.gz  </p><ol start="2"><li>进入 redis 源码目录并编译，注意编译时要生成调试符号并且关闭编译器优化选<br>项。<br>cd redis-4.0.11<br>make CFLAGS=”-g -O0” -j 2<br>由于 redis 是纯 C 项目，使用的编译器是 ，因而这里设置编译器的选项时使用的是 CFLAGS 选项；如<br>果项目使用的语言是 C++，那么使用的编译器一般是 g++，相对应的编译器选项是 CXXFLAGS。这点请<br>读者注意区别。另外，这里 makefile 使用了 -j 选项，其值是 2，表示开启 2 个进程同时编译，加<br>快编译速度。编译成功后，会在 src 目录下生成多个可执行程序，其中 redis-server 和 redis-cli 是需要调<br>试的程序。 进入 src 目录，使用 GDB 启动 redis-server 这个程序：<br>cd src<br>gdb ./redis-server  </li></ol><img src="/2020/10/15/Valgrind-gdb/1.png"><h2 id="gdb三种调试方式"><a href="#gdb三种调试方式" class="headerlink" title="gdb三种调试方式"></a>gdb三种调试方式</h2><h3 id="gdb-filename-直接调试目标程序"><a href="#gdb-filename-直接调试目标程序" class="headerlink" title="gdb filename 直接调试目标程序"></a>gdb filename 直接调试目标程序</h3><p>gdb ./hello_server  </p><h3 id="gdb-attach-pid-附加进程"><a href="#gdb-attach-pid-附加进程" class="headerlink" title="gdb attach pid 附加进程"></a>gdb attach pid 附加进程</h3><p>在某些情况下，一个程序已经启动了，我们想调试这个程序，但是又不想重启这个程序。 比如调试 redis。<br><img src="/2020/10/15/Valgrind-gdb/2.png"></p><p>得到 redis 进程 PID 为 35456，然后使用 gdb attach 35456，如果不是 root 权限需要加上 sudo，即是<br>sudo gdb attach 35456。</p><img src="/2020/10/15/Valgrind-gdb/3.png"><p>当用 gdb attach 上目标进程后，调试器会暂停下来，此时可以使用 continue 命令让程序继续运行，或者加<br>上相应的断点再继续运行程序。当调试完程序想结束此次调试时，而且不对当前进程 redis 有任何影响，<br>也就是说想让这个程序继续运行，可以在GDB 的命令行界面输入 detach 命令让程序与 GDB调试器分离，<br>这样 redis 就可以继续运行了：</p><img src="/2020/10/15/Valgrind-gdb/4.png"><h3 id="gdb-filename-corename-调试-core-文件"><a href="#gdb-filename-corename-调试-core-文件" class="headerlink" title="gdb filename corename 调试 core 文件"></a>gdb filename corename 调试 core 文件</h3><p>ulimit –c unlimited  暂时生效<br>产生 coredump 的条件发现 core file size 那一行默认是 0，表示关闭生成 core 文件，可以使用“ ulimit 选项名 设置值”来修改。例如，可以将 core 文件生成改成具体某个值（最大允许的字节数），这里我们使用 ulimit -c unlimited （ unlimited 是 -c 选项值）直接修改成不限制大小。将 ulimit -c unlimited 放入/etc/profile 中，然后执行 source /etc/profile 即可立即生效。即是：<br>（ 1） 将 ulimit -c unlimited 放入/etc/profile<br>（ 2） source /etc/profile<br>（ 3） 再次查看 ulimit -a<br>alpha@alpha:~/share/redis-4.0.11/src$ ulimit -a core file size          (blocks, -c) unlimited   </p><p>范例测试<br><img src="/2020/10/15/Valgrind-gdb/5.png"></p><p>编译运行<br><img src="/2020/10/15/Valgrind-gdb/6.png"></p><img src="/2020/10/15/Valgrind-gdb/7.png"><img src="/2020/10/15/Valgrind-gdb/8.png">]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Valgrind&quot;&gt;&lt;a href=&quot;#Valgrind&quot; class=&quot;headerlink&quot; title=&quot;Valgrind&quot;&gt;&lt;/a&gt;Valgrind&lt;/h1&gt;&lt;p&gt;Valgrind 是一套 Linux 下，开放源代码（ GPL V2）的仿真调试工具的集合。
      
    
    </summary>
    
      <category term="测试" scheme="http://twh233.github.io/categories/%E6%B5%8B%E8%AF%95/"/>
    
    
      <category term="测试" scheme="http://twh233.github.io/tags/%E6%B5%8B%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>log4cpp</title>
    <link href="http://twh233.github.io/2020/10/13/log4cpp/"/>
    <id>http://twh233.github.io/2020/10/13/log4cpp/</id>
    <published>2020-10-13T14:36:51.000Z</published>
    <updated>2020-10-13T14:39:53.550Z</updated>
    
    <content type="html"><![CDATA[<img src="/2020/10/13/log4cpp/1.png">]]></content>
    
    <summary type="html">
    
      
      
        &lt;img src=&quot;/2020/10/13/log4cpp/1.png&quot;&gt;

      
    
    </summary>
    
      <category term="日志" scheme="http://twh233.github.io/categories/%E6%97%A5%E5%BF%97/"/>
    
    
      <category term="log4cpp" scheme="http://twh233.github.io/tags/log4cpp/"/>
    
  </entry>
  
  <entry>
    <title>reactor模型</title>
    <link href="http://twh233.github.io/2020/10/12/reactor%E6%A8%A1%E5%9E%8B/"/>
    <id>http://twh233.github.io/2020/10/12/reactor模型/</id>
    <published>2020-10-12T14:31:23.000Z</published>
    <updated>2020-10-18T07:27:47.831Z</updated>
    
    <content type="html"><![CDATA[<p>作为一个高性能服务器程序通常需要考虑处理三类事件： I/O 事件，定时事件及信号。</p><p>应用程序需要提供相应的接口并注册到 Reactor 上，<br>如果相应的时间发生，Reactor 将主动调用应用程序注册的接口，所以Reactor译为反应堆。</p><p>Reactor 模型有三个重要的组件：<br> 多路复用器：由操作系统提供，在 linux 上一般是 select, poll, epoll 等系统调用。<br> 事件分发器：将多路复用器中返回的就绪事件分到对应的处理函数中。<br> 事件处理器：负责处理特定事件的处理函数。  </p><p>问题在于他是单线程，CPU现在的发展状况是以核心数上升。当程序需要使用多核资源时，Reactor 模型就会悲剧。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#include &lt;sys/socket.h&gt;</span><br><span class="line">#include &lt;sys/epoll.h&gt;</span><br><span class="line">#include &lt;arpa/inet.h&gt;</span><br><span class="line"></span><br><span class="line">#include &lt;fcntl.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#include &lt;errno.h&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#define BUFFER_LENGTH4096</span><br><span class="line">#define MAX_EPOLL_EVENTS1024</span><br><span class="line">#define SERVER_PORT8888</span><br><span class="line"></span><br><span class="line">typedef int NCALLBACK(int ,int, void*);</span><br><span class="line"></span><br><span class="line">struct ntyevent &#123;</span><br><span class="line">int fd;</span><br><span class="line">int events;</span><br><span class="line">void *arg;</span><br><span class="line">int (*callback)(int fd, int events, void *arg);</span><br><span class="line"></span><br><span class="line">int status;</span><br><span class="line">char buffer[BUFFER_LENGTH];</span><br><span class="line">int length;</span><br><span class="line">long last_active;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line"> * 核心是epoll和反应堆的管理</span><br><span class="line"> */</span><br><span class="line">struct ntyreactor &#123;</span><br><span class="line">int epfd;</span><br><span class="line">struct ntyevent *events;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int recv_cb(int fd, int events, void *arg);</span><br><span class="line">int send_cb(int fd, int events, void *arg);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">void nty_event_set(struct ntyevent *ev, int fd, NCALLBACK callback, void *arg) &#123;</span><br><span class="line"></span><br><span class="line">ev-&gt;fd = fd;</span><br><span class="line">ev-&gt;callback = callback;</span><br><span class="line">ev-&gt;events = 0;</span><br><span class="line">ev-&gt;arg = arg;</span><br><span class="line">ev-&gt;last_active = time(NULL);</span><br><span class="line"></span><br><span class="line">return ;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int nty_event_add(int epfd, int events, struct ntyevent *ev) &#123;</span><br><span class="line"></span><br><span class="line">struct epoll_event ep_ev = &#123;0, &#123;0&#125;&#125;;</span><br><span class="line">ep_ev.data.ptr = ev;</span><br><span class="line">ep_ev.events = ev-&gt;events = events;</span><br><span class="line"></span><br><span class="line">int op;</span><br><span class="line">if (ev-&gt;status == 1) &#123;</span><br><span class="line">op = EPOLL_CTL_MOD;</span><br><span class="line">&#125; else &#123;</span><br><span class="line">op = EPOLL_CTL_ADD;</span><br><span class="line">ev-&gt;status = 1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">if (epoll_ctl(epfd, op, ev-&gt;fd, &amp;ep_ev) &lt; 0) &#123;</span><br><span class="line">printf(&quot;event add failed [fd=%d], events[%d]\n&quot;, ev-&gt;fd, events);</span><br><span class="line">return -1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int nty_event_del(int epfd, struct ntyevent *ev) &#123;</span><br><span class="line"></span><br><span class="line">struct epoll_event ep_ev = &#123;0, &#123;0&#125;&#125;;</span><br><span class="line"></span><br><span class="line">if (ev-&gt;status != 1) &#123;</span><br><span class="line">return -1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ep_ev.data.ptr = ev;</span><br><span class="line">ev-&gt;status = 0;</span><br><span class="line">epoll_ctl(epfd, EPOLL_CTL_DEL, ev-&gt;fd, &amp;ep_ev);</span><br><span class="line"></span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int recv_cb(int fd, int events, void *arg) &#123;</span><br><span class="line"></span><br><span class="line">struct ntyreactor *reactor = (struct ntyreactor*)arg;</span><br><span class="line">struct ntyevent *ev = reactor-&gt;events+fd;</span><br><span class="line"></span><br><span class="line">int len = recv(fd, ev-&gt;buffer, BUFFER_LENGTH, 0);</span><br><span class="line">nty_event_del(reactor-&gt;epfd, ev);</span><br><span class="line"></span><br><span class="line">if (len &gt; 0) &#123;</span><br><span class="line"></span><br><span class="line">ev-&gt;length = len;</span><br><span class="line">ev-&gt;buffer[len] = &apos;\0&apos;;</span><br><span class="line"></span><br><span class="line">printf(&quot;C[%d]:%s\n&quot;, fd, ev-&gt;buffer);</span><br><span class="line"></span><br><span class="line">nty_event_set(ev, fd, send_cb, reactor);</span><br><span class="line">nty_event_add(reactor-&gt;epfd, EPOLLOUT, ev);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125; else if (len == 0) &#123;</span><br><span class="line"></span><br><span class="line">close(ev-&gt;fd);</span><br><span class="line">printf(&quot;[fd=%d] pos[%ld], closed\n&quot;, fd, ev-reactor-&gt;events);</span><br><span class="line"> </span><br><span class="line">&#125; else &#123;</span><br><span class="line"></span><br><span class="line">close(ev-&gt;fd);</span><br><span class="line">printf(&quot;recv[fd=%d] error[%d]:%s\n&quot;, fd, errno, strerror(errno));</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">return len;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int send_cb(int fd, int events, void *arg) &#123;</span><br><span class="line"></span><br><span class="line">struct ntyreactor *reactor = (struct ntyreactor*)arg;</span><br><span class="line">struct ntyevent *ev = reactor-&gt;events+fd;</span><br><span class="line"></span><br><span class="line">int len = send(fd, ev-&gt;buffer, ev-&gt;length, 0);</span><br><span class="line">if (len &gt; 0) &#123;</span><br><span class="line">printf(&quot;send[fd=%d], [%d]%s\n&quot;, fd, len, ev-&gt;buffer);</span><br><span class="line"></span><br><span class="line">nty_event_del(reactor-&gt;epfd, ev);</span><br><span class="line">nty_event_set(ev, fd, recv_cb, reactor);</span><br><span class="line">nty_event_add(reactor-&gt;epfd, EPOLLIN, ev);</span><br><span class="line"></span><br><span class="line">&#125; else &#123;</span><br><span class="line"></span><br><span class="line">close(ev-&gt;fd);</span><br><span class="line"></span><br><span class="line">nty_event_del(reactor-&gt;epfd, ev);</span><br><span class="line">printf(&quot;send[fd=%d] error %s\n&quot;, fd, strerror(errno));</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">return len;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int accept_cb(int fd, int events, void *arg) &#123;</span><br><span class="line"></span><br><span class="line">struct ntyreactor *reactor = (struct ntyreactor*)arg;</span><br><span class="line">if (reactor == NULL) return -1;</span><br><span class="line"></span><br><span class="line">struct sockaddr_in client_addr;</span><br><span class="line">socklen_t len = sizeof(client_addr);</span><br><span class="line"></span><br><span class="line">int clientfd;</span><br><span class="line"></span><br><span class="line">if ((clientfd = accept(fd, (struct sockaddr*)&amp;client_addr, &amp;len)) == -1) &#123;</span><br><span class="line">if (errno != EAGAIN &amp;&amp; errno != EINTR) &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">printf(&quot;accept: %s\n&quot;, strerror(errno));</span><br><span class="line">return -1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int i = 0;</span><br><span class="line">do &#123;</span><br><span class="line"></span><br><span class="line">for (i = 0;i &lt; MAX_EPOLL_EVENTS;i ++) &#123;</span><br><span class="line">if (reactor-&gt;events[i].status == 0) &#123;</span><br><span class="line">break;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">if (i == MAX_EPOLL_EVENTS) &#123;</span><br><span class="line">printf(&quot;%s: max connect limit[%d]\n&quot;, __func__, MAX_EPOLL_EVENTS);</span><br><span class="line">break;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int flag = 0;</span><br><span class="line">if ((flag = fcntl(clientfd, F_SETFL, O_NONBLOCK)) &lt; 0) &#123;</span><br><span class="line">printf(&quot;%s: fcntl nonblocking failed, %d\n&quot;, __func__, MAX_EPOLL_EVENTS);</span><br><span class="line">break;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">nty_event_set(&amp;reactor-&gt;events[clientfd], clientfd, recv_cb, reactor);</span><br><span class="line">nty_event_add(reactor-&gt;epfd, EPOLLIN, &amp;reactor-&gt;events[clientfd]);</span><br><span class="line"></span><br><span class="line">&#125; while (0);</span><br><span class="line"></span><br><span class="line">printf(&quot;new connect [%s:%d][time:%ld], pos[%d]\n&quot;, </span><br><span class="line">inet_ntoa(client_addr.sin_addr), ntohs(client_addr.sin_port), reactor-&gt;events[i].last_active, i);</span><br><span class="line"></span><br><span class="line">return 0;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int init_sock(short port) &#123;</span><br><span class="line"></span><br><span class="line">int fd = socket(AF_INET, SOCK_STREAM, 0);</span><br><span class="line">fcntl(fd, F_SETFL, O_NONBLOCK);</span><br><span class="line"></span><br><span class="line">struct sockaddr_in server_addr;</span><br><span class="line">memset(&amp;server_addr, 0, sizeof(server_addr));</span><br><span class="line">server_addr.sin_family = AF_INET;</span><br><span class="line">server_addr.sin_addr.s_addr = htonl(INADDR_ANY);</span><br><span class="line">server_addr.sin_port = htons(port);</span><br><span class="line"></span><br><span class="line">bind(fd, (struct sockaddr*)&amp;server_addr, sizeof(server_addr));</span><br><span class="line"></span><br><span class="line">if (listen(fd, 20) &lt; 0) &#123;</span><br><span class="line">printf(&quot;listen failed : %s\n&quot;, strerror(errno));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">return fd;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int ntyreactor_init(struct ntyreactor *reactor) &#123;</span><br><span class="line"></span><br><span class="line">if (reactor == NULL) return -1;</span><br><span class="line">memset(reactor, 0, sizeof(struct ntyreactor));</span><br><span class="line"></span><br><span class="line">reactor-&gt;epfd = epoll_create(1);</span><br><span class="line">if (reactor-&gt;epfd &lt;= 0) &#123;</span><br><span class="line">printf(&quot;create epfd in %s err %s\n&quot;, __func__, strerror(errno));</span><br><span class="line">return -2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">reactor-&gt;events = (struct ntyevent*)malloc((MAX_EPOLL_EVENTS) * sizeof(struct ntyevent));</span><br><span class="line">if (reactor-&gt;events == NULL) &#123;</span><br><span class="line">printf(&quot;create epfd in %s err %s\n&quot;, __func__, strerror(errno));</span><br><span class="line">close(reactor-&gt;epfd);</span><br><span class="line">return -3;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int ntyreactor_destory(struct ntyreactor *reactor) &#123;</span><br><span class="line"></span><br><span class="line">close(reactor-&gt;epfd);</span><br><span class="line">free(reactor-&gt;events);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int ntyreactor_addlistener(struct ntyreactor *reactor, int sockfd, NCALLBACK *acceptor) &#123;</span><br><span class="line"></span><br><span class="line">if (reactor == NULL) return -1;</span><br><span class="line">if (reactor-&gt;events == NULL) return -1;</span><br><span class="line"></span><br><span class="line">nty_event_set(&amp;reactor-&gt;events[sockfd], sockfd, acceptor, reactor);</span><br><span class="line">nty_event_add(reactor-&gt;epfd, EPOLLIN, &amp;reactor-&gt;events[sockfd]);</span><br><span class="line"></span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int ntyreactor_run(struct ntyreactor *reactor) &#123;</span><br><span class="line">if (reactor == NULL) return -1;</span><br><span class="line">if (reactor-&gt;epfd &lt; 0) return -1;</span><br><span class="line">if (reactor-&gt;events == NULL) return -1;</span><br><span class="line"></span><br><span class="line">struct epoll_event events[MAX_EPOLL_EVENTS+1];</span><br><span class="line"></span><br><span class="line">int checkpos = 0, i;</span><br><span class="line"></span><br><span class="line">while (1) &#123;</span><br><span class="line"></span><br><span class="line">long now = time(NULL);</span><br><span class="line">for (i = 0;i &lt; 100;i ++, checkpos ++) &#123;</span><br><span class="line">if (checkpos == MAX_EPOLL_EVENTS) &#123;</span><br><span class="line">checkpos = 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">if (reactor-&gt;events[checkpos].status != 1) &#123;</span><br><span class="line">continue;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">long duration = now - reactor-&gt;events[checkpos].last_active;</span><br><span class="line"></span><br><span class="line">if (duration &gt;= 60) &#123;</span><br><span class="line">close(reactor-&gt;events[checkpos].fd);</span><br><span class="line">printf(&quot;[fd=%d] timeout\n&quot;, reactor-&gt;events[checkpos].fd);</span><br><span class="line">nty_event_del(reactor-&gt;epfd, &amp;reactor-&gt;events[checkpos]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int nready = epoll_wait(reactor-&gt;epfd, events, MAX_EPOLL_EVENTS, 1000);</span><br><span class="line">if (nready &lt; 0) &#123;</span><br><span class="line">printf(&quot;epoll_wait error, exit\n&quot;);</span><br><span class="line">continue;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">for (i = 0;i &lt; nready;i ++) &#123;</span><br><span class="line"></span><br><span class="line">struct ntyevent *ev = (struct ntyevent*)events[i].data.ptr;</span><br><span class="line"></span><br><span class="line">if ((events[i].events &amp; EPOLLIN) &amp;&amp; (ev-&gt;events &amp; EPOLLIN)) &#123;</span><br><span class="line">ev-&gt;callback(ev-&gt;fd, events[i].events, ev-&gt;arg);</span><br><span class="line">&#125;</span><br><span class="line">if ((events[i].events &amp; EPOLLOUT) &amp;&amp; (ev-&gt;events &amp; EPOLLOUT)) &#123;</span><br><span class="line">ev-&gt;callback(ev-&gt;fd, events[i].events, ev-&gt;arg);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">int main(int argc, char *argv[]) &#123;</span><br><span class="line"></span><br><span class="line">unsigned short port = SERVER_PORT;</span><br><span class="line">if (argc == 2) &#123;</span><br><span class="line">port = atoi(argv[1]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int sockfd = init_sock(port);</span><br><span class="line"></span><br><span class="line">struct ntyreactor *reactor = (struct ntyreactor*)malloc(sizeof(struct ntyreactor));</span><br><span class="line">ntyreactor_init(reactor);</span><br><span class="line"></span><br><span class="line">ntyreactor_addlistener(reactor, sockfd, accept_cb);</span><br><span class="line">ntyreactor_run(reactor);</span><br><span class="line"></span><br><span class="line">ntyreactor_destory(reactor);</span><br><span class="line">close(sockfd);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="如何使用reactor实现百万并发"><a href="#如何使用reactor实现百万并发" class="headerlink" title="如何使用reactor实现百万并发"></a>如何使用reactor实现百万并发</h2><p>服务需要解决的问题：<br>1.操作系统fd的限制<br>2.Segmentation fault(core dumped)<br>3.端口的问题</p><p>客户端端口以及服务器端口，并且同时listen多个端口</p><p>遇到问题考虑tcp五元组(sip, dip, sport, dport, proto)  </p><img src="/2020/10/12/reactor模型/1.png">]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;作为一个高性能服务器程序通常需要考虑处理三类事件： I/O 事件，定时事件及信号。&lt;/p&gt;
&lt;p&gt;应用程序需要提供相应的接口并注册到 Reactor 上，&lt;br&gt;如果相应的时间发生，Reactor 将主动调用应用程序注册的接口，所以Reactor译为反应堆。&lt;/p&gt;
&lt;p&gt;
      
    
    </summary>
    
      <category term="基础" scheme="http://twh233.github.io/categories/%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="reactor" scheme="http://twh233.github.io/tags/reactor/"/>
    
  </entry>
  
  <entry>
    <title>消息队列和ZeroMQ</title>
    <link href="http://twh233.github.io/2020/10/09/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E5%92%8CZeroMQ/"/>
    <id>http://twh233.github.io/2020/10/09/消息队列和ZeroMQ/</id>
    <published>2020-10-09T08:56:28.000Z</published>
    <updated>2020-10-09T09:07:47.440Z</updated>
    
    <content type="html"><![CDATA[<h2 id="消息可靠性处理"><a href="#消息可靠性处理" class="headerlink" title="消息可靠性处理"></a>消息可靠性处理</h2><p>(1) 确认ACK，如果没有ACK就超时重传；<br>(2) 定义序列号，消息序号是连续，中间发现消息不连续的时候就知道丢了信息；<br>(3) 备份；<br>(4) 持久化 RocketMQ</p><h2 id="消息吞吐量"><a href="#消息吞吐量" class="headerlink" title="消息吞吐量"></a>消息吞吐量</h2><img src="/2020/10/09/消息队列和ZeroMQ/1.png"><h2 id="流量削峰"><a href="#流量削峰" class="headerlink" title="流量削峰"></a>流量削峰</h2><p>使用消息队列隔离网关和后端服务，以达到流量控制和保护后端服务的目的</p><img src="/2020/10/09/消息队列和ZeroMQ/2.png"><h2 id="模型"><a href="#模型" class="headerlink" title="模型"></a>模型</h2><img src="/2020/10/09/消息队列和ZeroMQ/3.png"><img src="/2020/10/09/消息队列和ZeroMQ/4.png">]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;消息可靠性处理&quot;&gt;&lt;a href=&quot;#消息可靠性处理&quot; class=&quot;headerlink&quot; title=&quot;消息可靠性处理&quot;&gt;&lt;/a&gt;消息可靠性处理&lt;/h2&gt;&lt;p&gt;(1) 确认ACK，如果没有ACK就超时重传；&lt;br&gt;(2) 定义序列号，消息序号是连续，中间发现消
      
    
    </summary>
    
      <category term="ZeroMQ" scheme="http://twh233.github.io/categories/ZeroMQ/"/>
    
    
      <category term="ZeroMQ" scheme="http://twh233.github.io/tags/ZeroMQ/"/>
    
  </entry>
  
  <entry>
    <title>内存池</title>
    <link href="http://twh233.github.io/2020/10/09/%E5%86%85%E5%AD%98%E6%B1%A0/"/>
    <id>http://twh233.github.io/2020/10/09/内存池/</id>
    <published>2020-10-09T08:02:09.000Z</published>
    <updated>2020-10-09T08:03:18.795Z</updated>
    
    <content type="html"><![CDATA[<img src="/2020/10/09/内存池/1.png"><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line"></span><br><span class="line">#include &lt;fcntl.h&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#define MP_ALIGNMENT       32</span><br><span class="line">#define MP_PAGE_SIZE4096</span><br><span class="line">#define MP_MAX_ALLOC_FROM_POOL(MP_PAGE_SIZE-1)</span><br><span class="line"></span><br><span class="line">#define mp_align(n, alignment) (((n)+(alignment-1)) &amp; ~(alignment-1))</span><br><span class="line">#define mp_align_ptr(p, alignment) (void *)((((size_t)p)+(alignment-1)) &amp; ~(alignment-1))</span><br><span class="line"></span><br><span class="line">struct mp_large_s &#123;</span><br><span class="line">    struct mp_large_s *next;</span><br><span class="line">    void *alloc;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">struct mp_node_s &#123;</span><br><span class="line"></span><br><span class="line">    unsigned char *last; // 已经使用区段末尾</span><br><span class="line">    unsigned char *end; // 整个数据区段末尾</span><br><span class="line"></span><br><span class="line">    struct mp_node_s *next;</span><br><span class="line">    size_t failed;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">struct mp_pool_s &#123;</span><br><span class="line"></span><br><span class="line">    size_t max;</span><br><span class="line"></span><br><span class="line">    struct mp_node_s *current; // 指向mp_node_s 结点</span><br><span class="line">    struct mp_large_s *large; //大块内存</span><br><span class="line"></span><br><span class="line">    struct mp_node_s head[0];</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">//内存池创建</span><br><span class="line">struct mp_pool_s *mp_create_pool(size_t size) &#123;</span><br><span class="line">    struct mp_pool_s *p;</span><br><span class="line">    int ret = posix_memalign((void **)&amp;p, MP_ALIGNMENT, size + sizeof(struct mp_pool_s) + sizeof(struct mp_node_s));</span><br><span class="line">    if (ret) &#123;</span><br><span class="line">        return NULL;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    p-&gt;max = (size &lt; MP_MAX_ALLOC_FROM_POOL) ? size : MP_MAX_ALLOC_FROM_POOL;</span><br><span class="line">    p-&gt;current = p-&gt;head;</span><br><span class="line">    p-&gt;large = NULL;</span><br><span class="line"></span><br><span class="line">    p-&gt;head-&gt;last = (unsigned char *)p + sizeof(struct mp_pool_s) + sizeof(struct mp_node_s);</span><br><span class="line">    p-&gt;head-&gt;end = p-&gt;head-&gt;last + size;</span><br><span class="line">    p-&gt;head-&gt;failed = 0;</span><br><span class="line"></span><br><span class="line">    return p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//内存池销毁</span><br><span class="line">void mp_destory_pool(struct mp_pool_s *pool) &#123;</span><br><span class="line"></span><br><span class="line">    struct mp_node_s *h, *n;</span><br><span class="line">    struct mp_large_s *l;</span><br><span class="line">    for (l = pool-&gt;large; l; l-&gt;next) &#123;</span><br><span class="line">        if (l-&gt;alloc) &#123;</span><br><span class="line">            free(l-&gt;alloc);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    h = pool-&gt;head-&gt;next;</span><br><span class="line">    while(h) &#123;</span><br><span class="line">        n = h-&gt;next;</span><br><span class="line">        free(h);</span><br><span class="line">        h = n;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    free(pool);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//释放大页内存</span><br><span class="line">void mp_free(struct mp_pool_s *pool, void *p) &#123;</span><br><span class="line"></span><br><span class="line">    struct mp_large_s *l;</span><br><span class="line">    for (l = pool-&gt;large; l; l = l-&gt;next) &#123;</span><br><span class="line">        if (p == l-&gt;alloc) &#123;</span><br><span class="line">            free(l-&gt;alloc);</span><br><span class="line">            l-&gt;alloc = NULL;</span><br><span class="line"></span><br><span class="line">            return ;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//内存池重置</span><br><span class="line">//1.释放large</span><br><span class="line">//2.将node节点last重置</span><br><span class="line">void mp_reset_pool(struct mp_pool_s *pool) &#123;</span><br><span class="line"></span><br><span class="line">    struct mp_node_s *h;</span><br><span class="line">    struct mp_large_s *l;</span><br><span class="line"></span><br><span class="line">    for (l = pool-&gt;large; l; l = l-&gt;next) &#123;</span><br><span class="line">        if (l-&gt;alloc) &#123;</span><br><span class="line">            free(l-&gt;alloc);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    pool-&gt;large = NULL;</span><br><span class="line">    for (h = pool-&gt;head; h; h = h-&gt;next) &#123;</span><br><span class="line">        h-&gt;last = (unsigned char *)h + sizeof(struct mp_node_s);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//分配小块内存</span><br><span class="line">static void *mp_alloc_block(struct mp_pool_s *pool, size_t size) &#123;</span><br><span class="line"></span><br><span class="line">    unsigned char *m;</span><br><span class="line">    struct mp_node_s *h = pool-&gt;head;</span><br><span class="line">    size_t psize = (size_t)(h-&gt;end - (unsigned char *)h);</span><br><span class="line"></span><br><span class="line">    int ret = posix_memalign((void **)&amp;m, MP_ALIGNMENT, psize);</span><br><span class="line">    if (ret) return NULL;</span><br><span class="line"></span><br><span class="line">    struct mp_node_s *p, *new_node, *current;</span><br><span class="line">    new_node = (struct mp_node_s*)m;</span><br><span class="line"></span><br><span class="line">    new_node-&gt;end = m + psize;</span><br><span class="line">    new_node-&gt;next = NULL;</span><br><span class="line">    new_node-&gt;failed = 0;</span><br><span class="line"></span><br><span class="line">    m += sizeof(struct mp_node_s);</span><br><span class="line">    m = mp_align_ptr(m, MP_ALIGNMENT);</span><br><span class="line">    new_node-&gt;last = m + size;</span><br><span class="line"></span><br><span class="line">    current = pool-&gt;current;</span><br><span class="line"></span><br><span class="line">    for(p = current; p-&gt;next; p = p-&gt;next) &#123;</span><br><span class="line">        if (p-&gt;failed++ &gt; 4) &#123;</span><br><span class="line">            current = p-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    p-&gt;next = new_node;</span><br><span class="line"></span><br><span class="line">    pool-&gt;current = current ? current : new_node;</span><br><span class="line">    return m;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//分配大块内存</span><br><span class="line">static void *mp_alloc_large(struct mp_pool_s *pool, size_t size) &#123;</span><br><span class="line"></span><br><span class="line">    void *p = malloc(size);</span><br><span class="line">    if (p == NULL) return NULL;</span><br><span class="line"></span><br><span class="line">    size_t n = 0;</span><br><span class="line">    struct mp_large_s *large;</span><br><span class="line">    for (large = pool-&gt;large; large; large = large-&gt;next) &#123;</span><br><span class="line">        if (large-&gt;alloc == NULL) &#123;</span><br><span class="line">            large-&gt;alloc = p;</span><br><span class="line">            return p;</span><br><span class="line">        &#125;</span><br><span class="line">        if (n ++ &gt; 3) break;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    large = mp_alloc(pool, sizeof(struct mp_large_s));</span><br><span class="line">    if (large == NULL) &#123;</span><br><span class="line">        free(p);</span><br><span class="line">        return NULL;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    large-&gt;alloc = p;</span><br><span class="line">    large-&gt;next = pool-&gt;large;</span><br><span class="line">    pool-&gt;large = large;</span><br><span class="line"></span><br><span class="line">    return p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//内存池分配</span><br><span class="line">void *mp_alloc(struct mp_pool_s *pool, size_t size) &#123;</span><br><span class="line"></span><br><span class="line">    unsigned char *m;</span><br><span class="line">    struct mp_node_s *p;</span><br><span class="line"></span><br><span class="line">    if (size &lt;= pool-&gt;max) &#123;</span><br><span class="line">        p = pool-&gt;current;</span><br><span class="line"></span><br><span class="line">        do &#123;</span><br><span class="line">            m = mp_align_ptr(p-&gt;last, MP_ALIGNMENT);</span><br><span class="line">            if((size_t)(p-&gt;end - m) &gt;= size) &#123;</span><br><span class="line">                p-&gt;last = m + size;</span><br><span class="line">                return m;</span><br><span class="line">            &#125;</span><br><span class="line">            p = p-&gt;next;</span><br><span class="line">        &#125; while (p);</span><br><span class="line"></span><br><span class="line">        return mp_alloc_block(pool, size);</span><br><span class="line">    &#125;</span><br><span class="line">    return mp_alloc_large(pool, size);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main(int argc, char *argv[]) &#123;</span><br><span class="line"></span><br><span class="line">    int size = 1 &lt;&lt; 12;</span><br><span class="line"></span><br><span class="line">    struct mp_pool_s *p = mp_create_pool(size);</span><br><span class="line"></span><br><span class="line">    int i = 0;</span><br><span class="line">    for (i = 0;i &lt; 10;i ++) &#123;</span><br><span class="line"></span><br><span class="line">        void *mp = mp_alloc(p, 512);</span><br><span class="line">//mp_free(mp);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //printf(&quot;mp_create_pool: %ld\n&quot;, p-&gt;max);</span><br><span class="line">    printf(&quot;mp_align(123, 32): %d, mp_align(17, 32): %d\n&quot;, mp_align(24, 32), mp_align(17, 32));</span><br><span class="line">    //printf(&quot;mp_align_ptr(p-&gt;current, 32): %lx, p-&gt;current: %lx, mp_align(p-&gt;large, 32): %lx, p-&gt;large: %lx\n&quot;, mp_align_ptr(p-&gt;current, 32), p-&gt;current, mp_align_ptr(p-&gt;large, 32), p-&gt;large);</span><br><span class="line"></span><br><span class="line">    int j = 0;</span><br><span class="line">    for (i = 0;i &lt; 5;i ++) &#123;</span><br><span class="line"></span><br><span class="line">        char *pp = mp_calloc(p, 32);</span><br><span class="line">        for (j = 0;j &lt; 32;j ++) &#123;</span><br><span class="line">            if (pp[j]) &#123;</span><br><span class="line">                printf(&quot;calloc wrong\n&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">            printf(&quot;calloc success\n&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //printf(&quot;mp_reset_pool\n&quot;);</span><br><span class="line"></span><br><span class="line">    for (i = 0;i &lt; 5;i ++) &#123;</span><br><span class="line">        void *l = mp_alloc(p, 8192);</span><br><span class="line">        mp_free(p, l);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mp_reset_pool(p);</span><br><span class="line"></span><br><span class="line">    //printf(&quot;mp_destory_pool\n&quot;);</span><br><span class="line">    for (i = 0;i &lt; 58;i ++) &#123;</span><br><span class="line">        mp_alloc(p, 256);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mp_destory_pool(p);</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;img src=&quot;/2020/10/09/内存池/1.png&quot;&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span cl
      
    
    </summary>
    
      <category term="基础" scheme="http://twh233.github.io/categories/%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="内存池" scheme="http://twh233.github.io/tags/%E5%86%85%E5%AD%98%E6%B1%A0/"/>
    
  </entry>
  
  <entry>
    <title>字符编码Unicode原理数据流压缩Zlib与Miniz的实现</title>
    <link href="http://twh233.github.io/2020/10/08/%E5%AD%97%E7%AC%A6%E7%BC%96%E7%A0%81Unicode%E5%8E%9F%E7%90%86%E6%95%B0%E6%8D%AE%E6%B5%81%E5%8E%8B%E7%BC%A9Zlib%E4%B8%8EMiniz%E7%9A%84%E5%AE%9E%E7%8E%B0/"/>
    <id>http://twh233.github.io/2020/10/08/字符编码Unicode原理数据流压缩Zlib与Miniz的实现/</id>
    <published>2020-10-08T06:31:46.000Z</published>
    <updated>2020-10-08T07:17:22.526Z</updated>
    
    <content type="html"><![CDATA[<p>字符Unicode其实是根据码表转化映射出图形。<br>根据码表找到位图文件显示出文字。</p><p>UTF-8 1-6字节<br>UTF-16 2或4字节<br>UTF-32 4字节  </p><p>通过前缀码，编译器可以知道是这个文件是按什么格式编码的。</p><p>Mysql的“uft8”不是真正的UTF-8，“utf8”只支持每个字符最多3个字节。</p><p>Mysql真正的UTF-8是”utf8mb4”。  </p><img src="/2020/10/08/字符编码Unicode原理数据流压缩Zlib与Miniz的实现/1.png">]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;字符Unicode其实是根据码表转化映射出图形。&lt;br&gt;根据码表找到位图文件显示出文字。&lt;/p&gt;
&lt;p&gt;UTF-8 1-6字节&lt;br&gt;UTF-16 2或4字节&lt;br&gt;UTF-32 4字节  &lt;/p&gt;
&lt;p&gt;通过前缀码，编译器可以知道是这个文件是按什么格式编码的。&lt;/p&gt;
&lt;
      
    
    </summary>
    
      <category term="基础" scheme="http://twh233.github.io/categories/%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="基础" scheme="http://twh233.github.io/tags/%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>Golang 系统监控</title>
    <link href="http://twh233.github.io/2020/10/07/Golang-%E7%B3%BB%E7%BB%9F%E7%9B%91%E6%8E%A7/"/>
    <id>http://twh233.github.io/2020/10/07/Golang-系统监控/</id>
    <published>2020-10-07T09:06:23.000Z</published>
    <updated>2020-10-07T09:07:06.729Z</updated>
    
    <content type="html"><![CDATA[<p>系统监控程序会定期的检查上次垃圾回收器什么时候执行的，如果发现已经有很长时间没有执行垃圾回收操作了，它就强制执行一次回收。  </p><p>它来定期扫描自由内存块，如果长时间不用，它就会建议操作系统把物理内存收回去。  </p><p>在函数头部插入一段汇编指令：<br>第一件事用来判断栈帧空间够不够用，不够用进行扩张<br>第二件事检查当前的G执行多长，如果系统调度发出抢占通知，立即中止G执行。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;系统监控程序会定期的检查上次垃圾回收器什么时候执行的，如果发现已经有很长时间没有执行垃圾回收操作了，它就强制执行一次回收。  &lt;/p&gt;
&lt;p&gt;它来定期扫描自由内存块，如果长时间不用，它就会建议操作系统把物理内存收回去。  &lt;/p&gt;
&lt;p&gt;在函数头部插入一段汇编指令：&lt;br&gt;
      
    
    </summary>
    
      <category term="基础" scheme="http://twh233.github.io/categories/%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="Golang" scheme="http://twh233.github.io/tags/Golang/"/>
    
  </entry>
  
  <entry>
    <title>Golang 并发</title>
    <link href="http://twh233.github.io/2020/10/07/Golang-%E5%B9%B6%E5%8F%91/"/>
    <id>http://twh233.github.io/2020/10/07/Golang-并发/</id>
    <published>2020-10-07T08:57:14.000Z</published>
    <updated>2020-10-07T09:06:57.960Z</updated>
    
    <content type="html"><![CDATA[<h2 id="PMG模型"><a href="#PMG模型" class="headerlink" title="PMG模型"></a>PMG模型</h2><img src="/2020/10/07/Golang-并发/1.png"><p>第一本地队列超过 256 个任务转移一半任务到全局队列，第二本地队列执行 60 个任务则到全局队列执行一个确保公平性。  </p><h2 id="runnext"><a href="#runnext" class="headerlink" title="runnext"></a>runnext</h2><p>G对象有runnext属性，记录最后一个G对象。执行 runnext 优先，然后 runq 队列。</p><h2 id="栈内存"><a href="#栈内存" class="headerlink" title="栈内存"></a>栈内存</h2><p>M 的所有的状态都保存在 G 任务栈，优点是在任意时 M 都能上下文切换。</p><p>M 使用的栈保存在 G 栈上，切换时只需要把 M 使用的 SP 等寄存器保存到 G 的寄存器上，保存后 M 就可以上下文切换。</p><p>G 自带栈可以从 2KB 扩容到 1GB，那么怎么扩容呢？实际上重新分配两倍的内存，然后把数据拷贝进来，栈指针指向新的地址，原来的释放掉，称之为拷贝栈。收缩也一样，创建小一点的块，把数据拷贝进来，用它来替换原来的释放。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;PMG模型&quot;&gt;&lt;a href=&quot;#PMG模型&quot; class=&quot;headerlink&quot; title=&quot;PMG模型&quot;&gt;&lt;/a&gt;PMG模型&lt;/h2&gt;&lt;img src=&quot;/2020/10/07/Golang-并发/1.png&quot;&gt;
&lt;p&gt;第一本地队列超过 256 个任务转移
      
    
    </summary>
    
      <category term="基础" scheme="http://twh233.github.io/categories/%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="Golang" scheme="http://twh233.github.io/tags/Golang/"/>
    
  </entry>
  
  <entry>
    <title>垃圾回收</title>
    <link href="http://twh233.github.io/2020/10/07/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/"/>
    <id>http://twh233.github.io/2020/10/07/垃圾回收/</id>
    <published>2020-10-07T08:55:34.000Z</published>
    <updated>2020-10-07T08:56:17.106Z</updated>
    
    <content type="html"><![CDATA[<h2 id="引用计数"><a href="#引用计数" class="headerlink" title="引用计数"></a>引用计数</h2><p>引用计数实现方式非常简单，每个对象头部有一个计数器，引用对象时计数器加一，取消引用时计数器减一，等于零时释放内存。</p><p>缺点：<br>1.易内存泄漏<br>2.不支持循环引用 </p><h2 id="代龄"><a href="#代龄" class="headerlink" title="代龄"></a>代龄</h2><p>代龄机制是这样的，对象通常分成三级代龄 0、1、2。新创建的对象的代龄是 0，每级代龄都有阈值，当 0 级对象数量超过阈值就会启动垃圾回收，垃圾回收扫描所有 0 级代龄对象，扫描完对象是活着或者死着两种状态。理论来说在第一次回收活着对象在第二次回收活着几率很高，垃圾回收器把第一次扫描活着对象标记为 1 级代龄对象，下次扫描 0 级代龄对象不用扫描第一次扫描过的对象，减少扫描对象的数量。当 1 级代龄对象数量超过阈值便扫描 1 级代龄对象，如果 1 级代龄还活着说明这个对象生命周期更长，就标记为 2 级代龄对象。  </p><p>优点1：减少扫描对象数量<br>优点2：支持内存压缩  </p><h2 id="标记清理"><a href="#标记清理" class="headerlink" title="标记清理"></a>标记清理</h2><p>回收器启动把所有对象标记成白色。A引用B，B变成灰色。白色可以释放。下次扫描灰色。<br>B变成黑色，如果B引用C。C依然是灰色。不断递归，只剩黑色和白色。那么黑色的都是活着的白色的都是死的。</p><h2 id="并发清理"><a href="#并发清理" class="headerlink" title="并发清理"></a>并发清理</h2><p>回收白色对象的时候可以和用户逻辑并发。</p><h2 id="写屏障"><a href="#写屏障" class="headerlink" title="写屏障"></a>写屏障</h2><p>一旦进入垃圾回收状态时进行短暂 STW 暂停，打开标记位标记为正在执行垃圾回收。扫描当时状态。<br>在垃圾回收阶段重新引用另外新对象，这个屏障把这种行为重新过滤。</p><h2 id="信用授权"><a href="#信用授权" class="headerlink" title="信用授权"></a>信用授权</h2><p>回收的速度跟不上分配的速度垃圾回收器会把用户逻辑暂停，用户逻辑暂停后不会有新的对象出现。<br>黑白对象标记完的对象数量累计到公共账户信用值，如果小于等于零则调度切换为垃圾回收，切换后不停的增加信用值和检查公共账户信用值，尽早提前结束切换执行用户代码，保证用户代码和垃圾回收的并行。  </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;引用计数&quot;&gt;&lt;a href=&quot;#引用计数&quot; class=&quot;headerlink&quot; title=&quot;引用计数&quot;&gt;&lt;/a&gt;引用计数&lt;/h2&gt;&lt;p&gt;引用计数实现方式非常简单，每个对象头部有一个计数器，引用对象时计数器加一，取消引用时计数器减一，等于零时释放内存。&lt;/p&gt;

      
    
    </summary>
    
      <category term="基础" scheme="http://twh233.github.io/categories/%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="垃圾回收" scheme="http://twh233.github.io/tags/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/"/>
    
  </entry>
  
  <entry>
    <title>内存分配器</title>
    <link href="http://twh233.github.io/2020/10/07/%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E5%99%A8/"/>
    <id>http://twh233.github.io/2020/10/07/内存分配器/</id>
    <published>2020-10-07T08:54:21.000Z</published>
    <updated>2020-10-07T08:55:13.154Z</updated>
    
    <content type="html"><![CDATA[<p>为了避免程序频繁的向操作系统申请，占用更多的空间延长内存的使用时间。可以一次性申请<br>多一部分的内存重复使用。例如：对象池、连接池。并且一次性申请大块内存可以做到连续分<br>配，通过相邻的地址空间的合并减少碎片化。  </p><h3 id="虚拟地址空间如何使用"><a href="#虚拟地址空间如何使用" class="headerlink" title="虚拟地址空间如何使用"></a>虚拟地址空间如何使用</h3><p>每个进程有一个虚拟地址空间，内存分配在某段虚拟地址空间内就能保证是连续的。</p><p>1.让操作系统随机开始，保留一段地址空间，如果失败，加上或者减去偏移量重新选择。<br>2.如果连续的方式不行使用分段的方式。空间扩展尝试同一方向扩展，失败则换个相反<br>方向扩展，这样空间还是连续的。操作系统随机从两个方向扩展的方式称之为稀疏堆。<br>3.使用一个数组。数组存储内存指针指向自由块，自由块有各种状态，比如当前使用多<br>少内存、是否是空闲状态等，形成类似反查表的作用。自由块的内存起始地址减去初始<br>位置得到偏移量，偏移量按页大小对齐作为数组索引。这样的优点是只需检查数组就知<br>道内存分配的信息、检查相邻的两项的是否空闲可以合并成大块内存。通过反查表实现<br>碎片化问题。</p><h3 id="Go管理内存框架"><a href="#Go管理内存框架" class="headerlink" title="Go管理内存框架"></a>Go管理内存框架</h3><p>内存分配的完整流程首先检查 Cache 里有没有自由块，有的话直接返回；没有的话计算<br>向哪个 Central 申请，如果 Central 有则取回一批，如果没有，则向Heap申请大块自由<br>块切割，如果Heap没有多余的自由块，Heap向操作系统申请。Go语言在初始化时建立一个<br>静态表，通过静态表知道一次取多少个，这个数字是基于大量的统计得到的，有些语言根<br>据程序运行期动态调整这个数字。  </p><p>任何时候内存管理都会涉及两个核心问题。  </p><p>第一个快速分配，比如实现无锁操作或者减少锁。因为 Central 被很多Cache共享，操作<br>数据必须加锁处理，Heap 被很多 Central 共享，操作数据要加锁。</p><p>第二个尽可能在内存复用方面做到平衡。快速操作意味着用批处理代替单次处理实现性能<br>提升，但是批处理会浪费大量的资源。所以一来用批处理来实现快速分配操作的性能，一<br>来实现内存节约避免快速消耗，需要在中间找到平衡点。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;为了避免程序频繁的向操作系统申请，占用更多的空间延长内存的使用时间。可以一次性申请&lt;br&gt;多一部分的内存重复使用。例如：对象池、连接池。并且一次性申请大块内存可以做到连续分&lt;br&gt;配，通过相邻的地址空间的合并减少碎片化。  &lt;/p&gt;
&lt;h3 id=&quot;虚拟地址空间如何使用&quot;&gt;
      
    
    </summary>
    
      <category term="基础" scheme="http://twh233.github.io/categories/%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="内存" scheme="http://twh233.github.io/tags/%E5%86%85%E5%AD%98/"/>
    
  </entry>
  
</feed>
